xquery version "1.0" encoding "UTF-8";

(: This file was generated on Fri Sep 16, 2011 22:23 by REx v5.9 which is Copyright (c) 1979-2011 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: XQueryV10.ebnf -xquery -tree :)

(:~
 : The parser that was generated for the XQueryV10 grammar.
 :)
module namespace p="XQueryV10";

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  61, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
  8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
  29, 26, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 30, 30, 30, 30, 30, 30, 32, 6, 33, 6, 30, 6, 34, 35,
  36, 37, 38, 39, 40, 41, 42, 30, 30, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 30, 57, 58, 59, 6, 6
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  216, 291, 323, 383, 415, 908, 351, 815, 815, 447, 479, 511, 543, 575, 621, 882, 589, 681, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 713, 745, 821, 649, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 777, 809, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 259, 815,
  815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 853, 940, 949, 941, 941, 957, 965, 973, 979, 987, 1267, 1010, 1027, 1046,
  1054, 1062, 1070, 1275, 1275, 1275, 1275, 1275, 1275, 1424, 1275, 1267, 1267, 1268, 1267, 1267, 1267, 1268, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1269, 1275, 1275, 1275, 1275, 1275, 1275,
  1275, 1275, 1275, 1275, 1275, 1267, 1267, 1267, 1267, 1267, 1267, 1355, 1268, 1266, 1265, 1267, 1267, 1267, 1267,
  1267, 1268, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1271, 1035, 1267, 1267, 1267, 1267, 1196, 1038, 1267,
  1267, 1267, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267,
  1267, 1274, 1275, 1037, 1273, 1275, 1401, 1275, 1275, 1275, 1275, 1275, 1266, 1267, 1267, 1272, 1133, 1321, 1400,
  1275, 1395, 1401, 1133, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1357, 1267, 1268, 1144, 1395, 1310, 1209,
  1395, 1401, 1395, 1395, 1395, 1395, 1395, 1395, 1395, 1395, 1397, 1275, 1275, 1275, 1401, 1275, 1275, 1275, 1380,
  1244, 1267, 1267, 1264, 1267, 1267, 1267, 1267, 1268, 1268, 1411, 1265, 1267, 1271, 1275, 1266, 1091, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1266, 1091, 1267, 1267, 1267, 1267, 1100, 1275, 1267, 1267, 1267, 1267, 1267,
  1267, 1113, 1122, 1267, 1267, 1267, 1114, 1269, 1273, 1437, 1267, 1267, 1267, 1267, 1267, 1267, 1162, 1395, 1397,
  1210, 1267, 1180, 1395, 1275, 1275, 1437, 1113, 1356, 1267, 1267, 1265, 1194, 1205, 1171, 1183, 1424, 1220, 1180,
  1395, 1273, 1275, 1231, 1254, 1356, 1267, 1267, 1265, 1083, 1205, 1186, 1183, 1275, 1242, 1425, 1395, 1252, 1275,
  1437, 1243, 1264, 1267, 1267, 1265, 1262, 1162, 1285, 1105, 1275, 1275, 994, 1395, 1275, 1275, 1437, 1113, 1356, 1267,
  1267, 1265, 1353, 1162, 1211, 1183, 1425, 1220, 1125, 1395, 1275, 1275, 1002, 1015, 1298, 1294, 1197, 1015, 1135,
  1125, 1212, 1209, 1424, 1275, 1424, 1395, 1275, 1275, 1437, 1091, 1265, 1267, 1267, 1265, 1092, 1125, 1286, 1209,
  1426, 1275, 1125, 1395, 1275, 1275, 1002, 1091, 1265, 1267, 1267, 1265, 1092, 1125, 1286, 1209, 1426, 1277, 1125,
  1395, 1275, 1275, 1002, 1091, 1265, 1267, 1267, 1265, 1267, 1125, 1172, 1209, 1424, 1275, 1125, 1395, 1275, 1275,
  1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1267,
  1267, 1267, 1267, 1269, 1275, 1267, 1267, 1267, 1267, 1268, 1275, 1266, 1267, 1267, 1267, 1267, 1268, 1306, 1400,
  1318, 1396, 1395, 1401, 1275, 1275, 1275, 1275, 1223, 1330, 1036, 1266, 1340, 1350, 1306, 1154, 1365, 1397, 1395,
  1401, 1275, 1275, 1275, 1275, 1277, 1019, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1272, 1275,
  1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1262, 1082, 1272, 1275, 1275,
  1275, 1275, 1409, 1274, 1409, 1196, 1033, 1342, 1195, 1222, 1275, 1275, 1275, 1275, 1277, 1275, 1332, 1276, 1296,
  1272, 1275, 1275, 1275, 1275, 1420, 1274, 1422, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1271, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267,
  1267, 1273, 1267, 1267, 1269, 1269, 1267, 1267, 1267, 1267, 1269, 1269, 1267, 1412, 1267, 1267, 1267, 1269, 1267,
  1267, 1267, 1267, 1267, 1267, 1091, 1136, 1234, 1270, 1114, 1271, 1267, 1270, 1234, 1270, 1076, 1275, 1275, 1275,
  1266, 1322, 1170, 1275, 1266, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1270, 999, 1266, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1434, 1035, 1267, 1267, 1267, 1267, 1270, 1275, 1275, 1275, 1275, 1275,
  1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275,
  1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1395, 1398, 1378, 1275, 1275, 1275, 1267, 1267, 1267, 1267, 1267,
  1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1271, 1275, 1275, 1275,
  1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1401, 1395, 1401, 1388, 1370, 1267, 1266, 1267, 1267, 1267, 1273,
  1394, 1395, 1286, 1399, 1285, 1394, 1395, 1397, 1394, 1378, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1266,
  1267, 1267, 1267, 1268, 1422, 1266, 1267, 1267, 1267, 1268, 1275, 1394, 1395, 1168, 1395, 1395, 1150, 1375, 1275,
  1267, 1267, 1267, 1272, 1272, 1275, 61, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
  11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 26, 30, 6, 6,
  6, 6, 6, 60, 60, 6, 6, 60, 60, 6, 30, 30, 30, 30, 30, 30, 30, 31, 30, 30, 30, 6, 6, 6, 30, 30, 6, 6, 30, 6, 30, 30,
  30, 32, 6, 33, 6, 30, 6, 6, 6, 6, 6, 30, 30, 30, 30, 30, 30, 6, 34, 35, 36, 37, 38, 39, 40, 41, 42, 30, 30, 43, 44,
  45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 30, 57, 58, 59, 6, 6, 6, 6, 6, 60, 6, 30, 6, 30, 30, 6, 30, 30, 6, 30,
  30, 30, 30, 30, 6, 30, 30, 30, 30, 30, 6, 60, 60, 60, 60, 6, 60, 60, 60, 6, 6, 30, 30, 30, 30, 30, 6, 6, 30, 30, 30,
  6, 6, 30, 30, 6, 6, 6, 6, 60, 60, 60, 30, 30, 30, 30, 30, 30, 30, 6, 30, 6, 30, 30, 30, 30, 6, 30, 60, 60, 6, 60, 60,
  60, 6, 60, 60, 30, 6, 6, 30, 30, 6, 6, 60, 30, 60, 60, 6, 60, 60, 60, 60, 60, 6, 6, 60, 60, 30, 30, 60, 60, 6, 6, 60,
  60, 60, 6, 6, 6, 6, 60, 30, 6, 30, 6, 6, 6, 30, 30, 6, 6, 6, 30, 30, 6, 6, 60, 6, 60, 60, 60, 60, 6, 6, 6, 60, 60, 6,
  6, 6, 6, 30, 30, 6, 30, 6, 6, 30, 6, 6, 60, 6, 6, 30, 30, 30, 6, 30, 30, 6, 30, 30, 30, 30, 6, 30, 6, 30, 30, 60, 60,
  30, 30, 30, 6, 6, 6, 6, 30, 30, 6, 30, 30, 6, 30, 30, 30, 30, 30, 30, 30, 30, 6, 6, 6, 6, 6, 6, 6, 6, 30, 6, 60, 60,
  60, 60, 60, 60, 6, 60, 60, 6, 30, 30, 6, 30, 6, 30, 30, 30, 30, 6, 6, 30, 60, 30, 30, 60, 60, 60, 60, 60, 30, 30, 60,
  30, 30, 30, 30, 30, 30, 60, 60, 60, 60, 60, 60, 30, 6, 30, 6, 6, 30, 6, 6, 30, 30, 6, 30, 30, 30, 6, 30, 6, 30, 6, 30,
  6, 6, 30, 30, 6, 30, 30, 6, 6, 30, 30, 30, 30, 30, 6, 30, 30, 30, 30, 30, 6, 60, 6, 6, 6, 6, 60, 60, 6, 60, 6, 6, 6,
  6, 6, 6, 30, 60, 6, 6, 6, 6, 6, 60, 6, 60, 60, 60, 60, 60, 60, 60, 60, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 30, 6, 30, 6, 30,
  6, 30, 6, 6, 6, 30, 6, 6, 6, 6, 6, 6, 6, 60, 60, 6, 30, 30, 30, 6, 60, 60, 60, 6, 30, 30, 30
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 65536, 65533, 1114111, 6, 6
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  6145, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 2071, 4119, 24, 25, 26, 27, 28, 29,
  30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58,
  59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,
  88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113,
  114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136,
  137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
  160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 7936, 7950, 7994, 7996, 7994,
  7994, 7994, 7964, 7994, 7975, 7991, 8012, 18072, 10890, 9741, 9742, 18014, 8386, 9742, 8575, 8567, 10198, 8581, 12651,
  8053, 9617, 9644, 8475, 8092, 8108, 8120, 8144, 9096, 8173, 8128, 8209, 8233, 16629, 9742, 13917, 8276, 8325, 19222,
  8341, 8357, 9066, 8157, 8352, 8879, 9742, 23245, 9742, 8374, 8406, 9109, 8872, 8447, 8435, 8422, 19234, 19129, 8463,
  8491, 8525, 8541, 8611, 8533, 9026, 12316, 18006, 8557, 8597, 8692, 8676, 8714, 8738, 8776, 8804, 8788, 8820, 20057,
  8859, 8895, 8911, 8947, 8963, 8979, 8995, 9011, 8637, 8358, 9060, 8184, 8193, 9082, 8921, 8931, 9145, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9171, 9742, 9742, 9662, 9742, 9742, 9742, 9191, 9217, 9232,
  14098, 9266, 9742, 10890, 9741, 13790, 18014, 8386, 9742, 8575, 8567, 10198, 10204, 9321, 8053, 9617, 9644, 8475,
  8092, 8108, 8120, 8144, 9096, 8173, 8128, 8209, 8233, 16629, 9742, 13917, 8276, 8325, 19222, 8341, 8357, 9066, 8157,
  8352, 8879, 9742, 23245, 9742, 8374, 8406, 9109, 8872, 8447, 8435, 8422, 19234, 19129, 8463, 8491, 8525, 8541, 8611,
  8533, 9026, 12316, 18006, 8557, 8597, 8692, 8676, 8714, 8738, 8776, 8804, 8788, 8820, 20057, 8859, 8895, 8911, 8947,
  8963, 8979, 8995, 9011, 8637, 8358, 9060, 8184, 8193, 9082, 8921, 8931, 9145, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9375, 9400, 9742, 9882, 9425, 9742, 9457, 9443, 9742, 9742, 9475, 9513, 9742, 10890,
  9741, 9552, 18014, 8386, 9742, 8575, 8567, 10198, 8581, 9384, 8053, 9617, 9644, 8475, 8092, 8108, 8120, 8144, 9096,
  8173, 8128, 8209, 8233, 16629, 9742, 13917, 8276, 8325, 19222, 8341, 8357, 9066, 8157, 8352, 8879, 9742, 23245, 9742,
  8374, 8406, 9109, 8872, 8447, 8435, 8422, 19234, 19129, 8463, 8491, 8525, 8541, 8611, 8533, 9026, 12316, 18006, 8557,
  8597, 8692, 8676, 8714, 8738, 8776, 8804, 8788, 8820, 20057, 8859, 8895, 8911, 8947, 8963, 8979, 8995, 9011, 8637,
  8358, 9060, 8184, 8193, 9082, 8921, 8931, 9145, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9569, 9742, 9742, 9662, 9742, 9742, 9742, 9191, 9742, 9742, 9742, 9604, 9742, 10890, 9642, 9660, 18014, 8386, 9742,
  8575, 8567, 10198, 8581, 13333, 8053, 9617, 9644, 8475, 8092, 8108, 8120, 8144, 9096, 8173, 8128, 8209, 8233, 16629,
  9742, 13917, 8276, 8325, 19222, 8341, 8357, 9066, 8157, 8352, 8879, 9742, 23245, 9742, 8374, 8406, 9109, 8872, 8447,
  8435, 8422, 19234, 19129, 8463, 8491, 8525, 8541, 8611, 8533, 9026, 12316, 18006, 8557, 8597, 8692, 8676, 8714, 8738,
  8776, 8804, 8788, 8820, 20057, 8859, 8895, 8911, 8947, 8963, 8979, 8995, 9011, 8637, 8358, 9060, 8184, 8193, 9082,
  8921, 8931, 9145, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9678, 17657, 9742, 9662, 18651,
  9742, 17665, 9191, 9742, 17662, 9700, 9266, 9742, 10890, 9741, 9742, 18014, 8386, 9742, 8575, 8567, 10198, 8581,
  12651, 8053, 9617, 9644, 8475, 8092, 8108, 8120, 8144, 9096, 8173, 8128, 8209, 8233, 16629, 9742, 13917, 8276, 8325,
  19222, 8341, 8357, 9066, 8157, 8352, 8879, 9742, 23245, 9742, 8374, 8406, 9109, 8872, 8447, 8435, 8422, 19234, 19129,
  8463, 8491, 8525, 8541, 8611, 8533, 9026, 12316, 18006, 8557, 8597, 8692, 8676, 8714, 8738, 8776, 8804, 8788, 8820,
  20057, 8859, 8895, 8911, 8947, 8963, 8979, 8995, 9011, 8637, 8358, 9060, 8184, 8193, 9082, 8921, 8931, 9145, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9171, 9742, 9742, 9662, 9742, 9742, 9742, 9191, 9742,
  9742, 9742, 9266, 9742, 10890, 9741, 9742, 18014, 8386, 9742, 8575, 8567, 10198, 8581, 12651, 8053, 9617, 9644, 8475,
  8092, 8108, 8120, 8144, 9096, 8173, 8128, 8209, 8233, 16629, 9742, 13917, 8276, 8325, 19222, 8341, 8357, 9066, 8157,
  8352, 8879, 9742, 23245, 9742, 8374, 8406, 9109, 8872, 8447, 8435, 8422, 19234, 19129, 8463, 8491, 8525, 8541, 8611,
  8533, 9026, 12316, 18006, 8557, 8597, 8692, 8676, 8714, 8738, 8776, 8804, 8788, 8820, 20057, 8859, 8895, 8911, 8947,
  8963, 8979, 8995, 9011, 8637, 8358, 9060, 8184, 8193, 9082, 8921, 8931, 9145, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9171, 9742, 9742, 9662, 9742, 9742, 9742, 9716, 9742, 9742, 9742, 9760, 9742, 10890,
  9741, 9742, 18014, 8386, 9742, 8575, 8567, 10198, 8581, 12651, 8053, 9617, 9644, 8475, 8092, 8108, 8120, 8144, 9096,
  8173, 8128, 8209, 8233, 16629, 9742, 13917, 8276, 8325, 19222, 8341, 8357, 9066, 8157, 8352, 8879, 9742, 23245, 9742,
  8374, 8406, 9109, 8872, 8447, 8435, 8422, 19234, 19129, 8463, 8491, 8525, 8541, 8611, 8533, 9026, 12316, 18006, 8557,
  8597, 8692, 8676, 8714, 8738, 8776, 8804, 8788, 8820, 20057, 8859, 8895, 8911, 8947, 8963, 8979, 8995, 9011, 8637,
  8358, 9060, 8184, 8193, 9082, 8921, 8931, 9145, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9797, 9819, 9742, 9497, 9880, 9742, 9495, 9850, 9742, 9742, 9865, 9898, 9742, 10890, 9741, 12110, 18014, 8386, 9742,
  8575, 8567, 10198, 8581, 9803, 8053, 9617, 9644, 8475, 8092, 8108, 8120, 8144, 9096, 8173, 8128, 8209, 8233, 16629,
  9742, 13917, 8276, 8325, 19222, 8341, 8357, 9066, 8157, 8352, 8879, 9742, 23245, 9742, 8374, 8406, 9109, 8872, 8447,
  8435, 8422, 19234, 19129, 8463, 8491, 8525, 8541, 8611, 8533, 9026, 12316, 18006, 8557, 8597, 8692, 8676, 8714, 8738,
  8776, 8804, 8788, 8820, 20057, 8859, 8895, 8911, 8947, 8963, 8979, 8995, 9011, 8637, 8358, 9060, 8184, 8193, 9082,
  8921, 8931, 9145, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9927, 9155, 9982, 9984, 9974,
  9982, 9982, 9950, 9964, 10000, 10029, 9266, 9742, 21826, 9741, 9742, 18014, 8386, 9742, 8575, 8567, 10198, 8581,
  12651, 8053, 14190, 9644, 8475, 8092, 8108, 8120, 8144, 9096, 8173, 8128, 8209, 8233, 16629, 9742, 13917, 8276, 8325,
  19222, 8341, 8357, 9066, 8157, 8352, 8879, 9742, 23245, 9742, 8374, 8406, 9109, 8872, 8447, 8435, 8422, 19234, 19129,
  8463, 8491, 8525, 8541, 8611, 8533, 9026, 12316, 18006, 8557, 8597, 8692, 8676, 8714, 8738, 8776, 8804, 8788, 8820,
  20057, 8859, 8895, 8911, 8947, 8963, 8979, 8995, 9011, 8637, 8358, 9060, 8184, 8193, 9082, 8921, 8931, 9145, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9171, 18076, 9742, 9662, 18797, 9742, 18801, 10045, 10055,
  10071, 9536, 10105, 9742, 10890, 10139, 9742, 18014, 8386, 9742, 8575, 8567, 10198, 8581, 12651, 8053, 9279, 9644,
  8475, 8092, 8108, 8120, 8144, 9096, 8173, 8128, 8209, 8233, 16629, 9742, 13917, 8276, 8325, 19222, 8341, 8357, 9066,
  8157, 8352, 8879, 9742, 23245, 9742, 8374, 8406, 9109, 8872, 8447, 8435, 8422, 19234, 19129, 8463, 8491, 8525, 8541,
  8611, 8533, 9026, 12316, 18006, 8557, 8597, 8692, 8676, 8714, 8738, 8776, 8804, 8788, 8820, 20057, 8859, 8895, 8911,
  8947, 8963, 8979, 8995, 9011, 8637, 8358, 9060, 8184, 8193, 9082, 8921, 8931, 9145, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9171, 9742, 9742, 9662, 9742, 9742, 9742, 9191, 10156, 10171, 11940, 9266, 9742,
  10890, 9741, 9742, 18014, 8386, 9742, 8575, 8567, 10198, 8581, 12651, 8053, 9617, 9644, 8475, 8092, 8108, 8120, 8144,
  9096, 10187, 8128, 8209, 8233, 16629, 9742, 13917, 8276, 8325, 19222, 8341, 8357, 9066, 8157, 8352, 8879, 9742, 23245,
  9742, 8374, 8406, 9109, 8872, 8447, 8435, 8422, 19234, 19129, 8463, 8491, 8525, 8541, 8611, 8533, 9026, 12316, 18006,
  8557, 8597, 8692, 8676, 8714, 8738, 8776, 8804, 8788, 8820, 20057, 8859, 8895, 8911, 8947, 8963, 8979, 8995, 9011,
  8637, 8358, 9060, 8184, 8193, 9082, 8921, 8931, 9145, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9171, 9742, 9742, 9662, 9742, 9742, 9742, 9191, 19153, 10220, 19147, 9266, 9742, 10890, 9741, 9742, 18014, 8386,
  9742, 8575, 8567, 10198, 8581, 12651, 8053, 9617, 9644, 8475, 8092, 8108, 8120, 8144, 9096, 8173, 8128, 8209, 10269,
  16629, 9742, 13917, 8276, 8325, 19222, 8341, 8357, 9066, 8157, 8352, 8879, 9742, 23245, 9742, 8374, 8406, 9109, 8872,
  8447, 8435, 8422, 19234, 19129, 8463, 8491, 8525, 8541, 8611, 8533, 9026, 12316, 18006, 8557, 8597, 8692, 8676, 8714,
  8738, 8776, 8804, 8788, 8820, 20057, 8859, 8895, 8911, 8947, 8963, 8979, 8995, 9011, 8637, 8358, 9060, 8184, 8193,
  9082, 8921, 8931, 9145, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9171, 20350, 9742, 9662,
  9409, 9742, 12538, 10309, 10295, 10357, 8390, 9266, 9742, 10890, 9741, 9742, 18014, 8386, 9742, 8575, 8567, 10198,
  8581, 12651, 8053, 9617, 9644, 8475, 8092, 8108, 8120, 8144, 9096, 8173, 8128, 8209, 8233, 16629, 9742, 13917, 8276,
  8325, 19222, 8341, 8357, 9066, 8157, 8352, 8879, 9742, 23245, 9742, 8374, 8406, 9109, 8872, 8447, 8435, 8422, 19234,
  19129, 8463, 8491, 8525, 8541, 8611, 8533, 9026, 12316, 18006, 8557, 8597, 8692, 8676, 8714, 8738, 8776, 8804, 8788,
  8820, 20057, 8859, 8895, 8911, 8947, 8963, 8979, 8995, 9011, 8637, 8358, 9060, 8184, 8193, 9082, 8921, 8931, 9145,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 10420, 9742, 9742, 9662, 9742, 9742, 9742, 9191,
  9834, 10444, 9828, 10481, 9742, 10890, 9741, 9742, 13384, 21279, 9742, 23161, 12449, 16158, 16164, 22841, 9742, 9736,
  17882, 13386, 13389, 9742, 23161, 13840, 13823, 21163, 17274, 17274, 22326, 19914, 9742, 9742, 12787, 13388, 23155,
  13840, 13840, 17618, 17274, 17274, 10540, 19878, 10515, 9742, 13386, 22582, 13840, 13840, 13587, 17274, 17274, 10561,
  9742, 12346, 13389, 23162, 13840, 21740, 10533, 10538, 9742, 15317, 17251, 13840, 21585, 17274, 10558, 9742, 18561,
  13840, 14789, 17800, 9742, 14277, 19782, 14229, 10562, 18041, 20488, 10578, 10594, 10641, 12985, 13584, 18927, 12405,
  15414, 15670, 14924, 9349, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9171, 9742, 9742, 9662,
  9742, 9742, 9742, 9191, 9742, 9742, 10678, 10694, 9742, 10890, 9741, 9742, 13384, 21279, 9742, 23161, 12449, 16158,
  15517, 9742, 9742, 9736, 9742, 13386, 13389, 9742, 23161, 13840, 13823, 21163, 17274, 17274, 10541, 19914, 9742, 9742,
  13380, 13388, 23155, 13840, 13840, 17618, 17274, 17274, 10540, 9742, 9742, 9742, 13386, 22582, 13840, 13840, 13587,
  17274, 17274, 10561, 9742, 12346, 13389, 23162, 13840, 13588, 17274, 10538, 9742, 12348, 17251, 13840, 13587, 17274,
  10542, 9742, 18561, 13840, 14789, 10538, 9742, 18563, 13841, 17274, 10562, 13817, 13589, 12992, 19945, 22207, 13590,
  13584, 12410, 20236, 15414, 15670, 14924, 9349, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9171, 11993, 9742, 9662, 9742, 9742, 9742, 9191, 10723, 10770, 10756, 9266, 9742, 10890, 9741, 12115, 18014, 8290,
  9742, 8575, 8567, 10198, 8581, 12651, 8053, 9617, 9644, 8475, 8092, 8108, 8120, 8144, 9096, 8173, 8128, 8209, 8233,
  16629, 9742, 13917, 8276, 8325, 19222, 8341, 8357, 9066, 8157, 8352, 8879, 9742, 23245, 9742, 8374, 8406, 9109, 8872,
  8447, 8435, 8422, 19234, 19129, 8463, 8491, 8525, 8541, 8611, 8533, 9026, 12316, 18006, 8557, 8597, 8692, 8676, 8714,
  8738, 8776, 8804, 8788, 8820, 20057, 8859, 8895, 8911, 8947, 8963, 8979, 8995, 9011, 8637, 8358, 9060, 8184, 8193,
  9082, 8921, 8931, 9145, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9171, 9742, 9742, 9662,
  9742, 9742, 9742, 9191, 9742, 9742, 10799, 10694, 9742, 10890, 9741, 9742, 13384, 21279, 9742, 23161, 12449, 16158,
  17374, 9742, 9742, 9736, 9584, 13386, 13389, 9742, 23161, 13840, 13823, 21163, 17274, 17274, 17709, 10815, 9742,
  14474, 13380, 13388, 23155, 13840, 13840, 17618, 17274, 17274, 18517, 11406, 9742, 18657, 13386, 22582, 13840, 13840,
  13587, 17274, 17274, 14466, 9742, 12346, 13389, 23162, 13840, 13588, 17274, 10538, 9742, 12348, 17251, 13840, 13587,
  17274, 10542, 9742, 18561, 13840, 14789, 10538, 9742, 18563, 13841, 17274, 10562, 13817, 13589, 12992, 19945, 22207,
  13590, 13584, 12410, 20236, 15414, 15670, 14924, 9349, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9171, 9743, 9304, 12232, 11886, 9742, 9297, 9191, 9742, 13360, 9744, 10837, 12261, 22745, 10888, 9742, 18014,
  8386, 9742, 11018, 11010, 11282, 11288, 12651, 8053, 21206, 9644, 8475, 8092, 8108, 10906, 11136, 11208, 11646, 11092,
  10950, 10976, 16629, 9742, 13917, 8276, 8325, 20293, 11440, 11001, 11024, 10960, 11040, 11047, 9742, 23245, 9742,
  8374, 11063, 20315, 20305, 10934, 11482, 11079, 11162, 19129, 8463, 8491, 11108, 11221, 11149, 11182, 11237, 12316,
  18006, 11271, 11122, 11304, 11577, 11323, 8738, 11347, 11375, 11359, 11391, 20057, 11427, 11456, 11472, 11498, 11514,
  11530, 11546, 11562, 11195, 11307, 11593, 11657, 10921, 11632, 11601, 11617, 11673, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9171, 9742, 11706, 9662, 21557, 11707, 9742, 11724, 11763, 11752, 19238, 9266,
  9742, 10890, 9741, 9742, 18014, 8386, 9742, 8575, 8567, 10198, 8581, 12651, 8053, 9617, 9644, 8475, 8092, 8108, 8120,
  8144, 9096, 8173, 8128, 8209, 8233, 16629, 9742, 16814, 8276, 8325, 19222, 8341, 8357, 9066, 8157, 8352, 8217, 9489,
  23245, 9044, 8374, 8406, 9109, 8872, 8447, 8435, 8422, 9121, 19129, 8463, 8491, 8525, 8541, 8611, 8533, 9026, 12316,
  18006, 8557, 8597, 8692, 8676, 8714, 8738, 8776, 8804, 8788, 8820, 20057, 8859, 8895, 8911, 8947, 8963, 8979, 8995,
  9011, 8637, 8358, 9060, 8184, 8193, 9082, 8921, 8931, 9145, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9171, 9742, 9742, 9662, 9742, 9742, 9742, 14397, 11779, 11794, 11833, 9266, 9742, 10890, 9741, 9742,
  18014, 11849, 9742, 8575, 8567, 10198, 8581, 11854, 8053, 9617, 9644, 8475, 8092, 8108, 8120, 8144, 9096, 8173, 8128,
  8209, 8233, 16629, 9742, 13917, 8276, 8325, 19222, 8341, 8357, 9066, 8157, 8352, 8879, 9742, 23245, 9742, 8374, 8406,
  9109, 8872, 8447, 8435, 8422, 19234, 19129, 8463, 8491, 8525, 8541, 8611, 8533, 9026, 12316, 18006, 8557, 8597, 8692,
  8676, 8714, 8738, 8776, 8804, 8788, 8820, 20057, 8859, 8895, 8911, 8947, 8963, 8979, 8995, 9011, 8637, 8358, 9060,
  8184, 8193, 9082, 8921, 8931, 9145, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 11870, 9742,
  11883, 9662, 9742, 9742, 11883, 9191, 11902, 11917, 9175, 9266, 13556, 10890, 9741, 9742, 18014, 11956, 9742, 8575,
  8567, 10198, 8581, 11979, 8053, 9617, 9644, 8475, 8092, 8108, 8120, 8144, 9096, 8173, 8128, 8209, 8233, 16629, 9742,
  13917, 8276, 8325, 19222, 8341, 8357, 9066, 8157, 8352, 8879, 9742, 23245, 9742, 8374, 8406, 9109, 8872, 8447, 8435,
  8422, 19234, 19129, 8463, 8491, 8525, 8541, 8611, 8533, 9026, 12316, 18006, 8557, 8597, 8692, 8676, 8714, 8738, 8776,
  8804, 8788, 8820, 20057, 8859, 8895, 8911, 8947, 8963, 8979, 8995, 9011, 8637, 8358, 9060, 8184, 8193, 9082, 8921,
  8931, 9145, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 12026, 12049, 9742, 9662, 9742, 9742,
  9742, 9191, 12082, 12097, 12033, 12131, 9742, 10890, 9741, 9742, 18014, 12168, 9742, 8575, 8567, 10198, 8581, 12191,
  8053, 9617, 9644, 8475, 8092, 8108, 8120, 8144, 9096, 8173, 8128, 8209, 8233, 16629, 9742, 13917, 8276, 8325, 19222,
  8341, 8357, 9066, 8157, 8352, 8879, 9742, 23245, 9742, 8374, 8406, 9109, 8872, 8447, 8435, 8422, 19234, 19129, 8463,
  8491, 8525, 8541, 8611, 8533, 9026, 12316, 18006, 8557, 8597, 8692, 8676, 8714, 8738, 8776, 8804, 8788, 8820, 20057,
  8859, 8895, 8911, 8947, 8963, 8979, 8995, 9011, 8663, 8358, 9060, 8184, 8193, 9082, 8921, 8931, 9145, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 12221, 12230, 9742, 9662, 14644, 9742, 9742, 9191, 20808, 21223,
  9742, 12248, 9742, 10890, 9741, 11411, 18014, 8386, 9742, 8575, 8567, 10198, 8698, 12283, 8053, 9617, 9644, 8475,
  8092, 8108, 8120, 8144, 9096, 8173, 8128, 8209, 8233, 16629, 9742, 13917, 8276, 8325, 19222, 8341, 8357, 9066, 8157,
  8352, 8879, 9742, 23245, 9742, 8374, 8406, 9109, 8872, 8447, 8435, 8422, 19234, 19129, 8463, 8491, 8525, 8541, 8611,
  8533, 9026, 12316, 18006, 8557, 8597, 8692, 8676, 8714, 8738, 8776, 8804, 8788, 8820, 20057, 8859, 8895, 8911, 8947,
  8963, 8979, 8995, 9011, 8637, 8358, 9060, 8184, 8193, 9082, 8921, 8931, 9145, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9171, 9742, 9742, 9662, 9742, 9742, 9742, 9191, 9742, 9742, 20375, 9266, 9742, 10890,
  9741, 9742, 18014, 8386, 9742, 8575, 8567, 10198, 8581, 12651, 8053, 9617, 9644, 8475, 8092, 8108, 8120, 8144, 9096,
  8173, 8128, 8209, 8233, 16629, 9742, 13917, 8276, 8325, 19222, 8341, 8357, 9066, 8157, 8352, 8879, 9742, 23245, 9742,
  8374, 8406, 9109, 8872, 8447, 8435, 8422, 19234, 19129, 8463, 8491, 8525, 8541, 8611, 8533, 9026, 12316, 18006, 8557,
  8597, 8692, 8676, 8714, 8738, 8776, 8804, 8788, 8820, 20057, 8859, 8895, 8911, 8947, 8963, 8979, 8995, 9011, 8637,
  8358, 9060, 8184, 8193, 9082, 8921, 8931, 9145, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  12332, 9742, 9742, 10517, 12343, 9742, 12343, 12364, 9742, 12391, 19021, 10694, 9742, 10890, 9741, 9742, 13384, 21279,
  9742, 23161, 12449, 16158, 16164, 19911, 9742, 9736, 9742, 13386, 13389, 9742, 23161, 13840, 13823, 16916, 17274,
  17274, 10541, 19914, 9742, 18658, 13380, 13388, 23155, 13840, 13840, 17618, 17274, 17274, 18535, 10494, 9742, 18657,
  13386, 22582, 13840, 13840, 13587, 17274, 17274, 14466, 9742, 22789, 13389, 23162, 13840, 13588, 17274, 10538, 9742,
  12348, 17251, 13840, 13587, 17274, 10542, 9742, 12431, 13840, 14789, 10538, 9742, 18563, 13841, 17274, 10562, 13817,
  13589, 12992, 19945, 22207, 13590, 13584, 12410, 20236, 15414, 15670, 14924, 9349, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 12332, 9742, 9742, 10517, 12343, 9742, 12343, 12364, 9742, 12391, 19021, 10694, 9742,
  10890, 9741, 9742, 13384, 21279, 9742, 23161, 12449, 16158, 16164, 19911, 9742, 9736, 9742, 13386, 13389, 9742, 23161,
  13840, 13823, 16916, 17274, 17274, 10541, 19914, 9742, 18658, 13380, 13388, 23155, 13840, 13840, 17618, 17274, 17274,
  18535, 10494, 9742, 18657, 13386, 22582, 13840, 13840, 13587, 17274, 17274, 14466, 9742, 12346, 13389, 23162, 13840,
  13588, 17274, 10538, 9742, 12348, 17251, 13840, 13587, 17274, 10542, 9742, 18561, 13840, 14789, 10538, 9742, 18563,
  13841, 17274, 10562, 13817, 13589, 12992, 19945, 22207, 13590, 13584, 12410, 20236, 15414, 15670, 14924, 9349, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 12332, 9742, 9742, 10517, 12343, 9742, 12343, 12364, 9742,
  12391, 19021, 10694, 9742, 10890, 9741, 9742, 13384, 21279, 9742, 23161, 12449, 16158, 16164, 19911, 9742, 9736, 9742,
  13386, 13389, 9742, 23161, 13840, 13823, 16916, 17274, 17274, 10541, 19914, 9742, 18658, 12566, 13388, 23155, 13840,
  13840, 17618, 17274, 17274, 18535, 10494, 9742, 18657, 13386, 22582, 13840, 13840, 13587, 17274, 17274, 14466, 9742,
  12346, 13389, 23162, 13840, 13588, 17274, 10538, 9742, 12348, 17251, 13840, 13587, 17274, 10542, 9742, 18561, 13840,
  14789, 10538, 9742, 18563, 13841, 17274, 10562, 13817, 13589, 12992, 19945, 22207, 13590, 13584, 12410, 20236, 15414,
  15670, 14924, 9349, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 12332, 9742, 9742, 10517, 12343,
  9742, 12343, 12364, 9742, 12391, 19021, 10694, 9742, 10890, 9741, 9742, 13384, 21279, 9742, 23161, 12449, 16158,
  16164, 19911, 9742, 9736, 9742, 13386, 13389, 9742, 23161, 13840, 13823, 16916, 17274, 17274, 10541, 19914, 9742,
  18658, 13380, 13388, 23155, 13840, 13840, 17618, 17274, 17274, 18535, 10494, 9742, 18657, 12473, 22582, 13840, 13840,
  13587, 17274, 17274, 14466, 9742, 12346, 13389, 23162, 13840, 13588, 17274, 10538, 9742, 12348, 17251, 13840, 13587,
  17274, 10542, 9742, 18561, 13840, 14789, 10538, 9742, 18563, 13841, 17274, 10562, 13817, 13589, 12992, 19945, 22207,
  13590, 13584, 12410, 20236, 15414, 15670, 14924, 9349, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 12332, 9742, 9742, 10517, 12343, 9742, 12343, 12364, 9742, 12391, 19021, 10694, 9742, 10890, 9741, 9742, 13384,
  21279, 9742, 23161, 12449, 16158, 20026, 19911, 9742, 9736, 9742, 13386, 13389, 9742, 23161, 13840, 13823, 16916,
  17274, 17274, 18147, 19914, 9742, 18658, 13380, 13388, 23155, 13840, 13840, 17618, 17274, 17274, 18535, 10494, 9742,
  18657, 13386, 22582, 13840, 13840, 13587, 17274, 17274, 14466, 9742, 12346, 13389, 23162, 13840, 13588, 17274, 10538,
  9742, 12348, 17251, 13840, 13587, 17274, 10542, 9742, 18561, 13840, 14789, 10538, 9742, 18563, 13841, 17274, 10562,
  13817, 13589, 12992, 19945, 22207, 13590, 13584, 12410, 20236, 15414, 15670, 14924, 9349, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 12332, 9742, 9742, 10517, 12343, 9742, 12343, 12364, 9742, 12391, 19021,
  10694, 9742, 10890, 9741, 9742, 13384, 21279, 9742, 23161, 12449, 16158, 16164, 19911, 9742, 9736, 9742, 13386, 13389,
  9742, 23161, 13840, 13823, 16916, 17274, 17274, 10541, 19914, 9742, 9742, 13380, 13388, 23155, 13840, 13840, 17618,
  17274, 17274, 10540, 9742, 9742, 9742, 13386, 22582, 13840, 13840, 13587, 17274, 17274, 10561, 9742, 12346, 13389,
  23162, 13840, 13588, 17274, 10538, 9742, 12348, 17251, 13840, 13587, 17274, 10542, 9742, 18561, 13840, 14789, 10538,
  9742, 18563, 13841, 17274, 10562, 13817, 13589, 12992, 19945, 22207, 13590, 13584, 12410, 20236, 15414, 15670, 14924,
  9349, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 12332, 9742, 9742, 10517, 12343, 9742, 12343,
  12364, 9742, 12391, 19021, 10694, 9742, 10890, 9741, 9742, 13384, 21279, 9742, 23161, 12449, 16158, 16164, 19911,
  9742, 9736, 9742, 13386, 13389, 9742, 23161, 13840, 13823, 16916, 17274, 17274, 10541, 19914, 9742, 9742, 13380,
  13388, 23155, 13840, 13840, 17618, 17274, 17274, 10540, 9742, 9742, 9742, 13386, 22582, 13840, 13840, 13587, 17274,
  17274, 10561, 9742, 12346, 13389, 23162, 13840, 13588, 17274, 10538, 9742, 20075, 17251, 13840, 13587, 17274, 10542,
  9742, 18561, 13840, 14789, 10538, 9742, 18563, 13841, 17274, 10562, 13817, 13589, 12992, 19945, 22207, 13590, 13584,
  12410, 20236, 15414, 15670, 14924, 9349, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9171, 9742,
  9742, 9662, 9742, 9742, 9742, 9191, 12492, 12525, 21283, 9266, 9742, 10890, 9741, 9742, 18014, 8386, 9742, 8575, 8567,
  10198, 8581, 12651, 8053, 9617, 17901, 8475, 8092, 8108, 8120, 8144, 9096, 8173, 8128, 8209, 8233, 16629, 9742, 13917,
  8276, 8325, 19222, 8341, 8357, 9066, 8157, 8352, 8879, 9742, 23245, 9742, 8374, 8406, 9109, 8872, 8447, 8435, 8422,
  19234, 19129, 8463, 8491, 8525, 8541, 8611, 8533, 9026, 12316, 18006, 8557, 8597, 8692, 8676, 8714, 8738, 8776, 8804,
  8788, 8820, 20106, 8859, 8895, 8911, 8947, 8963, 8979, 8995, 9011, 8637, 8358, 9060, 8184, 8193, 9082, 8921, 8931,
  9145, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9171, 9742, 19358, 9662, 9742, 9742, 9742,
  12554, 12599, 12588, 9588, 9266, 9742, 10890, 9741, 9742, 18014, 8386, 9742, 8575, 8567, 10198, 8581, 12651, 8053,
  9617, 9644, 8475, 8092, 8108, 8120, 8144, 9096, 8173, 8128, 8209, 8233, 16629, 9742, 13917, 8276, 8325, 19222, 8341,
  8357, 9066, 8157, 8352, 8879, 9742, 23245, 9742, 8374, 8406, 9109, 8872, 8447, 8435, 8422, 19234, 19129, 8463, 8491,
  8525, 8541, 8611, 8533, 9026, 12316, 18006, 8557, 8597, 8692, 8676, 8714, 8738, 8776, 8804, 8788, 8820, 20057, 8859,
  8895, 8911, 12615, 8963, 8979, 12631, 9011, 8650, 8358, 9060, 8184, 8193, 9082, 8921, 8931, 9145, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 12332, 9742, 8504, 10517, 21254, 12647, 12667, 12711, 12727, 12742,
  12758, 12774, 18901, 9911, 12809, 12847, 12895, 12917, 8076, 12933, 12971, 12946, 13008, 10244, 9742, 22127, 13043,
  13386, 12695, 9742, 23161, 13840, 13062, 16916, 17274, 17635, 10541, 17428, 9742, 13099, 18156, 12901, 13727, 13132,
  22537, 17618, 13150, 17274, 13171, 10707, 19722, 18657, 13206, 13234, 13250, 13840, 20178, 13308, 17274, 16131, 12267,
  12677, 13389, 23162, 20844, 20454, 17274, 13349, 10863, 13376, 17251, 13840, 13587, 17274, 10542, 9742, 18561, 13405,
  13424, 21789, 9742, 18563, 13841, 17274, 10562, 13817, 13589, 12992, 19945, 19599, 13590, 13584, 12410, 20236, 15414,
  15670, 14924, 9349, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 12332, 9742, 21800, 10517, 12343,
  9245, 12343, 13453, 11690, 12391, 19021, 10694, 9742, 10890, 9741, 9742, 13384, 21279, 9742, 23161, 12449, 16158,
  16164, 19911, 9742, 9736, 9742, 13386, 13389, 9742, 23161, 13840, 13823, 16916, 17274, 17274, 10541, 19914, 9742,
  9626, 13380, 22248, 23155, 13840, 18204, 17618, 17274, 17274, 13497, 10494, 9742, 18657, 13386, 22582, 13840, 13840,
  13587, 17274, 17274, 14466, 22727, 13046, 14255, 21424, 13840, 13534, 17274, 10538, 9742, 12348, 17251, 13840, 13587,
  17274, 10542, 9742, 18561, 13840, 14789, 10538, 9742, 18563, 13841, 17274, 10562, 13817, 13589, 12992, 19945, 22207,
  13590, 8026, 13579, 20236, 15414, 15670, 14924, 9349, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 13606, 9742, 10465, 10517, 12343, 20068, 13636, 13652, 13668, 13683, 13699, 10694, 9742, 22149, 13715, 9742,
  13384, 21279, 9742, 23161, 12449, 13749, 13771, 19911, 9742, 9526, 18855, 13806, 13389, 18101, 10370, 13839, 13292,
  22400, 13857, 17274, 10541, 19914, 13023, 18658, 13882, 13388, 23155, 13940, 13959, 18185, 20673, 14853, 18535, 10494,
  9742, 21808, 13386, 22582, 13840, 13840, 13587, 17274, 17274, 14466, 9742, 12346, 13389, 23162, 13840, 13588, 17274,
  10538, 9742, 12348, 13979, 17305, 13587, 22198, 18361, 16483, 14005, 21156, 14789, 14044, 9742, 18563, 16679, 17274,
  14063, 13817, 13589, 12992, 19945, 22207, 22905, 14079, 12410, 20236, 15414, 15670, 18710, 9349, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 12332, 9742, 10089, 10517, 12343, 14820, 14095, 14114, 14130, 14145,
  14161, 10694, 9742, 10890, 9741, 9742, 15325, 21279, 14177, 18743, 18735, 14215, 16164, 23192, 17228, 19193, 17682,
  14252, 14271, 9684, 14293, 17033, 13823, 17405, 17274, 14314, 10541, 19914, 9742, 18658, 13380, 13388, 23155, 13840,
  13840, 17618, 17274, 17274, 18535, 10783, 9742, 14338, 13386, 22582, 14372, 19311, 16103, 17274, 17274, 14389, 9742,
  18863, 13389, 8304, 19267, 14695, 18620, 10538, 9742, 15157, 17251, 14413, 13587, 14454, 10542, 9742, 18561, 13840,
  14789, 10538, 14826, 18563, 21974, 17274, 14490, 13817, 13589, 12992, 19945, 22207, 14506, 13584, 12410, 20236, 15414,
  15670, 14924, 9349, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 12332, 9742, 16487, 10517, 20710,
  14532, 14557, 14573, 14589, 14604, 14620, 10694, 16044, 8722, 14636, 10279, 13620, 13895, 22819, 23048, 14660, 14711,
  14759, 19667, 9038, 14809, 19968, 13386, 15901, 19505, 17257, 18581, 22371, 14842, 14890, 14914, 14940, 8065, 14975,
  15010, 23201, 15026, 15050, 22444, 15086, 16572, 14874, 15126, 15142, 10850, 13786, 10821, 15173, 15196, 17858, 15220,
  15236, 15261, 15283, 15305, 9742, 15341, 15480, 18995, 15375, 15411, 15430, 15459, 9742, 12348, 15496, 20979, 19948,
  16289, 17734, 21636, 15533, 18688, 15570, 15586, 15623, 18563, 18344, 15644, 19383, 13817, 20230, 21689, 15662, 15686,
  21333, 16660, 22357, 15715, 18601, 15736, 14924, 9349, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 12332, 9742, 9553, 10517, 12343, 21215, 15786, 15802, 15818, 15833, 15849, 10694, 9742, 15597, 9741, 9742,
  13384, 21279, 9742, 23161, 12449, 15865, 16164, 19911, 10084, 9736, 16957, 15895, 13389, 9742, 15204, 13840, 13823,
  16916, 15917, 17274, 10541, 19914, 9742, 18658, 13380, 13388, 23155, 13840, 21870, 17618, 17274, 21516, 18535, 10494,
  9742, 18657, 13386, 22582, 13840, 13840, 13587, 17274, 17274, 14466, 19746, 12346, 12831, 23162, 15746, 13588, 17274,
  15935, 9742, 12348, 17251, 13840, 13587, 17274, 10542, 9742, 18561, 13840, 14789, 10538, 9742, 18563, 13841, 17274,
  10562, 13817, 13589, 12992, 19945, 22207, 13590, 13584, 12410, 20236, 20950, 15953, 17115, 9349, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 12332, 9742, 9742, 10517, 12343, 20927, 21624, 15979, 15995, 16010,
  16026, 10694, 9742, 10890, 9741, 16042, 13384, 21279, 9742, 23161, 12449, 16158, 16164, 20133, 9742, 9736, 9742,
  13386, 13389, 9742, 23161, 13840, 13823, 16916, 17274, 17274, 10541, 19914, 9742, 9742, 13380, 13388, 23155, 13840,
  13840, 17618, 17274, 17274, 10540, 9742, 9742, 9742, 13386, 22582, 13840, 13840, 13587, 17274, 17274, 10561, 9742,
  12346, 13389, 23162, 13840, 13588, 17274, 10538, 9742, 12348, 17251, 13840, 13587, 17274, 10542, 11930, 18561, 13840,
  14789, 10538, 23094, 16060, 16097, 16119, 16508, 16147, 16180, 16209, 19945, 22207, 13590, 13584, 12410, 20236, 15414,
  22430, 16225, 9349, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 12332, 9742, 9742, 10517, 12343,
  9742, 12343, 12364, 9742, 12391, 19021, 10694, 9742, 20730, 9741, 16635, 13384, 16315, 9742, 13286, 13278, 16072,
  17551, 19454, 9742, 16335, 9742, 13386, 13389, 9742, 23161, 13840, 13823, 16278, 17274, 21709, 10541, 19914, 9742,
  9742, 13380, 13388, 23155, 13840, 13840, 17618, 17274, 17274, 10540, 9742, 9742, 9742, 13386, 22582, 13840, 13840,
  13587, 17274, 17274, 18471, 9742, 12346, 13389, 23162, 13840, 13588, 17274, 10538, 9742, 12348, 17251, 13840, 13587,
  17274, 10542, 9742, 18561, 13840, 14789, 10538, 9742, 18563, 13841, 17274, 10562, 13817, 10655, 15879, 19945, 22207,
  13590, 13584, 12410, 20236, 15414, 15670, 14924, 9349, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 12332, 16357, 9742, 16389, 12343, 16351, 16381, 16405, 16421, 16436, 16452, 10694, 9742, 10890, 9741, 9742,
  15473, 21279, 16468, 15763, 15755, 18700, 16164, 19911, 9742, 9736, 9742, 13518, 16978, 9781, 19774, 17027, 16252,
  20004, 17754, 17274, 16503, 12308, 11736, 10457, 13380, 15180, 23155, 13840, 16239, 17618, 17274, 20264, 18846, 9742,
  9427, 9742, 13386, 22582, 13840, 13408, 20986, 17274, 17274, 13546, 13907, 16524, 13389, 23162, 13840, 13588, 17274,
  10538, 16542, 8260, 16558, 16588, 17085, 16752, 16617, 9459, 16651, 16676, 16695, 21194, 9742, 18563, 13841, 17274,
  13437, 13817, 13589, 12992, 19945, 15245, 16724, 13584, 12410, 21747, 16768, 15670, 14924, 16804, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 12332, 9742, 9742, 10517, 12343, 10740, 23232, 16830, 16846, 16861,
  16877, 10694, 9305, 16939, 9741, 16893, 12687, 16932, 9742, 16908, 19704, 17540, 15289, 20133, 16955, 9736, 9742,
  16973, 13389, 9742, 17173, 16994, 17012, 16916, 17049, 22290, 18893, 10404, 9742, 9742, 10253, 13388, 13116, 17075,
  13840, 17618, 17101, 17274, 14236, 9742, 9742, 13563, 13386, 17165, 14373, 19996, 13587, 17274, 17189, 10561, 17225,
  12346, 17244, 13481, 13840, 13588, 17273, 10538, 23000, 10123, 19563, 13840, 19274, 17274, 10542, 19138, 18561, 13840,
  14789, 10538, 19634, 18563, 20863, 15646, 10562, 13817, 13589, 12992, 19945, 22207, 13590, 13584, 14516, 17827, 21460,
  14675, 17291, 9349, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 17327, 9742, 9742, 17390, 12343,
  15628, 12343, 17444, 17460, 17475, 17491, 10694, 9742, 17513, 9741, 11708, 15351, 17507, 9742, 17529, 18937, 17567,
  13755, 19911, 14356, 9736, 10118, 13386, 13389, 9742, 23161, 13840, 17597, 16916, 17634, 15919, 20462, 17651, 17681,
  9742, 13380, 13388, 23155, 13840, 13840, 17698, 17725, 17750, 10540, 9742, 14994, 8251, 13386, 22582, 16782, 13840,
  17770, 17795, 19590, 10561, 9742, 12346, 13389, 23162, 13840, 13588, 17274, 10538, 9742, 12348, 17251, 13840, 13587,
  17274, 21534, 9742, 18561, 13840, 14789, 10538, 9742, 18563, 13841, 17274, 10562, 13817, 13589, 14322, 17816, 21857,
  13590, 13584, 12410, 20236, 15414, 15670, 14924, 9349, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 12332, 23149, 9742, 17843, 17879, 11255, 17898, 17917, 17933, 17948, 17964, 17980, 9742, 19183, 17996, 9742,
  18030, 18057, 18092, 18125, 18172, 18220, 16708, 19911, 18250, 9736, 10428, 13386, 13389, 9742, 23161, 13840, 13823,
  16916, 17274, 17274, 10541, 22038, 13924, 9742, 13380, 13388, 23155, 13840, 13840, 17618, 17274, 17274, 10540, 9934,
  9742, 21380, 18275, 18295, 13840, 18334, 21877, 17274, 18377, 10561, 18393, 11963, 18409, 12066, 18425, 18449, 18487,
  18533, 12175, 18551, 17251, 18579, 18597, 18617, 10542, 18636, 18674, 18726, 15511, 18759, 18782, 18817, 17863, 18833,
  10562, 13817, 18879, 12992, 19945, 17779, 18917, 18953, 18990, 20236, 15414, 19011, 14924, 10608, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 12332, 9742, 9742, 12205, 12343, 9201, 19037, 19053, 19069, 19084,
  19100, 19116, 19169, 10890, 9741, 14541, 17341, 19209, 10013, 19254, 19290, 19327, 19343, 19911, 9742, 15607, 9742,
  13386, 13389, 9742, 23161, 13840, 16265, 17129, 17274, 18507, 19378, 19914, 20332, 20522, 13380, 18279, 12059, 13963,
  16788, 17618, 17274, 19399, 19416, 19437, 8242, 9742, 13386, 22582, 15070, 13840, 13587, 15110, 17274, 10561, 22226,
  12346, 13389, 23162, 13840, 13588, 17274, 10538, 19903, 12348, 15034, 13840, 22271, 17274, 12955, 9742, 19470, 13840,
  15101, 10538, 9742, 18563, 13841, 17274, 10562, 22530, 13075, 14898, 19486, 16081, 18353, 13584, 12410, 20236, 15414,
  15670, 14924, 13322, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 12332, 13110, 9742, 10517, 12343,
  13027, 19502, 12364, 9742, 19521, 19537, 10694, 9742, 9726, 9741, 9742, 13384, 21279, 12152, 23161, 12449, 16158,
  16164, 19911, 8835, 9736, 10233, 19553, 13389, 9742, 22612, 15064, 13823, 19579, 18234, 17274, 19615, 19650, 9742,
  20825, 13380, 13388, 23155, 13840, 13840, 17618, 17274, 17274, 15937, 11249, 9742, 19659, 13464, 19683, 15395, 13840,
  13587, 14864, 17274, 10561, 12502, 12346, 13389, 23162, 13840, 13588, 17274, 10538, 9742, 12348, 17251, 13840, 13587,
  17274, 10542, 9742, 18561, 13840, 14789, 10538, 9742, 18563, 13841, 17274, 10562, 13817, 13589, 13083, 19945, 22207,
  13590, 13584, 12410, 20236, 15414, 15670, 14924, 9349, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 12332, 9742, 9742, 10517, 12343, 9742, 12343, 12364, 9742, 12391, 19021, 10694, 9742, 10890, 9741, 19720, 12823,
  19738, 19744, 22392, 22384, 18136, 17059, 10332, 9742, 9736, 9742, 13386, 13389, 9742, 23161, 13840, 13823, 16916,
  17274, 17274, 10541, 19914, 9742, 9742, 13380, 13388, 23155, 13840, 13840, 17618, 17274, 17274, 10540, 9742, 9742,
  9742, 13386, 22582, 13840, 13840, 13587, 17274, 17274, 10561, 9742, 12346, 13389, 23162, 13840, 13588, 17274, 10538,
  9742, 12348, 17251, 13840, 13587, 17274, 10542, 9742, 18561, 13840, 14789, 10538, 9742, 18563, 21658, 22318, 10562,
  13817, 13589, 12992, 19945, 22207, 13590, 13584, 12410, 20236, 15414, 15670, 14924, 9349, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 12332, 9742, 9742, 10985, 19762, 9742, 19798, 19827, 19811, 19843, 19859,
  10694, 19875, 20142, 19894, 9742, 19930, 19964, 9359, 13733, 19984, 20020, 20042, 19911, 9742, 20091, 20122, 12375,
  13389, 9742, 23161, 20158, 21430, 16916, 18497, 17140, 10541, 19914, 9742, 13186, 13512, 12476, 23155, 14687, 8309,
  22171, 17209, 17274, 14726, 11331, 9129, 20194, 20889, 17354, 21303, 20216, 13587, 21482, 20257, 20280, 20331, 12346,
  13389, 12440, 13840, 21981, 17274, 10538, 20348, 11807, 17251, 13943, 13587, 17274, 20366, 9742, 11817, 13840, 20391,
  10662, 9742, 18563, 13841, 17274, 10562, 13817, 13589, 12992, 20412, 20441, 13590, 9335, 12410, 20236, 15414, 20478,
  14924, 9349, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 12332, 9742, 9742, 16365, 21411, 16362,
  20504, 20538, 20554, 20569, 20585, 10694, 20606, 10890, 20601, 10619, 20622, 21093, 21100, 22886, 22878, 20659, 16164,
  20695, 12003, 9736, 14743, 20746, 13389, 10321, 20762, 15388, 17311, 20774, 20790, 17274, 10541, 22471, 13190, 20806,
  13380, 13388, 23155, 13840, 13840, 17618, 17274, 17274, 10540, 9742, 19446, 20824, 12572, 13218, 13840, 19305, 22769,
  17274, 21361, 17417, 9742, 12346, 12872, 20841, 20860, 21474, 17149, 20396, 9742, 20879, 17251, 13840, 18309, 20905,
  10542, 9742, 18561, 13840, 14789, 10538, 14735, 13474, 20172, 14793, 15443, 13817, 13589, 12992, 20943, 20966, 13590,
  16739, 15720, 8037, 13264, 15670, 14924, 9349, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 12332,
  9742, 9742, 14959, 12343, 9742, 12343, 21002, 21018, 21033, 21049, 10694, 9742, 10890, 21065, 9742, 21081, 21116,
  20518, 22590, 21143, 21179, 21239, 19911, 16319, 9773, 8750, 12793, 21270, 8760, 21299, 15699, 21319, 18433, 17275,
  21349, 14047, 12146, 21377, 9742, 10872, 21396, 21446, 16601, 13840, 21498, 21929, 21514, 21532, 9742, 21550, 20725,
  13386, 21573, 13840, 14438, 13587, 17274, 22556, 19421, 9742, 10341, 21609, 14774, 21652, 15963, 20425, 15554, 14952,
  16526, 12879, 16996, 21674, 21705, 20920, 12509, 18561, 21725, 21763, 10393, 21824, 22868, 21842, 18974, 21893, 20633,
  21909, 21945, 19945, 22207, 13590, 13584, 18196, 21961, 21997, 15670, 16299, 22027, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 12332, 9742, 9742, 10517, 12343, 10140, 12343, 22054, 22070, 22085, 22101, 10694,
  9742, 22117, 9741, 9742, 13384, 21279, 9742, 23161, 12449, 16158, 16164, 8843, 9742, 9736, 10733, 13386, 13389, 9742,
  23161, 13840, 15770, 16916, 17274, 17274, 14028, 22143, 22929, 9742, 13380, 15359, 18259, 17612, 22165, 22187, 17201,
  21777, 10540, 9742, 22223, 9742, 22242, 22582, 22264, 13840, 13587, 22287, 17274, 18766, 9742, 12346, 13389, 23162,
  13840, 13588, 17274, 10538, 14990, 12348, 17251, 13840, 22306, 17274, 10542, 9742, 18561, 13840, 14789, 10538, 9742,
  18563, 13841, 17274, 10562, 13817, 22342, 12992, 19945, 22207, 13590, 13584, 20241, 21593, 15414, 22011, 22416, 9349,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 12332, 9742, 9742, 20200, 12343, 9742, 22460, 12364,
  12297, 22487, 22503, 10694, 9742, 10890, 9741, 9742, 13384, 21279, 9742, 14430, 14422, 10382, 20679, 19911, 9742,
  9736, 9742, 22519, 13389, 11683, 12457, 13840, 13823, 16916, 22553, 17274, 10541, 19914, 9742, 9742, 13380, 22572,
  22606, 14298, 13840, 17618, 19400, 17274, 10540, 9742, 9742, 9742, 13386, 22582, 13840, 13840, 13587, 17274, 17274,
  10561, 9742, 12346, 13389, 23162, 13840, 13588, 17274, 13155, 9742, 12348, 17251, 13840, 13587, 17274, 10542, 9742,
  18561, 13840, 14789, 10538, 9742, 18563, 13841, 17274, 16193, 13817, 13589, 12992, 19945, 22207, 13590, 13584, 12410,
  20236, 15414, 15670, 14924, 9349, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 12332, 9742, 9742,
  10517, 12343, 9742, 12343, 22628, 22644, 22659, 22675, 10694, 9742, 10890, 9741, 9742, 13384, 21279, 9742, 23161,
  12449, 16158, 16164, 19911, 9742, 9736, 9742, 13386, 13389, 9742, 23161, 13840, 13823, 16916, 17274, 17274, 10541,
  19914, 9742, 9742, 13380, 13388, 23155, 13840, 13840, 17618, 17274, 17274, 10540, 9742, 9742, 9742, 13386, 22582,
  13840, 13840, 13587, 17274, 17274, 10561, 9742, 12346, 13389, 12415, 13840, 17366, 21921, 18464, 9742, 12348, 17251,
  13840, 13587, 17274, 10542, 9742, 18561, 13840, 14789, 10538, 9742, 18563, 13841, 17274, 10562, 13817, 13589, 12992,
  19945, 22207, 13590, 13584, 12410, 20236, 15414, 15670, 14924, 9349, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 12332, 9742, 9742, 10517, 12343, 9742, 12343, 12364, 9742, 22691, 22707, 10694, 9742, 10890, 22723,
  9742, 12861, 21279, 22743, 22761, 13989, 14017, 15267, 19911, 9742, 9736, 22785, 13386, 13389, 9742, 23161, 13840,
  13823, 20643, 17274, 17274, 22805, 22835, 9742, 9742, 13380, 13388, 23155, 13840, 13840, 17618, 17274, 17274, 10540,
  9742, 9742, 9742, 13386, 22582, 13840, 13840, 13587, 17274, 17274, 10561, 9742, 12346, 13389, 23162, 13840, 13588,
  17274, 10538, 9742, 12348, 17251, 13840, 13587, 17274, 10542, 9742, 18561, 13840, 14789, 10538, 9742, 18563, 13841,
  17274, 10562, 13817, 13589, 12992, 19945, 22207, 13590, 13584, 12410, 20236, 15414, 15670, 14924, 9349, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 12332, 9742, 9742, 10517, 12343, 9742, 12343, 12364, 9742,
  12391, 19021, 10694, 10625, 10890, 9741, 9742, 13384, 21279, 9742, 23161, 12449, 15548, 17581, 19911, 9742, 9736,
  9742, 13386, 13389, 9742, 23161, 13840, 13823, 16916, 17274, 17274, 10541, 21127, 9742, 9742, 13380, 13388, 23155,
  13840, 13840, 17618, 17274, 17274, 10540, 9742, 14350, 9742, 22857, 22582, 19695, 13840, 22902, 18965, 17274, 10561,
  9742, 12346, 13389, 23162, 13134, 13588, 17274, 18318, 9742, 12348, 17251, 13840, 13587, 17274, 13866, 9742, 18561,
  13840, 14789, 10538, 9742, 18563, 13841, 17274, 10562, 13817, 13589, 12992, 19945, 22207, 13590, 13584, 12410, 20236,
  15414, 15670, 14924, 9349, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9171, 9742, 9742, 10499,
  22921, 22945, 22981, 22970, 9742, 14199, 22954, 9266, 9742, 10890, 9741, 22997, 18014, 8386, 9742, 8575, 8567, 10198,
  8581, 12651, 8053, 9617, 9644, 8475, 8092, 8108, 8120, 8144, 9096, 8173, 8128, 8209, 8233, 16629, 9742, 13917, 8276,
  8325, 19222, 8341, 8357, 9066, 8157, 8352, 8879, 9742, 23245, 9742, 8374, 8406, 9109, 8872, 8447, 8435, 8422, 19234,
  19129, 8463, 8491, 8525, 8541, 8611, 8533, 9026, 12316, 18006, 8557, 8597, 8692, 8676, 8714, 8738, 8776, 8804, 8788,
  8820, 20057, 8859, 8895, 8911, 8947, 8963, 8979, 8995, 9011, 8637, 8358, 9060, 8184, 8193, 9082, 8921, 8931, 9145,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9171, 9742, 9742, 9662, 9742, 9742, 9742, 9191,
  23016, 23020, 11166, 9266, 9742, 10890, 9741, 9742, 18014, 8386, 9742, 8575, 8567, 10198, 8581, 12651, 8053, 9617,
  9644, 8475, 8092, 8108, 8120, 8144, 9096, 8173, 8128, 8209, 8233, 16629, 9742, 13917, 8276, 8325, 19222, 8341, 8357,
  9066, 8157, 8352, 8879, 9742, 23245, 9742, 8374, 8406, 9109, 8872, 8447, 8435, 8422, 19234, 19129, 8463, 8491, 8525,
  8541, 8611, 8533, 9026, 12316, 18006, 8557, 8597, 8692, 8676, 8714, 8738, 8776, 8804, 8788, 8820, 20057, 8859, 8895,
  8911, 8947, 8963, 8979, 8995, 9011, 8637, 8358, 9060, 8184, 8193, 9082, 8921, 8931, 9145, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9171, 9742, 9742, 19362, 9742, 9742, 9742, 23036, 23075, 23064, 8509, 9266,
  9742, 10890, 9741, 19630, 18014, 8386, 9742, 8575, 8567, 10198, 8581, 12651, 8053, 9617, 9644, 8475, 8092, 8108, 8120,
  8144, 9096, 8173, 8128, 8209, 8233, 16629, 9742, 13917, 8276, 8325, 19222, 8341, 8357, 9066, 8157, 8352, 8879, 9742,
  23245, 9742, 8374, 8406, 9109, 8872, 8447, 8435, 8422, 19234, 19129, 8463, 8491, 8525, 8541, 8611, 8533, 9026, 12316,
  18006, 8557, 8597, 8692, 8676, 8714, 8738, 8776, 8804, 8788, 8820, 20057, 8859, 8895, 8911, 8947, 8963, 8979, 8995,
  9011, 8637, 8358, 9060, 8184, 8193, 9082, 8921, 8931, 9145, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9171, 9742, 9742, 9662, 9742, 9742, 9742, 9191, 9742, 9742, 9742, 10694, 9742, 10890, 9741, 9742, 13384,
  21279, 9742, 23161, 12449, 16158, 16164, 9742, 9742, 9736, 9742, 13386, 13389, 9742, 23161, 13840, 13823, 21163,
  17274, 17274, 10541, 19914, 9742, 9742, 13380, 13388, 23155, 13840, 13840, 17618, 17274, 17274, 10540, 9742, 9742,
  9742, 13386, 22582, 13840, 13840, 13587, 17274, 17274, 10561, 9742, 12346, 13389, 23162, 13840, 13588, 17274, 10538,
  9742, 12348, 17251, 13840, 13587, 17274, 10542, 9742, 18561, 13840, 14789, 10538, 9742, 18563, 13841, 17274, 10562,
  13817, 13589, 12992, 19945, 22207, 13590, 13584, 12410, 20236, 15414, 15670, 14924, 9349, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 12010, 9742, 9742, 23091, 9742, 23091, 23137, 23110, 23125, 18109,
  9250, 9742, 9742, 9742, 9742, 18014, 8386, 9742, 8575, 8567, 10198, 8581, 12651, 8053, 9288, 9644, 8475, 8092, 8108,
  8120, 8144, 9096, 8173, 8128, 8209, 8233, 16629, 9742, 13917, 8276, 8325, 19222, 8341, 8357, 9066, 8157, 8352, 8879,
  9742, 23245, 9742, 8374, 8406, 9109, 8872, 8447, 8435, 8422, 19234, 19129, 8463, 8491, 8525, 8541, 8611, 8533, 9026,
  12316, 18006, 8557, 8597, 8692, 8676, 8714, 8738, 8776, 8804, 8788, 8820, 20057, 8859, 8895, 8911, 23178, 8963, 8979,
  23217, 9011, 8624, 8358, 9060, 8184, 8193, 9082, 8921, 8931, 9145, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742, 9742,
  9742, 9742, 9742, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28862, 28862, 0, 0, 0, 0, 30916, 30916, 28862, 28862,
  30916, 30916, 30916, 30916, 30916, 30916, 24576, 26624, 30916, 30916, 30916, 30916, 30916, 22528, 30916, 30916, 0,
  30916, 30916, 30916, 30916, 30916, 30916, 30916, 30916, 30916, 30916, 30916, 0, 28862, 0, 0, 30916, 28862, 30916,
  30916, 30916, 30916, 30916, 30916, 30916, 30916, 30916, 30916, 30916, 30916, 30916, 30916, 30916, 30916, 223, 30916,
  6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 187, 188, 561152, 28862, 0, 0, 0, 189, 189, 1483, 1484, 189, 189, 189, 1488, 189,
  343, 343, 343, 343, 343, 343, 1515, 343, 343, 0, 1518, 0, 189, 1520, 189, 677888, 0, 0, 0, 0, 0, 0, 0, 0, 751616, 0,
  788480, 0, 0, 0, 0, 0, 598, 794, 0, 0, 0, 798, 0, 0, 0, 0, 0, 395, 0, 0, 0, 0, 0, 0, 0, 470, 0, 0, 759808, 765952,
  772096, 559104, 780288, 792576, 559104, 559104, 559104, 835584, 559104, 559104, 559104, 722944, 739328, 743424,
  759808, 765952, 772096, 780288, 835584, 0, 0, 0, 0, 0, 765952, 0, 792576, 0, 0, 0, 561152, 561152, 561152, 561152,
  561152, 561152, 561152, 561152, 561152, 561152, 722944, 561152, 561152, 561152, 739328, 743424, 561152, 747520,
  561152, 561152, 561152, 561152, 739328, 743424, 561152, 561152, 561152, 759808, 765952, 772096, 561152, 780288,
  792576, 561152, 561152, 561152, 561152, 561152, 561152, 706560, 561152, 561152, 561152, 561152, 561152, 561152,
  561152, 735232, 561152, 561152, 561152, 747520, 561152, 561152, 561152, 561152, 561152, 561152, 0, 0, 561152, 561152,
  561152, 561152, 561152, 0, 0, 0, 561152, 561152, 561152, 561152, 710656, 561152, 561152, 561152, 561152, 561152,
  561152, 675840, 0, 819200, 561152, 561152, 561152, 759808, 561152, 765952, 772096, 561152, 780288, 561152, 792576,
  561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 0, 536576, 679936, 0, 187, 0, 0, 561152,
  835584, 561152, 561152, 561152, 561152, 561152, 561152, 534528, 0, 0, 0, 0, 0, 0, 0, 0, 968, 0, 0, 0, 0, 0, 0, 0, 0,
  983, 0, 0, 0, 0, 0, 0, 0, 0, 1215, 0, 0, 1218, 260, 1220, 260, 260, 0, 735232, 770048, 0, 0, 0, 663552, 663552,
  559104, 559104, 559104, 559104, 559104, 706560, 559104, 559104, 559104, 559104, 0, 0, 0, 0, 0, 0, 0, 0, 0, 92160, 0,
  0, 0, 189, 1132, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 891, 189, 893, 189, 895, 559104, 735232,
  559104, 559104, 559104, 770048, 774144, 559104, 559104, 559104, 559104, 559104, 559104, 559104, 0, 706560, 561152,
  561152, 561152, 706560, 561152, 561152, 561152, 561152, 561152, 561152, 735232, 561152, 561152, 561152, 561152,
  770048, 774144, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152,
  561152, 561152, 561152, 0, 0, 559104, 679936, 681984, 559104, 559104, 559104, 714752, 559104, 559104, 745472, 559104,
  559104, 559104, 559104, 559104, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79872, 79872, 79872, 559104, 559104, 559104,
  559104, 681984, 0, 745472, 0, 0, 0, 0, 0, 561152, 561152, 679936, 681984, 561152, 786432, 561152, 561152, 561152,
  561152, 561152, 561152, 561152, 821248, 823296, 561152, 831488, 561152, 561152, 561152, 561152, 561152, 561152,
  714752, 561152, 561152, 561152, 561152, 745472, 561152, 561152, 561152, 761856, 786432, 561152, 561152, 831488,
  561152, 561152, 561152, 561152, 679936, 681984, 561152, 561152, 0, 0, 768000, 0, 0, 829440, 0, 0, 0, 0, 0, 851968, 0,
  559104, 559104, 559104, 559104, 559104, 559104, 559104, 559104, 722944, 559104, 559104, 739328, 743424, 559104,
  559104, 559104, 559104, 716800, 559104, 559104, 559104, 794624, 559104, 559104, 559104, 837632, 841728, 851968, 0, 0,
  0, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 337920, 337920, 337920, 337920, 0, 837632, 841728, 561152, 561152,
  561152, 686080, 561152, 561152, 561152, 561152, 561152, 716800, 724992, 561152, 561152, 561152, 561152, 561152,
  561152, 794624, 561152, 561152, 561152, 561152, 561152, 837632, 841728, 561152, 561152, 851968, 561152, 727040,
  559104, 559104, 811008, 559104, 825344, 0, 727040, 0, 0, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 0, 0,
  0, 0, 0, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 0, 532480, 0,
  561152, 561152, 0, 561152, 561152, 727040, 561152, 749568, 561152, 561152, 776192, 561152, 800768, 561152, 811008,
  561152, 825344, 561152, 561152, 561152, 561152, 716800, 561152, 561152, 561152, 561152, 561152, 561152, 561152,
  686080, 561152, 561152, 561152, 561152, 561152, 561152, 839680, 784384, 0, 0, 0, 0, 0, 561152, 561152, 561152, 561152,
  561152, 561152, 839680, 784384, 0, 0, 0, 0, 1360, 561152, 561152, 561152, 561152, 561152, 561152, 839680, 784384, 0,
  0, 0, 0, 1437, 561152, 561152, 561152, 561152, 561152, 561152, 839680, 784384, 0, 0, 0, 0, 47104, 561152, 561152,
  561152, 561152, 561152, 727040, 561152, 749568, 561152, 561152, 776192, 561152, 800768, 561152, 561152, 811008,
  854016, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152,
  561152, 561152, 0, 532480, 114688, 561152, 561152, 0, 561152, 561152, 825344, 561152, 561152, 561152, 854016, 753664,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 400, 0, 0, 0, 404, 223, 223, 698368, 712704, 0, 0, 0, 0, 849920, 0, 0, 0, 0, 796672, 0, 0,
  0, 0, 0, 638, 0, 0, 0, 0, 0, 643, 0, 0, 0, 0, 0, 0, 0, 676, 0, 0, 0, 0, 0, 0, 0, 559104, 559104, 559104, 698368,
  559104, 559104, 559104, 559104, 0, 0, 0, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152,
  690176, 696320, 698368, 561152, 561152, 712704, 561152, 696320, 698368, 561152, 561152, 561152, 561152, 561152,
  796672, 561152, 561152, 561152, 561152, 561152, 690176, 561152, 712704, 561152, 561152, 561152, 796672, 561152,
  561152, 561152, 561152, 561152, 561152, 561152, 0, 0, 806912, 673792, 0, 0, 0, 607, 0, 0, 0, 611, 0, 0, 0, 0, 0, 0, 0,
  0, 598, 0, 0, 0, 0, 0, 0, 604, 559104, 684032, 559104, 559104, 755712, 559104, 559104, 684032, 755712, 0, 659456,
  561152, 684032, 561152, 561152, 561152, 561152, 561152, 821248, 823296, 561152, 561152, 561152, 561152, 561152,
  561152, 561152, 561152, 561152, 0, 536576, 679936, 0, 0, 0, 0, 708608, 561152, 755712, 561152, 561152, 561152, 561152,
  845824, 561152, 708608, 561152, 561152, 561152, 561152, 561152, 659456, 561152, 561152, 684032, 561152, 561152,
  561152, 708608, 561152, 561152, 755712, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152,
  561152, 661504, 561152, 561152, 561152, 561152, 817152, 561152, 733184, 804864, 561152, 561152, 733184, 804864,
  561152, 702464, 561152, 561152, 561152, 845824, 0, 0, 0, 688128, 0, 0, 778240, 813056, 843776, 0, 667648, 0, 1360,
  667648, 688128, 559104, 757760, 813056, 757760, 561152, 667648, 688128, 561152, 561152, 731136, 757760, 802816,
  813056, 843776, 671744, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 667648, 671744, 688128, 561152,
  561152, 561152, 561152, 731136, 757760, 802816, 561152, 813056, 561152, 561152, 561152, 843776, 782336, 0, 0, 0, 0, 0,
  704512, 1360, 704512, 561152, 700416, 704512, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 839680, 561152,
  700416, 704512, 561152, 561152, 561152, 561152, 837632, 561152, 841728, 561152, 561152, 851968, 561152, 776192, 0, 0,
  0, 0, 0, 609, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32768, 0, 0, 0, 0, 692224, 0, 0, 561152, 561152, 561152, 561152,
  561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 0, 561152, 663552, 561152, 561152, 561152,
  561152, 718848, 561152, 561152, 819200, 561152, 561152, 718848, 561152, 561152, 561152, 561152, 819200, 694272,
  561152, 561152, 561152, 561152, 835584, 561152, 561152, 561152, 561152, 561152, 0, 751616, 0, 561152, 561152, 561152,
  561152, 561152, 561152, 714752, 561152, 561152, 561152, 561152, 745472, 561152, 561152, 561152, 561152, 0, 187, 0,
  188, 0, 0, 0, 0, 0, 0, 0, 0, 0, 969, 970, 971, 0, 0, 0, 0, 702464, 561152, 561152, 561152, 561152, 561152, 561152,
  561152, 808960, 808960, 0, 0, 0, 0, 0, 0, 197, 197, 0, 0, 197, 197, 63685, 197, 197, 197, 6145, 0, 3, 4, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 116736, 116736, 116736, 0, 0, 24576, 26624, 0, 0, 0, 0, 0, 22528, 0, 0, 0, 0, 0, 0, 216, 0,
  0, 0, 0, 0, 0, 214, 216, 233, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 0, 277,
  0, 277, 277, 277, 277, 277, 277, 277, 277, 277, 0, 0, 0, 0, 203, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 561152, 0, 0, 0,
  6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 187, 188, 561152, 0, 0, 0, 0, 223, 0, 0, 0, 669696, 0, 0, 0, 0, 0, 0, 0, 0, 669696,
  0, 0, 0, 0, 0, 0, 0, 199, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 390, 587, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  665600, 0, 0, 0, 189, 1482, 189, 189, 189, 189, 189, 189, 189, 343, 1491, 343, 343, 189, 343, 189, 343, 189, 343, 189,
  343, 0, 0, 0, 0, 0, 0, 477, 478, 0, 0, 477, 0, 0, 0, 0, 481, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 187, 0, 0, 0,
  0, 0, 0, 0, 0, 665600, 0, 0, 0, 0, 55296, 0, 0, 0, 0, 187, 55296, 0, 0, 0, 0, 0, 0, 0, 0, 79872, 0, 79872, 79872,
  79872, 0, 0, 0, 187, 187, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 974, 0, 0, 55537, 26624, 0, 0, 0, 0, 0, 22528,
  0, 0, 0, 0, 0, 187, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1295, 187, 0, 0, 0, 0, 0, 0, 187, 187, 187, 187, 187,
  187, 0, 0, 187, 0, 188, 0, 0, 0, 188, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 188, 6145, 0, 3, 4, 0, 0, 0, 0,
  0, 0, 14709, 188, 561152, 0, 0, 0, 0, 223, 223, 0, 0, 0, 624, 0, 0, 0, 0, 0, 0, 69632, 0, 0, 0, 69632, 0, 0, 69632,
  69632, 69632, 18432, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 211, 6145, 0, 567475, 4, 181, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 181, 0, 0, 0, 634, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133120, 133120, 133120, 6145, 0, 567475, 4, 0, 65536,
  0, 0, 0, 0, 187, 188, 561152, 0, 0, 0, 0, 223, 223, 0, 0, 669696, 0, 0, 0, 0, 0, 0, 0, 0, 827, 0, 828, 0, 0, 0, 0, 0,
  223, 65536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 792576, 0, 420, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  223, 0, 6145, 0, 3, 4, 0, 59392, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 677, 0, 0, 0, 680, 59392, 0, 0, 59392, 0, 59392, 0,
  59392, 59392, 59392, 59392, 59392, 59392, 0, 0, 59392, 0, 0, 242, 242, 0, 0, 0, 0, 0, 242, 0, 0, 0, 0, 0, 0, 397, 0,
  0, 0, 0, 0, 0, 0, 223, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 198, 0, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0,
  374, 375, 561152, 0, 0, 0, 0, 223, 223, 622, 623, 0, 0, 0, 0, 0, 0, 0, 0, 674, 0, 0, 0, 0, 0, 679, 0, 6145, 0, 3, 4,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 188, 0, 0, 0, 0, 0, 665600, 0, 0, 0, 0, 61440, 0, 0, 0, 0, 188, 61440, 0, 0, 0, 0, 0, 0, 0,
  0, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 0, 0, 24576,
  61685, 0, 0, 0, 0, 0, 22528, 0, 0, 0, 0, 0, 188, 0, 0, 0, 0, 0, 0, 188, 188, 188, 188, 188, 188, 0, 0, 188, 188, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 187, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 187, 14712, 561152, 0, 0, 0, 0, 395, 0,
  0, 0, 0, 0, 0, 0, 403, 0, 223, 223, 6145, 0, 3, 4, 0, 0, 182, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 955, 0, 0, 0, 0, 0, 197,
  197, 24576, 26624, 197, 197, 197, 197, 197, 22528, 197, 197, 0, 197, 197, 197, 63685, 63685, 63685, 197, 63685, 197,
  197, 63685, 197, 197, 197, 197, 197, 197, 63685, 226, 197, 197, 197, 197, 197, 197, 197, 197, 197, 197, 197, 197, 197,
  197, 197, 197, 224, 197, 197, 0, 197, 197, 63685, 197, 63685, 63685, 63685, 197, 63685, 63685, 63685, 0, 0, 0, 0, 476,
  0, 0, 469, 0, 480, 0, 0, 0, 426, 0, 0, 63488, 197, 0, 197, 197, 197, 197, 63685, 63714, 63714, 63714, 63714, 63714,
  63685, 63685, 63685, 69632, 0, 24576, 26624, 0, 0, 0, 0, 0, 22528, 69632, 69632, 0, 0, 0, 69632, 0, 69632, 69632, 0,
  69632, 69632, 69632, 69632, 69632, 69632, 69632, 0, 69632, 0, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632,
  69632, 0, 0, 0, 0, 608, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 207, 0, 0, 0, 0, 6145, 0, 0, 4, 57344, 0, 0, 0, 0, 0, 187,
  188, 561152, 0, 0, 0, 0, 636, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 260, 1219, 260, 260, 260, 96256, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 234, 0, 0, 71680, 71680, 71680, 0, 71680, 71680, 71680, 71680, 71680, 71680, 71680, 71680,
  71680, 71680, 0, 71680, 0, 71680, 71680, 71680, 71680, 71680, 73728, 71680, 73728, 71680, 0, 0, 49494, 561152, 561152,
  747520, 561152, 561152, 561152, 561152, 561152, 561152, 0, 49152, 561152, 561152, 561152, 561152, 561152, 0, 561152,
  561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 0, 532480, 587, 561152, 561152, 0, 75776, 0,
  75776, 0, 75776, 75776, 75776, 75776, 75776, 77824, 75776, 77824, 75776, 0, 0, 0, 0, 637, 0, 0, 0, 0, 607, 0, 0, 0, 0,
  0, 0, 591, 595, 0, 598, 0, 0, 0, 0, 0, 0, 0, 260, 260, 260, 837, 260, 260, 260, 260, 260, 561152, 835584, 561152,
  561152, 561152, 561152, 561152, 561152, 534528, 778, 0, 0, 0, 0, 0, 0, 425, 0, 0, 0, 428, 0, 0, 0, 431, 0, 79872,
  79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 24576, 26624,
  79872, 0, 0, 79872, 0, 22528, 79872, 79872, 0, 0, 0, 0, 0, 671, 0, 0, 0, 675, 0, 0, 0, 0, 0, 0, 593, 597, 0, 598, 0,
  0, 0, 0, 0, 0, 0, 1111, 0, 0, 0, 0, 0, 260, 260, 1118, 79872, 0, 79872, 0, 79872, 79872, 79872, 79872, 79872, 79872,
  79872, 79872, 79872, 0, 0, 0, 0, 683, 685, 189, 189, 189, 689, 189, 693, 189, 189, 189, 189, 189, 0, 343, 343, 343,
  343, 552, 343, 343, 343, 343, 343, 343, 343, 343, 1345, 343, 343, 0, 0, 0, 0, 0, 598, 0, 0, 0, 0, 0, 0, 800, 0, 0, 0,
  177, 0, 3, 4, 0, 0, 0, 183, 0, 0, 0, 0, 0, 0, 0, 0, 0, 606, 0, 0, 0, 0, 0, 0, 81920, 0, 81920, 0, 81920, 81920, 81920,
  81920, 81920, 81920, 81920, 81920, 81920, 0, 0, 0, 0, 824, 0, 0, 826, 0, 0, 0, 0, 0, 0, 0, 0, 204, 205, 206, 0, 0, 0,
  0, 0, 0, 39090, 3, 4, 0, 0, 370, 0, 0, 0, 187, 188, 189, 0, 0, 0, 0, 952, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 331776,
  0, 223, 0, 0, 962, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 189, 343, 343, 343, 343, 1173, 343, 343, 343, 343,
  343, 343, 343, 343, 343, 343, 343, 0, 0, 0, 0, 0, 0, 0, 0, 0, 343, 1272, 343, 343, 343, 343, 343, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1360, 343, 1427, 343, 343, 343, 343, 343, 343, 0, 0, 0, 0, 0, 0, 0, 1360, 260, 189, 1439, 189, 189,
  189, 189, 189, 1444, 189, 189, 189, 343, 1448, 343, 343, 189, 343, 189, 343, 1561, 1562, 189, 343, 0, 0, 0, 0, 0, 0,
  424, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 385, 0, 0, 0, 0, 0, 343, 343, 343, 1453, 343, 343, 343, 0, 0, 0, 0, 0, 1360, 1460,
  189, 189, 189, 189, 189, 189, 1420, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 0, 1349, 0, 0, 0, 86379, 0,
  0, 0, 0, 0, 0, 86384, 86384, 86384, 86384, 86384, 86384, 0, 0, 86384, 6145, 39090, 3, 4, 0, 0, 0, 0, 0, 0, 187, 188,
  189, 0, 0, 0, 0, 952, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 960, 0, 0, 90398, 90398, 90398, 0, 90398, 0, 0, 90398, 0, 0, 0, 0,
  0, 0, 639, 0, 0, 0, 0, 0, 0, 0, 0, 0, 232, 0, 0, 0, 0, 0, 0, 0, 0, 191, 0, 0, 0, 0, 0, 90398, 90398, 90398, 90398,
  90398, 90398, 90398, 0, 90398, 0, 90398, 90398, 90398, 90398, 90398, 0, 90398, 0, 90398, 0, 0, 0, 0, 952, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 959, 0, 364, 0, 0, 0, 0, 0, 0, 364, 364, 364, 364, 364, 364, 0, 0, 364, 0, 788, 0, 0, 0, 598, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 828, 0, 0, 987, 988, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 187, 188, 561529, 0, 0, 0, 0, 952, 0, 0,
  0, 0, 0, 0, 0, 957, 0, 0, 0, 0, 1200, 0, 0, 0, 1204, 0, 0, 0, 0, 0, 0, 0, 260, 260, 836, 260, 260, 260, 260, 260, 841,
  565654, 67584, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 223, 792576, 0, 0, 0, 561529, 561529, 561529, 561529,
  561529, 561529, 561529, 561529, 561529, 561529, 723321, 561529, 561691, 561691, 711195, 561691, 561691, 561691,
  561691, 561691, 561691, 675840, 0, 819200, 561529, 561529, 561529, 762233, 786809, 561529, 561529, 831865, 561529,
  561691, 561691, 561691, 680475, 682523, 561691, 561691, 760347, 561691, 766491, 772635, 561691, 780827, 561691,
  793115, 561691, 561691, 561691, 561691, 561691, 561691, 561691, 561691, 707099, 561691, 561691, 561691, 561691,
  561691, 561691, 561691, 735771, 561691, 561691, 836123, 561691, 561691, 561691, 561691, 561691, 561691, 534528, 0, 0,
  0, 0, 0, 0, 0, 218, 0, 0, 0, 0, 0, 0, 223, 189, 774521, 561529, 561529, 561529, 561529, 561529, 561529, 561529,
  561529, 561529, 561529, 561529, 561529, 561529, 561529, 561529, 0, 0, 0, 0, 0, 561529, 561529, 561529, 561529, 561529,
  561529, 561529, 561529, 561529, 561529, 561529, 561529, 0, 561691, 664091, 561691, 561691, 561691, 561691, 561691,
  561691, 561691, 770587, 774683, 561691, 561691, 561691, 561691, 561691, 561691, 561691, 561691, 561691, 561691, 0,
  536576, 679936, 0, 0, 0, 0, 559104, 559104, 559104, 559104, 681984, 0, 745472, 0, 0, 0, 0, 0, 561529, 561529, 680313,
  682361, 561691, 786971, 561691, 561691, 561691, 561691, 561691, 561691, 561691, 821787, 823835, 561691, 832027,
  561691, 561691, 561691, 561691, 561691, 561691, 723483, 561691, 561691, 561691, 739867, 743963, 561691, 748059,
  561691, 561691, 0, 837632, 841728, 561529, 561529, 561529, 686457, 561529, 561529, 561529, 561529, 561529, 717177,
  725369, 561529, 561529, 727417, 561529, 749945, 561529, 561529, 776569, 561529, 801145, 561529, 811385, 561529,
  825721, 561529, 561529, 739705, 743801, 561529, 561529, 561529, 760185, 766329, 772473, 561529, 780665, 792953,
  561529, 561529, 561529, 561529, 717177, 561529, 561529, 561529, 561691, 561691, 561691, 561691, 686619, 561691,
  561691, 561691, 561691, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 335872, 335872, 335872, 561691, 561691, 561691, 561691,
  717339, 725531, 561691, 561691, 561691, 561691, 561691, 561691, 795163, 561691, 561691, 561691, 561691, 561691,
  561691, 840219, 784384, 0, 0, 0, 0, 1360, 561529, 561529, 561529, 561529, 835961, 561529, 561529, 561529, 561529,
  561529, 0, 751616, 0, 561529, 561529, 561529, 561529, 795001, 561529, 561529, 561529, 561529, 561529, 838009, 842105,
  561529, 561529, 852345, 561529, 561691, 561691, 561691, 561691, 838171, 561691, 842267, 561691, 561691, 852507,
  561691, 776192, 0, 0, 0, 0, 0, 792, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 193, 0, 194, 0, 0, 0, 727040, 559104, 559104,
  811008, 559104, 825344, 0, 727040, 0, 0, 561529, 561529, 561529, 561529, 561529, 561529, 538, 561691, 561691, 561691,
  561691, 561691, 561691, 561691, 561691, 561691, 561691, 0, 532480, 0, 561529, 561529, 0, 854393, 561529, 561529,
  561529, 561529, 561529, 561529, 561529, 561529, 561691, 561691, 561691, 561691, 561691, 561691, 561691, 561691,
  561691, 0, 561691, 561691, 825883, 561691, 561691, 561691, 854555, 753664, 0, 0, 0, 0, 0, 0, 0, 0, 0, 954, 0, 956, 0,
  0, 0, 0, 0, 559104, 559104, 559104, 698368, 559104, 559104, 559104, 559104, 0, 0, 0, 561529, 561529, 561529, 561529,
  561691, 561691, 561691, 561691, 561691, 690715, 696859, 698907, 561691, 561691, 713243, 561691, 696697, 698745,
  561529, 561529, 561529, 561529, 561529, 797049, 561529, 561529, 561529, 561529, 561529, 690553, 561529, 713081,
  561691, 561691, 561691, 797211, 561691, 561691, 561691, 561691, 561691, 561691, 561691, 0, 0, 806912, 673792, 0, 0, 0,
  788, 952, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 114688, 0, 0, 0, 559104, 684032, 559104, 559104, 755712, 559104, 559104,
  684032, 755712, 0, 659833, 561529, 684409, 561529, 561529, 561529, 706937, 561529, 561529, 561529, 561529, 561529,
  561529, 735609, 561529, 561529, 561529, 561529, 770425, 708985, 561529, 756089, 561529, 561529, 561529, 561529,
  846201, 561529, 708985, 561529, 561529, 561529, 561529, 561529, 659995, 561691, 561691, 684571, 561691, 561691,
  561691, 709147, 561691, 561691, 756251, 561691, 561691, 561691, 561691, 561691, 561691, 715291, 561691, 561691,
  561691, 561691, 746011, 561691, 561691, 561691, 762395, 561691, 561691, 846363, 0, 0, 0, 688128, 0, 0, 778240, 813056,
  843776, 0, 667648, 0, 1360, 667648, 688128, 559104, 757760, 813056, 757760, 561529, 668025, 688505, 561529, 561529,
  731513, 758137, 803193, 813433, 844153, 672121, 561529, 561529, 561529, 561529, 561529, 561529, 561691, 668187,
  672283, 688667, 561691, 561691, 561691, 561691, 731675, 758299, 803355, 561691, 813595, 561691, 561691, 561691,
  844315, 782336, 0, 0, 0, 0, 0, 704512, 1360, 704512, 561529, 700793, 704889, 561529, 561529, 561529, 561529, 561529,
  561529, 561529, 840057, 561691, 700955, 705051, 561691, 561691, 561691, 561691, 561691, 727579, 561691, 750107,
  561691, 561691, 776731, 561691, 801307, 561691, 561691, 811547, 692224, 0, 0, 561529, 561529, 561529, 561529, 561529,
  561529, 561529, 561529, 561529, 561691, 561691, 561691, 561691, 561691, 561691, 661881, 561529, 561529, 561529,
  561529, 817529, 662043, 561691, 561691, 561691, 561691, 817691, 561529, 733561, 805241, 561529, 561691, 733723,
  805403, 561691, 702841, 561529, 719225, 561529, 561529, 819577, 561691, 561691, 719387, 561691, 561691, 561691,
  561691, 819739, 694272, 561529, 561529, 747897, 561529, 561529, 561529, 561529, 561529, 561529, 0, 0, 561691, 561691,
  561691, 561691, 561691, 0, 0, 0, 561529, 561529, 561529, 561529, 711033, 561529, 561529, 561529, 703003, 561691,
  561529, 561691, 561529, 561691, 561529, 561691, 809337, 809499, 0, 0, 0, 0, 0, 0, 672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 248,
  0, 0, 0, 0, 0, 0, 0, 102400, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 392, 0, 0, 24576, 26624, 0, 0, 0, 0, 0,
  22528, 102400, 102400, 0, 0, 0, 0, 0, 809, 0, 0, 0, 0, 0, 815, 0, 817, 0, 0, 102400, 0, 102400, 0, 102400, 102400,
  102400, 102400, 102400, 102400, 102400, 102400, 102400, 0, 0, 0, 102400, 0, 102400, 102400, 0, 102400, 102400, 102400,
  102400, 102400, 102400, 104726, 104726, 104726, 104726, 104726, 104726, 104726, 104726, 104726, 104726, 104726,
  104726, 104726, 104726, 104726, 104726, 0, 104726, 0, 104726, 104726, 104726, 104726, 104726, 104726, 104726, 104726,
  104726, 0, 0, 0, 0, 1213, 0, 0, 0, 0, 0, 0, 260, 260, 260, 260, 260, 260, 260, 260, 0, 0, 0, 1307, 189, 189, 189,
  104813, 0, 0, 0, 0, 0, 0, 104813, 104813, 104813, 104813, 104813, 104813, 104726, 104726, 104817, 559104, 559104,
  559104, 559104, 0, 110592, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 665600, 0, 0, 6145, 0, 3, 4, 0, 0, 0, 0, 116736, 0, 0,
  0, 0, 0, 0, 116736, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 199, 199, 0, 116736, 116736, 116736, 116736, 116736,
  116736, 116736, 116736, 116736, 116736, 116736, 116736, 116736, 116736, 116736, 116736, 0, 116736, 0, 116736, 116736,
  116736, 116736, 116736, 116736, 116736, 116736, 116736, 0, 0, 0, 0, 1286, 0, 0, 0, 0, 1290, 0, 0, 0, 0, 0, 0, 71680,
  49494, 49494, 49494, 49494, 49494, 49494, 71680, 71680, 49494, 559104, 559104, 559104, 559104, 53248, 112640, 120832,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1114, 0, 0, 260, 260, 260, 112640, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 665600, 0, 0, 0,
  191, 0, 0, 0, 0, 0, 191, 0, 0, 0, 0, 0, 0, 610, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 51200, 0, 0, 0, 0, 0, 6145, 0, 3, 4, 0,
  0, 0, 0, 0, 118784, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 119063, 119063, 119063, 118784, 0, 0, 118784, 0, 0, 0, 0, 0, 118784,
  0, 0, 0, 0, 0, 0, 859, 0, 0, 0, 189, 189, 189, 189, 189, 189, 189, 1137, 189, 189, 189, 189, 189, 119063, 119063,
  119063, 119063, 119063, 119063, 119063, 119063, 119063, 119063, 119063, 119063, 119063, 119063, 119063, 119063, 0,
  119063, 0, 119063, 119063, 119063, 119063, 119063, 119063, 119063, 119063, 119063, 0, 0, 0, 0, 20480, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 108544, 0, 0, 0, 6145, 0, 3, 0, 0, 0, 0, 126976, 0, 0, 187, 188, 561152, 0, 94208, 0, 0, 0, 792,
  0, 598, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 397, 0, 0, 0, 0, 397, 559104, 559104, 559104, 559104, 0, 0, 122880, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1205, 0, 0, 0, 1207, 0, 0, 83968, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 665600, 0, 0, 0, 214, 215, 216,
  217, 0, 0, 0, 0, 0, 0, 0, 223, 189, 6145, 0, 3, 569524, 0, 0, 0, 0, 0, 0, 184, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 225, 0, 6145, 0, 3, 569524, 0, 0, 0, 0, 0, 0, 187, 188, 561152, 0, 0, 0, 0, 67584, 98304, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1101, 0, 0, 0, 0, 114688, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 665600, 0, 0, 0, 222, 0, 0, 221, 0, 0, 221, 0,
  0, 0, 0, 0, 0, 598, 0, 795, 0, 0, 0, 0, 0, 0, 0, 0, 0, 790528, 0, 811008, 815104, 0, 0, 0, 6145, 39090, 3, 4, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 189, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 260, 260, 260, 260, 260, 0, 0, 24576, 26624, 0, 0, 0, 0,
  0, 22528, 0, 0, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 658, 260, 260, 260, 260, 0, 189, 0, 189, 0, 0, 0, 0,
  0, 0, 260, 0, 0, 189, 189, 343, 1511, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0, 189, 189, 189, 189, 189, 189, 189,
  189, 189, 189, 189, 189, 1140, 1296, 260, 260, 260, 260, 260, 260, 260, 260, 0, 0, 0, 189, 189, 189, 189, 189, 1135,
  189, 189, 189, 189, 189, 189, 189, 0, 0, 0, 0, 0, 189, 189, 189, 189, 189, 189, 692, 189, 189, 189, 189, 189, 989,
  260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 852, 0, 0, 0, 0, 131072, 131072, 131072, 0,
  131072, 0, 0, 131072, 0, 0, 0, 0, 0, 0, 1097, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1291, 0, 0, 0, 0, 0, 0, 0, 131072, 0,
  131072, 131072, 131072, 131072, 131072, 0, 131072, 0, 131072, 0, 0, 0, 0, 79872, 0, 79872, 0, 0, 0, 0, 0, 0, 0, 79872,
  0, 133120, 0, 24576, 26624, 0, 0, 0, 0, 0, 22528, 133120, 133120, 0, 0, 0, 0, 0, 833, 0, 260, 260, 260, 260, 260, 260,
  260, 260, 260, 260, 260, 260, 260, 260, 1001, 133120, 0, 133120, 0, 133120, 133120, 133120, 133120, 133120, 133120,
  133120, 133120, 133120, 0, 0, 0, 133120, 0, 133120, 133120, 0, 133120, 133120, 133120, 133120, 133120, 133120, 561152,
  561152, 845824, 0, 0, 0, 688128, 0, 0, 778240, 813056, 843776, 0, 667648, 0, 1408, 757760, 802816, 561152, 813056,
  561152, 561152, 561152, 843776, 782336, 0, 0, 0, 0, 0, 704512, 1437, 0, 200, 200, 229, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 665600, 0, 0, 0, 0, 189, 0, 200, 0, 0, 200, 237, 200, 0, 0, 0, 0, 0, 0, 1110, 0, 0, 0, 0, 0, 0, 260, 260,
  260, 260, 440, 260, 260, 260, 260, 260, 260, 260, 260, 667, 260, 260, 260, 260, 0, 0, 0, 0, 0, 24576, 26624, 246, 0,
  0, 0, 0, 22528, 246, 259, 261, 261, 261, 261, 259, 259, 287, 287, 287, 259, 287, 259, 259, 287, 259, 259, 259, 259,
  259, 259, 309, 259, 309, 259, 259, 259, 259, 259, 328, 261, 328, 259, 333, 333, 344, 333, 333, 333, 333, 333, 333,
  333, 344, 344, 344, 344, 344, 344, 333, 333, 344, 6145, 39090, 3, 4, 0, 0, 0, 0, 371, 0, 187, 188, 189, 0, 0, 0, 0,
  106496, 0, 0, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 661, 223, 0, 407, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 417, 0, 0, 0, 260, 260, 260, 260, 442, 260, 260, 260, 260, 260, 260, 260, 260, 1125, 260, 260, 260,
  260, 0, 0, 0, 0, 421, 0, 0, 0, 0, 0, 383, 0, 0, 0, 0, 0, 371, 0, 0, 0, 260, 260, 260, 260, 443, 260, 260, 260, 260,
  260, 260, 260, 260, 1123, 260, 260, 260, 260, 260, 260, 260, 0, 0, 0, 0, 189, 189, 189, 189, 189, 1234, 0, 407, 0,
  260, 260, 436, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 850, 260, 260, 0, 0, 456, 260, 260, 260, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 470, 0, 0, 483, 484, 189, 487, 189, 189, 189, 189, 189, 189, 189, 189, 189, 510, 513, 189,
  0, 343, 343, 543, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0, 0, 0, 0, 1281, 0, 0, 189, 513, 189, 189, 520, 189, 189,
  0, 0, 0, 417, 407, 189, 487, 189, 189, 189, 189, 189, 189, 1469, 343, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0, 0,
  0, 0, 0, 1360, 343, 343, 569, 343, 572, 343, 343, 582, 343, 343, 0, 0, 0, 189, 189, 0, 0, 0, 807, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 195, 0, 0, 0, 0, 0, 633, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 260, 1117, 260, 189, 189, 189, 713,
  189, 189, 189, 189, 189, 189, 0, 0, 633, 189, 189, 189, 189, 189, 189, 189, 1421, 343, 343, 343, 343, 343, 343, 343,
  343, 0, 0, 1433, 0, 1435, 0, 0, 1360, 820, 0, 0, 0, 0, 0, 0, 0, 0, 0, 828, 0, 0, 0, 0, 0, 195, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 189, 189, 189, 189, 865, 866, 189, 868, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189,
  189, 1153, 343, 343, 343, 343, 915, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0, 0, 1195, 343, 343,
  942, 343, 343, 343, 343, 343, 343, 0, 0, 0, 0, 0, 950, 0, 0, 0, 823, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 816, 0, 0, 0,
  0, 260, 260, 991, 992, 260, 260, 260, 260, 260, 260, 997, 260, 260, 260, 260, 0, 0, 0, 0, 0, 0, 0, 0, 1012, 189, 189,
  189, 260, 260, 260, 260, 1006, 0, 0, 1008, 0, 0, 0, 1006, 189, 189, 189, 1014, 189, 1016, 1017, 189, 189, 189, 189,
  189, 189, 189, 189, 189, 189, 1026, 189, 189, 189, 189, 189, 343, 1526, 343, 343, 343, 343, 343, 343, 0, 189, 189,
  189, 189, 189, 521, 189, 0, 0, 0, 0, 0, 189, 488, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 673, 0, 0, 189,
  189, 722, 343, 1056, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 1066, 343, 343, 189, 343, 1559, 1560, 189,
  343, 189, 343, 0, 0, 0, 0, 0, 0, 590, 594, 0, 0, 0, 0, 0, 0, 665600, 0, 0, 343, 343, 1186, 343, 343, 343, 343, 343,
  1190, 343, 343, 0, 0, 0, 0, 0, 198, 0, 198, 0, 199, 0, 199, 0, 0, 0, 0, 1209, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 260, 260,
  260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 0, 0, 0, 189, 189, 1311, 189, 189, 189, 189, 189,
  189, 189, 189, 189, 189, 189, 189, 189, 189, 1041, 189, 189, 189, 1325, 189, 343, 343, 343, 343, 343, 343, 343, 343,
  1333, 343, 343, 343, 0, 0, 0, 0, 1404, 0, 0, 0, 0, 0, 0, 0, 1360, 0, 0, 24576, 26624, 0, 248, 0, 0, 248, 22528, 0, 0,
  260, 260, 260, 260, 260, 260, 260, 260, 996, 260, 260, 260, 260, 260, 260, 1365, 0, 0, 0, 189, 189, 189, 189, 189,
  189, 1136, 189, 189, 189, 189, 189, 189, 940, 343, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0, 0, 0, 950, 0, 0, 0,
  832, 0, 0, 0, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 659, 260, 1154, 189, 189, 189, 189,
  189, 189, 189, 343, 343, 1164, 1165, 343, 343, 343, 343, 0, 0, 0, 0, 0, 1085, 0, 0, 0, 0, 0, 0, 100352, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 985, 0, 0, 0, 0, 0, 1494, 1495, 343, 1497, 343, 0, 0, 0, 189, 189, 189, 189, 189, 189, 189, 189, 189,
  343, 343, 343, 343, 343, 343, 343, 343, 343, 0, 6145, 39090, 3, 4, 0, 0, 0, 0, 0, 0, 0, 185, 0, 189, 0, 0, 0, 260,
  260, 260, 438, 260, 260, 445, 260, 450, 260, 453, 260, 455, 0, 0, 189, 0, 0, 0, 204, 0, 0, 0, 0, 0, 0, 0, 204, 204, 0,
  204, 24576, 26624, 204, 249, 0, 0, 249, 22528, 254, 254, 262, 262, 262, 262, 254, 254, 288, 288, 288, 254, 288, 254,
  254, 302, 254, 254, 254, 307, 307, 308, 310, 308, 310, 308, 308, 308, 308, 308, 254, 262, 254, 308, 334, 334, 345,
  334, 334, 334, 334, 334, 334, 334, 345, 345, 345, 345, 345, 345, 334, 334, 345, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  416, 0, 0, 0, 0, 0, 858, 0, 0, 0, 0, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 509, 511, 189, 189, 189, 535,
  189, 0, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0, 494, 189, 0, 343, 343, 343, 343, 573, 343, 343,
  343, 343, 343, 0, 0, 0, 189, 189, 0, 0, 0, 964, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 430, 0, 0, 0, 0, 260, 649, 260,
  260, 260, 260, 260, 260, 260, 657, 260, 260, 260, 260, 260, 0, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 0, 0,
  0, 189, 189, 189, 697, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 343, 343, 740,
  343, 744, 343, 343, 343, 343, 749, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0, 0, 0, 1280, 0, 0, 0, 831, 0, 0, 0, 0,
  0, 0, 260, 260, 260, 260, 260, 839, 260, 260, 260, 260, 0, 0, 0, 0, 463, 0, 466, 468, 0, 0, 0, 0, 0, 1096, 0, 0, 0,
  1099, 0, 0, 0, 0, 0, 0, 763904, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 814, 0, 0, 0, 0, 0, 189, 189, 869, 189, 189, 189, 189,
  189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 1243, 189, 189, 189, 189, 883, 189, 189, 189, 189, 189, 189, 189,
  189, 189, 189, 189, 189, 877, 189, 189, 189, 260, 1223, 260, 260, 260, 260, 0, 0, 1227, 0, 189, 189, 189, 189, 189,
  189, 189, 0, 523, 0, 0, 0, 189, 189, 189, 497, 0, 260, 260, 260, 260, 260, 260, 1302, 260, 0, 0, 1306, 189, 189, 189,
  189, 189, 0, 343, 343, 343, 343, 553, 343, 343, 343, 343, 343, 343, 343, 777, 0, 0, 0, 0, 781, 0, 0, 0, 343, 343,
  1339, 343, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0, 0, 0, 0, 0, 786, 1399, 343, 343, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1360, 0, 1479, 0, 189, 189, 189, 189, 189, 1486, 189, 189, 189, 343, 343, 343, 1493, 0, 207, 189, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 277, 277, 277, 0, 0, 24576, 26624, 247, 207, 0, 0, 207, 22528, 255, 255, 263, 263, 263, 263,
  255, 255, 289, 289, 289, 255, 289, 300, 300, 303, 300, 300, 300, 300, 300, 300, 311, 300, 311, 300, 300, 300, 300,
  300, 300, 263, 300, 300, 335, 335, 346, 311, 335, 335, 335, 335, 335, 335, 346, 346, 346, 346, 346, 346, 335, 335,
  346, 0, 0, 473, 0, 0, 0, 0, 0, 0, 0, 0, 0, 473, 0, 0, 0, 0, 565653, 223, 0, 0, 669696, 0, 0, 0, 0, 0, 0, 0, 0, 331776,
  331776, 331776, 331776, 331776, 0, 0, 0, 501, 189, 189, 189, 189, 0, 343, 343, 343, 343, 343, 343, 343, 557, 343, 343,
  343, 343, 343, 343, 1390, 343, 343, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0, 949, 0, 0, 0, 647, 648, 260, 260, 260,
  260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 1127, 0, 0, 260, 260, 260, 663, 260, 664, 260, 260, 260, 260,
  260, 260, 260, 0, 0, 0, 1367, 189, 189, 189, 189, 189, 616, 0, 0, 0, 684, 189, 189, 189, 189, 189, 189, 189, 189, 189,
  189, 189, 876, 189, 189, 189, 189, 343, 343, 343, 343, 758, 343, 759, 760, 343, 343, 343, 343, 343, 343, 343, 343, 0,
  0, 0, 0, 0, 1436, 0, 1360, 0, 0, 977, 0, 0, 0, 981, 0, 0, 0, 0, 828, 0, 0, 0, 0, 0, 965, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  613, 0, 0, 0, 0, 0, 1015, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 1028, 1080, 1081,
  343, 343, 0, 950, 0, 952, 0, 0, 0, 0, 0, 0, 0, 0, 0, 104701, 0, 0, 0, 0, 0, 0, 1235, 189, 189, 189, 189, 189, 189,
  189, 1240, 189, 189, 189, 189, 189, 189, 189, 0, 0, 0, 0, 0, 189, 189, 189, 496, 189, 189, 189, 189, 189, 189, 189,
  189, 1035, 189, 189, 189, 189, 189, 189, 189, 343, 1261, 343, 343, 343, 343, 343, 343, 343, 343, 343, 1268, 343, 343,
  343, 343, 0, 950, 0, 952, 0, 0, 0, 0, 0, 0, 0, 0, 0, 634, 828, 0, 0, 0, 0, 0, 343, 1400, 343, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1360, 189, 1464, 189, 189, 189, 189, 343, 343, 1471, 343, 343, 343, 343, 343, 343, 0, 0, 0, 189, 189,
  1504, 1505, 189, 189, 189, 189, 230, 0, 0, 0, 0, 0, 0, 208, 228, 0, 0, 0, 0, 0, 0, 0, 384, 426, 427, 0, 0, 0, 386, 0,
  0, 0, 0, 189, 0, 0, 208, 0, 228, 0, 228, 0, 0, 0, 0, 210, 208, 0, 210, 24576, 26624, 210, 0, 0, 0, 0, 22528, 256, 256,
  264, 264, 264, 264, 280, 280, 290, 290, 290, 280, 290, 280, 280, 290, 305, 305, 305, 305, 305, 305, 312, 305, 312,
  305, 305, 305, 305, 305, 329, 264, 329, 305, 336, 336, 347, 366, 336, 336, 336, 336, 336, 336, 347, 347, 347, 347,
  347, 347, 336, 336, 347, 223, 0, 0, 0, 0, 0, 0, 412, 0, 0, 0, 0, 0, 0, 0, 0, 0, 124928, 0, 0, 0, 0, 0, 0, 512, 514,
  189, 189, 189, 189, 189, 0, 0, 0, 466, 0, 189, 189, 490, 189, 189, 189, 189, 343, 343, 343, 343, 343, 343, 189, 1543,
  189, 189, 189, 189, 189, 189, 189, 873, 189, 189, 189, 189, 189, 189, 189, 189, 343, 1163, 343, 343, 343, 343, 343,
  343, 189, 508, 189, 514, 536, 0, 343, 343, 343, 546, 343, 343, 555, 343, 563, 343, 343, 343, 343, 343, 945, 343, 947,
  343, 0, 0, 0, 0, 0, 0, 0, 1355, 0, 0, 0, 0, 0, 0, 0, 0, 641, 0, 0, 0, 0, 0, 641, 0, 566, 343, 343, 571, 574, 577, 343,
  343, 343, 343, 0, 586, 0, 189, 536, 0, 0, 0, 1131, 189, 189, 189, 1134, 189, 189, 189, 189, 189, 189, 1139, 189, 189,
  189, 189, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 1396, 343, 343, 0, 619, 0, 0, 223, 223, 0,
  0, 0, 0, 625, 0, 0, 0, 0, 0, 207, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1356, 0, 0, 0, 0, 723, 189, 189, 725, 189, 708,
  189, 189, 189, 49883, 598, 343, 343, 343, 343, 343, 343, 343, 343, 343, 933, 934, 343, 343, 343, 343, 343, 343, 343,
  343, 343, 1063, 343, 343, 343, 343, 343, 343, 343, 343, 343, 919, 343, 343, 922, 343, 343, 343, 343, 343, 343, 343,
  745, 343, 343, 748, 343, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0, 1434, 0, 0, 0, 1360, 343, 756, 343, 343, 343,
  343, 343, 343, 343, 762, 343, 343, 343, 343, 343, 343, 189, 189, 189, 189, 343, 343, 343, 343, 189, 189, 343, 343,
  771, 343, 343, 343, 776, 343, 586, 0, 0, 780, 0, 0, 0, 0, 0, 1201, 1202, 0, 0, 0, 0, 0, 0, 0, 0, 0, 220, 0, 0, 0, 0,
  223, 189, 0, 805, 0, 0, 808, 0, 810, 811, 0, 813, 0, 0, 0, 0, 818, 0, 0, 0, 1199, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  972, 0, 0, 0, 0, 0, 822, 0, 0, 825, 0, 0, 0, 0, 828, 0, 0, 0, 0, 830, 842, 260, 260, 260, 845, 260, 260, 846, 260,
  260, 260, 260, 260, 260, 0, 0, 0, 0, 1229, 189, 189, 189, 189, 189, 854, 0, 0, 857, 0, 0, 0, 0, 780, 780, 861, 189,
  862, 863, 189, 189, 189, 189, 189, 701, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 1024, 189, 189, 189, 189,
  189, 189, 881, 882, 189, 189, 189, 189, 887, 189, 189, 189, 189, 189, 189, 894, 189, 189, 189, 189, 343, 343, 343,
  343, 1332, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 1064, 343, 343, 343, 343, 343, 343, 343, 927, 343, 343,
  343, 930, 931, 932, 343, 343, 343, 343, 937, 343, 939, 343, 343, 343, 943, 343, 343, 343, 343, 948, 0, 0, 0, 0, 0,
  950, 0, 0, 0, 1212, 0, 0, 0, 0, 0, 1216, 0, 260, 260, 260, 260, 1222, 0, 260, 260, 260, 260, 260, 994, 260, 260, 260,
  260, 260, 260, 260, 260, 260, 848, 260, 260, 260, 260, 0, 0, 260, 260, 260, 1005, 0, 0, 0, 0, 0, 0, 0, 0, 189, 189,
  189, 189, 189, 690, 189, 189, 189, 189, 189, 189, 189, 189, 1031, 189, 189, 189, 189, 189, 189, 189, 189, 189, 1039,
  189, 189, 1042, 189, 1044, 189, 189, 189, 1046, 189, 189, 189, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0, 0, 0, 1360,
  189, 189, 1462, 1055, 343, 343, 1058, 343, 1060, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0, 497, 189,
  0, 343, 343, 343, 343, 1071, 1072, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0, 529, 189, 0, 343, 343,
  1082, 343, 1084, 950, 0, 952, 0, 0, 0, 1087, 0, 0, 0, 0, 0, 1214, 0, 0, 0, 0, 0, 260, 260, 260, 260, 260, 260, 260,
  447, 260, 260, 260, 260, 260, 0, 1107, 0, 1108, 1109, 0, 0, 0, 1112, 0, 0, 0, 0, 260, 260, 260, 260, 441, 260, 260,
  260, 260, 260, 260, 260, 260, 847, 260, 260, 260, 260, 260, 0, 0, 189, 189, 189, 1144, 1145, 189, 189, 189, 189, 1150,
  189, 189, 1151, 189, 189, 189, 189, 189, 189, 702, 189, 189, 189, 189, 189, 189, 189, 189, 189, 1023, 189, 189, 189,
  189, 189, 189, 189, 189, 1156, 189, 189, 189, 189, 189, 343, 343, 343, 343, 343, 343, 343, 343, 0, 189, 189, 343, 343,
  1171, 343, 343, 343, 343, 343, 343, 343, 343, 1179, 1180, 343, 343, 343, 0, 0, 1403, 0, 0, 1405, 0, 0, 0, 0, 0, 0,
  1360, 343, 343, 343, 1187, 343, 343, 343, 1189, 343, 343, 343, 0, 0, 1193, 0, 0, 0, 260, 260, 260, 439, 260, 260, 260,
  260, 260, 260, 260, 260, 260, 1126, 260, 260, 260, 0, 0, 0, 260, 260, 1224, 260, 260, 260, 0, 0, 0, 1228, 189, 189,
  189, 189, 1233, 189, 189, 189, 189, 343, 1329, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 0, 585, 0, 189, 189,
  88064, 0, 260, 1298, 260, 260, 260, 1301, 260, 1303, 1304, 1305, 0, 189, 189, 1309, 189, 189, 189, 189, 537, 0, 343,
  343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 0, 1192, 0, 0, 0, 1323, 189, 1326, 189, 343, 343, 343, 1331, 343,
  343, 343, 343, 343, 343, 343, 1336, 343, 1338, 343, 343, 343, 343, 1342, 1344, 343, 1346, 1347, 0, 0, 0, 0, 0, 396, 0,
  0, 0, 0, 0, 0, 0, 0, 223, 223, 0, 0, 0, 0, 0, 0, 0, 628, 0, 0, 0, 0, 1353, 0, 1354, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  186, 0, 0, 0, 0, 343, 1386, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 1398, 260, 189,
  189, 189, 189, 189, 189, 1443, 189, 189, 189, 189, 343, 343, 343, 343, 343, 343, 189, 189, 189, 189, 189, 189, 1450,
  343, 343, 343, 343, 343, 343, 0, 0, 0, 0, 1459, 1360, 189, 189, 189, 189, 189, 189, 703, 189, 704, 189, 189, 189, 189,
  189, 189, 709, 189, 1510, 343, 343, 1512, 343, 343, 343, 343, 343, 0, 0, 0, 189, 189, 189, 189, 189, 189, 1507, 189,
  189, 189, 189, 1536, 343, 1538, 343, 343, 343, 1542, 189, 189, 189, 189, 189, 189, 189, 189, 1149, 189, 189, 189, 189,
  189, 189, 189, 0, 0, 0, 0, 0, 189, 189, 491, 189, 189, 189, 189, 189, 189, 189, 189, 189, 719, 0, 0, 0, 189, 189, 189,
  0, 0, 189, 0, 0, 0, 0, 0, 0, 0, 211, 0, 0, 0, 0, 211, 0, 0, 24576, 26624, 0, 0, 250, 250, 0, 22528, 250, 250, 265,
  265, 265, 265, 250, 250, 0, 0, 0, 250, 211, 250, 250, 211, 250, 250, 250, 250, 250, 250, 313, 250, 313, 250, 250, 250,
  250, 250, 250, 265, 250, 250, 313, 313, 348, 313, 313, 313, 313, 313, 313, 313, 348, 348, 348, 348, 348, 348, 313,
  313, 348, 531, 189, 189, 189, 189, 0, 343, 343, 343, 343, 343, 343, 343, 558, 343, 343, 343, 343, 343, 343, 1431, 343,
  0, 0, 0, 0, 0, 0, 0, 1360, 0, 260, 260, 260, 260, 652, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 668, 260,
  670, 0, 0, 0, 343, 741, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 768, 343, 343, 1185,
  343, 343, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0, 0, 0, 0, 786, 189, 189, 189, 189, 1537, 343, 343, 343, 343, 343,
  189, 189, 189, 189, 189, 189, 189, 189, 1162, 343, 343, 343, 343, 1166, 343, 343, 0, 0, 24576, 26624, 0, 0, 0, 0, 0,
  22528, 0, 0, 266, 266, 266, 266, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 314,
  281, 314, 281, 281, 281, 281, 281, 281, 266, 281, 281, 314, 314, 349, 314, 314, 314, 314, 314, 314, 314, 349, 349,
  349, 349, 349, 349, 314, 314, 349, 0, 422, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 389, 0, 1361, 260, 260, 260, 260,
  260, 260, 0, 0, 0, 189, 1368, 189, 189, 189, 189, 189, 0, 343, 343, 544, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0,
  0, 0, 1360, 189, 1461, 189, 189, 1372, 189, 189, 1374, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 343, 343,
  343, 343, 343, 1053, 343, 1385, 343, 343, 343, 343, 343, 343, 343, 1392, 343, 343, 1394, 343, 343, 343, 343, 0, 950,
  0, 952, 0, 0, 0, 0, 0, 0, 1090, 0, 260, 260, 1409, 260, 260, 0, 189, 189, 189, 189, 1412, 189, 189, 189, 189, 189, 0,
  343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0, 189, 189, 0, 189, 189, 189, 1417, 189, 189, 189, 343, 343,
  343, 343, 343, 1423, 343, 343, 343, 0, 1402, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1360, 343, 343, 1428, 343, 343, 343, 343,
  343, 0, 0, 0, 0, 0, 0, 0, 1360, 343, 343, 1548, 1549, 343, 343, 189, 189, 189, 189, 343, 343, 343, 343, 189, 189, 189,
  189, 189, 885, 189, 189, 189, 189, 189, 189, 892, 189, 189, 189, 189, 189, 189, 715, 189, 189, 189, 0, 0, 0, 189, 189,
  189, 189, 189, 189, 716, 189, 189, 189, 0, 0, 0, 189, 189, 189, 189, 189, 189, 728, 189, 189, 49883, 598, 343, 343,
  343, 343, 343, 343, 343, 343, 343, 1267, 343, 343, 343, 343, 343, 343, 189, 189, 189, 189, 343, 343, 343, 343, 189,
  1555, 260, 260, 260, 461, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 614, 0, 0, 617, 618, 0, 0, 0, 223, 223, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 630, 0, 212, 0, 212, 0, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 219, 0, 0, 0, 0, 0, 223, 189,
  0, 0, 189, 0, 0, 0, 0, 0, 212, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 189, 0, 0, 24576, 26624, 0, 0, 0, 0, 0,
  22528, 0, 0, 267, 267, 267, 267, 282, 282, 291, 291, 291, 282, 291, 301, 301, 291, 306, 291, 291, 291, 291, 291, 315,
  291, 315, 291, 291, 291, 291, 291, 330, 267, 330, 291, 337, 337, 350, 315, 337, 337, 337, 337, 337, 337, 350, 350,
  350, 350, 350, 350, 337, 337, 350, 471, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 471, 0, 0, 471, 0, 0, 0, 1285, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 208, 209, 210, 0, 343, 343, 343, 343, 773, 343, 343, 343, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1407,
  1360, 1106, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 260, 260, 260, 1221, 260, 0, 0, 1198, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1208, 260, 260, 260, 260, 1225, 260, 0, 0, 0, 0, 189, 1230, 189, 1232, 189, 189, 189, 189, 189, 901, 189, 903, 189,
  905, 49883, 906, 343, 907, 343, 909, 189, 189, 189, 1237, 189, 189, 189, 189, 189, 189, 1241, 189, 1242, 189, 189,
  189, 189, 189, 189, 872, 189, 189, 189, 189, 189, 189, 878, 189, 189, 1271, 343, 343, 1273, 343, 343, 343, 0, 0, 0, 0,
  1279, 0, 0, 0, 0, 0, 561152, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 429, 0, 0, 0, 0, 0, 260, 260, 260, 260, 1300, 260, 260,
  260, 0, 0, 0, 189, 189, 189, 189, 1485, 189, 189, 189, 189, 343, 343, 1492, 343, 189, 189, 1312, 189, 189, 189, 189,
  189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 1383, 343, 189, 1324, 189, 189, 343, 343, 343, 343, 343, 343, 343,
  343, 1334, 343, 343, 343, 343, 343, 343, 581, 343, 343, 343, 0, 0, 0, 189, 189, 0, 1463, 189, 189, 1466, 1467, 189,
  343, 343, 343, 343, 1473, 1474, 1475, 1476, 343, 0, 0, 0, 1481, 189, 189, 189, 189, 189, 189, 189, 189, 1490, 343,
  343, 343, 343, 343, 343, 1265, 343, 343, 343, 343, 343, 343, 1269, 343, 343, 1522, 189, 189, 189, 189, 343, 343, 343,
  1527, 1528, 343, 343, 343, 0, 189, 189, 189, 189, 189, 1020, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 890,
  189, 189, 189, 189, 189, 343, 343, 1557, 1558, 189, 343, 189, 343, 189, 343, 0, 0, 0, 0, 0, 0, 763904, 0, 0, 32768, 0,
  0, 0, 16384, 0, 0, 0, 0, 24576, 26624, 0, 0, 251, 251, 0, 22528, 251, 251, 268, 268, 268, 268, 283, 283, 292, 292,
  292, 283, 292, 283, 283, 292, 283, 283, 283, 283, 283, 283, 316, 283, 316, 283, 283, 283, 283, 283, 283, 268, 283,
  331, 316, 316, 351, 316, 316, 316, 316, 316, 316, 316, 351, 351, 351, 351, 351, 351, 316, 316, 351, 0, 422, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 391, 0, 0, 0, 189, 189, 189, 493, 189, 189, 189, 189, 189, 189, 189, 189, 189, 49883,
  598, 343, 343, 343, 343, 343, 260, 260, 260, 260, 0, 0, 0, 391, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 223, 0,
  605, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 608, 0, 0, 260, 260, 260, 651, 260, 260, 260, 260, 260, 260, 260, 260,
  260, 260, 260, 669, 260, 0, 0, 0, 189, 698, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189,
  1244, 189, 711, 189, 189, 189, 189, 189, 717, 189, 189, 0, 0, 0, 189, 688, 189, 189, 189, 189, 700, 189, 189, 189,
  189, 189, 189, 189, 189, 189, 189, 189, 705, 189, 706, 189, 189, 189, 738, 343, 343, 343, 343, 343, 343, 343, 343,
  750, 343, 343, 343, 343, 343, 343, 343, 343, 343, 584, 0, 0, 0, 495, 189, 0, 867, 189, 189, 189, 189, 189, 189, 189,
  189, 875, 189, 189, 189, 189, 189, 189, 189, 189, 1252, 343, 1254, 343, 343, 1257, 343, 343, 911, 912, 343, 914, 343,
  343, 343, 343, 343, 343, 343, 343, 343, 923, 343, 343, 343, 343, 343, 343, 1551, 189, 189, 189, 1553, 343, 343, 343,
  189, 189, 189, 189, 189, 727, 189, 189, 189, 49883, 598, 343, 343, 343, 343, 343, 343, 343, 343, 761, 343, 343, 343,
  343, 343, 343, 343, 343, 343, 343, 1178, 343, 343, 343, 343, 1183, 1002, 260, 260, 260, 0, 0, 0, 0, 0, 0, 0, 0, 189,
  189, 189, 189, 688, 189, 189, 189, 189, 189, 189, 189, 1068, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 1076,
  343, 343, 343, 343, 343, 343, 343, 917, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 921, 343, 343, 343,
  343, 0, 0, 1094, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 615, 616, 0, 1119, 260, 260, 260, 260, 260, 260, 260, 260,
  260, 260, 260, 260, 0, 0, 0, 0, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 696, 1169, 343, 343, 343, 343,
  343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 755, 343, 1547, 343, 343, 343, 343, 189, 189, 189, 189,
  343, 343, 343, 343, 189, 189, 189, 189, 189, 1238, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 0, 675, 0, 189,
  189, 189, 6145, 39090, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 186, 189, 0, 0, 0, 260, 260, 437, 260, 260, 444, 260, 260, 260,
  452, 260, 260, 260, 260, 0, 0, 0, 0, 1009, 0, 0, 0, 189, 189, 189, 189, 189, 189, 189, 1161, 343, 343, 343, 343, 343,
  343, 343, 343, 343, 343, 585, 364, 0, 189, 189, 585, 0, 186, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 189, 189, 189,
  189, 726, 189, 189, 189, 189, 49883, 598, 733, 343, 343, 343, 343, 0, 0, 786, 0, 792, 0, 0, 0, 0, 0, 0, 0, 598, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 803, 0, 0, 24576, 26624, 0, 0, 0, 0, 0, 22528, 0, 0, 269, 269, 269, 269, 0, 0, 293, 293, 298, 0,
  293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 317, 293, 317, 293, 293, 293, 293, 293, 293, 269, 293, 293, 317,
  317, 352, 317, 317, 317, 317, 317, 317, 317, 352, 352, 352, 352, 352, 352, 317, 317, 352, 260, 260, 260, 260, 0, 0, 0,
  392, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 223, 392, 0, 0, 0, 189, 189, 189, 494, 189, 189, 502, 189, 189, 189,
  189, 189, 0, 343, 343, 343, 343, 549, 343, 343, 343, 343, 343, 343, 343, 343, 583, 343, 0, 0, 0, 189, 189, 0, 502,
  189, 189, 189, 189, 0, 343, 343, 343, 343, 550, 343, 343, 559, 343, 343, 343, 343, 343, 580, 343, 343, 343, 343, 0, 0,
  0, 189, 189, 0, 189, 189, 712, 189, 189, 189, 189, 189, 189, 189, 0, 0, 0, 189, 721, 189, 189, 189, 189, 870, 189,
  189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 49883, 343, 343, 343, 343, 343, 739, 343, 343, 343, 343, 343, 343,
  343, 343, 343, 343, 343, 343, 343, 343, 343, 769, 0, 0, 790, 0, 0, 598, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59392, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 804, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 615, 896, 189, 898, 189, 900, 189,
  189, 189, 189, 189, 49883, 343, 343, 343, 343, 343, 343, 343, 343, 585, 779, 0, 0, 0, 782, 0, 0, 343, 343, 913, 343,
  343, 343, 343, 343, 918, 343, 343, 343, 343, 343, 343, 343, 0, 0, 1277, 1278, 0, 0, 0, 0, 0, 343, 343, 343, 928, 343,
  343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 752, 343, 343, 343, 1043, 189, 189, 189, 189, 189, 1047, 189,
  189, 343, 343, 343, 343, 343, 343, 343, 0, 0, 1457, 0, 0, 1360, 189, 189, 189, 343, 343, 343, 343, 1059, 343, 343,
  343, 343, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0, 0, 1350, 260, 189, 189, 189, 189, 189, 189, 189, 189, 189, 1446,
  189, 343, 343, 343, 343, 1513, 1514, 343, 343, 343, 0, 0, 0, 1519, 189, 189, 0, 0, 213, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 223, 189, 189, 189, 189, 1019, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 1380, 189, 189, 189, 343,
  213, 0, 189, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 645, 0, 0, 0, 213, 189, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  646, 0, 792576, 0, 0, 24576, 26624, 0, 0, 0, 0, 213, 22528, 0, 0, 270, 270, 270, 270, 284, 284, 294, 284, 284, 284,
  284, 284, 284, 294, 284, 284, 284, 284, 284, 284, 318, 284, 318, 284, 284, 284, 284, 284, 284, 270, 284, 284, 338,
  338, 353, 318, 338, 338, 338, 338, 338, 338, 353, 353, 353, 353, 353, 353, 338, 338, 353, 6145, 39090, 3, 4, 0, 0, 0,
  0, 0, 0, 187, 188, 189, 0, 0, 378, 223, 0, 0, 0, 0, 410, 0, 0, 0, 414, 0, 0, 0, 0, 0, 0, 827392, 825344, 0, 0, 0,
  559104, 559104, 559104, 559104, 559104, 559104, 559104, 559104, 559104, 559104, 559104, 559104, 559104, 0, 0, 433,
  260, 434, 260, 260, 260, 260, 260, 448, 260, 260, 260, 260, 260, 0, 189, 189, 189, 189, 189, 1413, 189, 1414, 189,
  189, 260, 260, 460, 260, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 433, 0, 0, 0, 30916, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  69632, 0, 0, 0, 0, 474, 0, 0, 0, 0, 0, 479, 0, 0, 0, 0, 0, 0, 0, 673, 0, 0, 0, 0, 0, 0, 0, 0, 0, 51200, 0, 0, 0,
  51200, 51200, 51200, 0, 482, 0, 0, 485, 189, 189, 189, 189, 189, 503, 189, 189, 189, 189, 189, 0, 343, 343, 343, 343,
  551, 343, 343, 343, 343, 343, 343, 343, 343, 586, 0, 0, 0, 0, 0, 0, 0, 260, 260, 260, 260, 838, 260, 260, 260, 260,
  189, 189, 189, 519, 189, 189, 189, 433, 0, 524, 0, 0, 485, 189, 189, 189, 189, 189, 189, 902, 189, 189, 189, 49883,
  343, 343, 343, 343, 343, 0, 0, 1501, 189, 189, 189, 189, 189, 189, 189, 189, 888, 189, 189, 189, 189, 189, 189, 189,
  503, 189, 189, 189, 189, 0, 343, 540, 343, 343, 343, 343, 343, 560, 343, 343, 343, 343, 343, 747, 343, 343, 343, 343,
  343, 343, 343, 343, 753, 343, 0, 0, 606, 0, 0, 0, 0, 0, 612, 0, 0, 0, 0, 0, 0, 0, 781, 0, 0, 189, 189, 189, 189, 189,
  189, 0, 990, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 851, 260, 0, 0, 260, 260, 1004,
  260, 0, 0, 0, 0, 0, 0, 1011, 0, 189, 1013, 189, 189, 189, 189, 189, 1249, 1250, 189, 189, 343, 343, 343, 343, 343,
  343, 343, 343, 343, 343, 1191, 0, 0, 0, 0, 0, 189, 1030, 189, 189, 189, 189, 189, 189, 189, 1036, 189, 189, 189, 189,
  189, 189, 189, 189, 1377, 189, 189, 189, 189, 189, 189, 343, 1470, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0, 0, 0,
  0, 0, 1282, 0, 343, 343, 343, 1070, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 1079, 0, 1093, 0, 1095, 0,
  0, 0, 1098, 0, 0, 1100, 0, 0, 0, 0, 1105, 260, 1120, 260, 260, 1122, 260, 260, 1124, 260, 260, 260, 260, 260, 0, 0,
  1129, 189, 1142, 189, 189, 189, 189, 189, 1148, 189, 189, 189, 189, 189, 189, 189, 189, 189, 49883, 598, 343, 343,
  735, 343, 343, 189, 1155, 189, 1157, 189, 189, 189, 189, 343, 343, 343, 343, 343, 343, 1167, 343, 343, 343, 343, 343,
  1188, 343, 343, 343, 343, 343, 0, 0, 0, 0, 0, 0, 1086, 0, 0, 0, 0, 0, 343, 1170, 343, 1172, 343, 343, 343, 343, 343,
  1177, 343, 343, 343, 343, 343, 343, 343, 343, 343, 751, 343, 343, 343, 343, 343, 343, 343, 343, 343, 763, 343, 343,
  343, 343, 343, 343, 343, 343, 343, 779, 779, 0, 0, 782, 950, 0, 1184, 343, 343, 343, 343, 343, 343, 343, 343, 343,
  343, 0, 0, 0, 0, 0, 950, 0, 0, 1210, 0, 0, 0, 0, 0, 0, 0, 0, 0, 260, 260, 260, 260, 260, 260, 260, 260, 0, 0, 0, 189,
  189, 189, 189, 189, 189, 189, 1236, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 708, 189,
  189, 189, 189, 1247, 189, 189, 189, 189, 189, 343, 343, 343, 343, 343, 343, 343, 343, 0, 189, 1532, 343, 343, 1262,
  343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 1182, 343, 0, 0, 1284, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1294, 0, 0, 0, 59392, 59392, 59392, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 828, 0, 0, 0, 0, 0, 0, 1297, 260, 260,
  260, 260, 260, 260, 260, 0, 0, 0, 189, 1308, 189, 189, 189, 189, 189, 1315, 189, 189, 189, 1318, 1319, 1320, 189, 189,
  189, 189, 189, 0, 343, 343, 343, 547, 343, 343, 343, 343, 343, 343, 189, 189, 189, 1552, 343, 343, 343, 1554, 189,
  189, 189, 189, 189, 189, 1314, 189, 189, 189, 1317, 189, 189, 189, 189, 189, 189, 189, 0, 0, 473, 0, 0, 189, 189, 189,
  189, 189, 189, 501, 189, 189, 189, 189, 189, 1337, 343, 343, 343, 1340, 343, 343, 343, 343, 343, 343, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1089, 0, 0, 1351, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1359, 0, 0, 0, 69632, 0, 0, 0, 0, 69632, 69632,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 260, 260, 1362, 1363, 260, 260, 260, 0, 0, 0, 189, 189, 189, 1369, 1370, 1371, 343, 343,
  343, 1387, 1388, 1389, 343, 343, 343, 343, 343, 343, 1395, 343, 343, 343, 343, 343, 343, 946, 343, 343, 0, 0, 0, 0, 0,
  0, 0, 640, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1113, 0, 0, 0, 1116, 260, 260, 189, 1415, 189, 189, 189, 189, 189, 343, 343,
  343, 343, 343, 343, 1424, 343, 343, 343, 343, 343, 775, 343, 343, 0, 0, 0, 0, 0, 0, 0, 0, 383, 0, 0, 0, 0, 0, 0, 0,
  189, 189, 1465, 189, 189, 189, 343, 343, 343, 1472, 343, 343, 343, 343, 343, 0, 0, 0, 189, 1503, 189, 189, 189, 189,
  189, 189, 189, 0, 392, 0, 0, 0, 189, 189, 189, 530, 0, 0, 1480, 189, 189, 189, 189, 189, 189, 1487, 189, 1489, 343,
  343, 343, 343, 343, 343, 343, 1061, 1062, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 1393, 343, 343, 343, 1397,
  343, 343, 343, 1496, 343, 1498, 0, 0, 0, 189, 189, 189, 189, 189, 189, 189, 189, 1138, 189, 189, 189, 189, 1533, 1534,
  189, 189, 343, 343, 1539, 1540, 343, 343, 189, 189, 189, 189, 189, 189, 189, 343, 343, 343, 343, 343, 343, 189, 189,
  343, 0, 0, 189, 0, 0, 0, 0, 0, 0, 0, 215, 0, 0, 216, 0, 216, 0, 0, 24576, 26624, 0, 217, 216, 216, 217, 22528, 257,
  257, 271, 271, 271, 271, 257, 257, 295, 295, 295, 257, 299, 257, 257, 304, 257, 257, 257, 257, 257, 257, 319, 257,
  319, 257, 257, 257, 257, 257, 257, 271, 257, 257, 319, 319, 354, 319, 319, 319, 319, 319, 319, 319, 354, 354, 354,
  354, 354, 354, 319, 319, 354, 6145, 39090, 3, 4, 0, 0, 0, 0, 0, 372, 187, 188, 189, 0, 0, 0, 0, 716800, 0, 0, 0,
  794624, 0, 0, 0, 0, 0, 0, 0, 0, 1289, 0, 0, 0, 0, 0, 0, 0, 0, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776,
  75776, 75776, 75776, 75776, 75776, 75776, 379, 380, 0, 0, 0, 0, 0, 0, 0, 384, 0, 386, 387, 388, 0, 0, 0, 394, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 223, 223, 0, 0, 0, 0, 0, 0, 627, 0, 0, 0, 260, 458, 260, 260, 0, 0, 0, 0, 0, 0, 0, 0, 469, 0, 0,
  0, 0, 774144, 0, 0, 774144, 0, 0, 561152, 663552, 561152, 561152, 561152, 561152, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 102400, 102400, 102400, 0, 0, 386, 386, 189, 489, 492, 189, 498, 189, 189, 189, 507, 189, 189, 189, 189, 189, 189,
  1147, 189, 189, 189, 189, 189, 189, 189, 189, 189, 343, 343, 343, 1256, 343, 343, 343, 189, 515, 517, 189, 189, 189,
  189, 0, 0, 0, 0, 0, 189, 527, 528, 189, 189, 189, 189, 1033, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189,
  1037, 1038, 189, 189, 189, 189, 189, 533, 189, 515, 517, 0, 343, 343, 545, 548, 343, 554, 343, 343, 343, 565, 567,
  343, 343, 343, 575, 578, 343, 343, 343, 343, 0, 0, 0, 189, 517, 0, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 337920, 223, 0, 343, 343, 343, 343, 774, 343, 343, 343, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1406, 0, 0, 1360, 925, 343, 343,
  343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 924, 343, 343, 343, 343, 944, 343, 343, 343, 343, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1091, 951, 0, 592, 0, 0, 0, 953, 0, 596, 0, 0, 0, 0, 0, 0, 0, 967, 0, 0, 0, 0, 0, 0, 0,
  0, 598, 599, 0, 0, 0, 0, 0, 0, 0, 260, 260, 1299, 260, 260, 260, 260, 260, 0, 0, 0, 189, 189, 189, 1310, 260, 189,
  189, 189, 189, 189, 1442, 189, 189, 189, 189, 189, 343, 343, 343, 1449, 195, 0, 189, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 678, 0, 0, 0, 320, 0, 320, 0, 0, 0, 0, 0, 0, 260, 0, 0, 339, 339, 355, 339, 339, 339, 339, 339, 339, 339, 355,
  355, 355, 355, 355, 355, 339, 339, 355, 0, 260, 260, 260, 260, 260, 260, 260, 656, 260, 260, 260, 260, 260, 260, 260,
  1226, 0, 0, 0, 189, 189, 1231, 189, 189, 189, 189, 724, 189, 189, 189, 189, 189, 189, 730, 49883, 598, 343, 343, 343,
  343, 343, 343, 343, 343, 1075, 343, 343, 343, 343, 343, 343, 343, 0, 1456, 0, 1458, 0, 1360, 189, 189, 189, 343, 343,
  343, 772, 343, 343, 343, 343, 0, 0, 0, 0, 0, 0, 785, 0, 0, 0, 339968, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1357, 0, 0,
  0, 0, 0, 791, 0, 0, 598, 0, 0, 796, 0, 0, 0, 0, 0, 0, 0, 982, 0, 0, 0, 0, 0, 0, 0, 0, 598, 0, 0, 0, 602, 0, 0, 0, 260,
  260, 260, 260, 0, 1007, 0, 0, 0, 0, 0, 0, 189, 189, 189, 189, 189, 189, 189, 1021, 1022, 189, 189, 189, 189, 189, 189,
  189, 0, 391, 0, 0, 0, 189, 189, 189, 529, 0, 423, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 973, 0, 260, 260, 260,
  260, 0, 0, 0, 462, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1104, 0, 0, 0, 189, 0, 218, 0, 0, 0, 0, 0, 0, 218, 0, 0,
  0, 0, 189, 189, 189, 687, 189, 189, 189, 189, 189, 189, 189, 189, 189, 1378, 189, 189, 189, 189, 189, 1384, 0, 0, 189,
  218, 0, 0, 218, 0, 0, 0, 0, 0, 0, 218, 218, 0, 0, 0, 218, 0, 218, 218, 0, 218, 218, 218, 218, 218, 218, 0, 218, 24576,
  26624, 218, 0, 218, 218, 0, 22528, 218, 218, 272, 272, 272, 272, 218, 321, 218, 321, 218, 218, 218, 218, 218, 218,
  272, 218, 218, 321, 321, 356, 321, 321, 321, 321, 321, 321, 321, 356, 356, 356, 356, 356, 356, 321, 321, 356, 0, 0,
  381, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 958, 0, 0, 223, 0, 0, 0, 0, 0, 411, 0, 413, 0, 0, 0, 0, 0, 0, 0, 1203, 0,
  0, 0, 0, 0, 0, 0, 0, 598, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 432, 0, 0, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260,
  260, 454, 260, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 343, 343, 343, 343, 343, 343, 1259, 260, 459,
  260, 260, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 644, 0, 0, 0, 189, 189, 518, 189, 189, 189, 189, 0, 0, 0, 0, 0, 189,
  189, 189, 189, 189, 189, 189, 1034, 189, 189, 189, 189, 189, 189, 189, 189, 189, 49883, 598, 343, 343, 343, 343, 737,
  189, 189, 534, 189, 518, 0, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 0, 586, 0, 189, 189, 0, 343, 568, 570,
  343, 343, 579, 343, 343, 343, 343, 0, 0, 0, 189, 518, 0, 0, 0, 737280, 0, 798720, 847872, 0, 729088, 720896, 741376,
  0, 0, 0, 0, 0, 185, 204, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1217, 260, 260, 260, 260, 260, 0, 0, 620, 621, 223, 223, 0, 0,
  0, 0, 0, 0, 0, 0, 629, 0, 0, 0, 737280, 0, 798720, 847872, 0, 729088, 720896, 741376, 0, 0, 0, 0, 1360, 0, 632, 0, 0,
  0, 0, 0, 0, 0, 0, 642, 0, 0, 0, 0, 0, 592, 596, 0, 598, 0, 0, 0, 0, 0, 0, 0, 398, 399, 0, 0, 0, 0, 0, 223, 223, 189,
  699, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 707, 189, 189, 189, 189, 189, 1375, 189, 189, 189, 189,
  189, 189, 189, 189, 189, 343, 343, 343, 343, 1052, 343, 1054, 0, 976, 0, 0, 0, 980, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 221,
  222, 0, 0, 223, 189, 1029, 189, 189, 1032, 189, 189, 189, 189, 189, 189, 189, 189, 189, 1040, 189, 189, 189, 189, 189,
  1419, 189, 343, 343, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0, 189, 189, 189, 189, 189, 189, 189, 1508, 343, 343,
  1069, 343, 343, 343, 1073, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 936, 343, 343, 343, 343, 343,
  343, 1083, 0, 0, 0, 0, 0, 0, 0, 0, 1088, 0, 0, 0, 0, 774144, 0, 0, 774144, 0, 0, 561529, 663929, 561529, 561529,
  561529, 561529, 561529, 821625, 823673, 561529, 561529, 561529, 561529, 561529, 561529, 561529, 561529, 561529,
  715129, 561529, 561529, 561529, 561529, 745849, 561529, 561529, 561529, 561529, 1092, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 819, 1196, 1197, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79872, 0, 343, 343, 343, 343, 1274, 343, 343,
  0, 1276, 0, 0, 0, 0, 0, 0, 0, 129024, 129024, 129024, 129024, 129024, 129024, 0, 0, 129024, 189, 189, 189, 189, 1328,
  343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0, 1194, 0, 260, 1438, 189, 189, 189, 189, 189, 189, 189,
  1445, 189, 189, 1447, 343, 343, 343, 343, 343, 343, 1174, 343, 1176, 343, 343, 343, 343, 1181, 343, 343, 343, 343,
  343, 343, 1454, 343, 343, 0, 0, 0, 0, 0, 1360, 189, 189, 189, 189, 189, 189, 1160, 189, 343, 343, 343, 343, 343, 343,
  343, 343, 0, 0, 0, 0, 0, 0, 784, 0, 189, 189, 1535, 189, 343, 343, 343, 343, 1541, 343, 189, 189, 189, 189, 189, 189,
  189, 343, 343, 343, 343, 343, 343, 343, 343, 1426, 235, 0, 189, 0, 0, 236, 0, 0, 0, 0, 0, 0, 239, 240, 0, 0, 0, 467,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 829, 0, 422, 0, 0, 0, 24576, 26624, 0, 0, 240, 240, 0, 22528, 258, 258, 273, 273,
  273, 273, 258, 258, 0, 0, 219, 258, 0, 258, 258, 0, 258, 258, 258, 258, 258, 258, 322, 258, 322, 258, 258, 258, 258,
  258, 258, 273, 258, 332, 340, 340, 357, 322, 340, 340, 340, 340, 340, 340, 357, 357, 357, 357, 357, 357, 340, 340,
  357, 223, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 382, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 424, 260, 435, 260, 260, 260, 260, 260,
  449, 260, 260, 260, 260, 260, 0, 189, 189, 189, 1411, 189, 189, 189, 189, 189, 189, 189, 729, 189, 49883, 598, 343,
  343, 343, 343, 343, 504, 189, 189, 189, 189, 0, 343, 541, 343, 343, 343, 343, 343, 561, 343, 343, 343, 343, 343, 916,
  343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0, 496, 189, 0, 0, 0, 588, 0, 0, 0, 0, 0, 598, 0, 0, 0, 0, 0,
  603, 0, 0, 189, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 228, 0, 0, 0, 978, 979, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 402, 0, 0,
  223, 223, 0, 260, 260, 650, 260, 653, 260, 655, 260, 260, 260, 260, 260, 260, 260, 660, 0, 0, 681, 682, 189, 189, 686,
  189, 189, 691, 189, 189, 694, 189, 189, 189, 189, 189, 189, 189, 189, 49883, 598, 343, 343, 343, 736, 343, 343, 742,
  343, 343, 746, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 754, 0, 821, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 124928, 0, 975, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 638, 0, 0, 0, 0, 1130, 0, 0, 189, 189, 189, 189, 189, 189, 189,
  189, 189, 189, 189, 189, 189, 1152, 189, 189, 189, 189, 1143, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189,
  189, 189, 1382, 189, 343, 0, 0, 1211, 0, 0, 0, 0, 0, 0, 0, 0, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260,
  998, 999, 1000, 260, 343, 343, 343, 343, 1264, 343, 343, 343, 343, 343, 343, 343, 343, 343, 1270, 343, 343, 343, 343,
  343, 1275, 343, 0, 0, 0, 0, 0, 0, 0, 0, 0, 231, 0, 0, 0, 0, 0, 0, 260, 189, 189, 189, 1440, 1441, 189, 189, 189, 189,
  189, 189, 343, 343, 343, 343, 343, 343, 343, 343, 0, 1531, 189, 343, 1451, 1452, 343, 343, 343, 343, 0, 0, 0, 0, 0,
  1360, 189, 189, 189, 189, 189, 189, 1239, 189, 189, 189, 189, 189, 189, 189, 189, 189, 343, 343, 1051, 343, 343, 343,
  343, 0, 0, 24576, 26624, 0, 0, 0, 0, 0, 22528, 0, 0, 274, 274, 274, 274, 0, 285, 296, 296, 296, 285, 296, 285, 285,
  296, 285, 285, 296, 296, 296, 296, 323, 296, 323, 296, 296, 296, 296, 296, 285, 274, 285, 296, 341, 341, 358, 367,
  341, 341, 341, 341, 341, 341, 358, 358, 358, 358, 358, 358, 341, 341, 358, 223, 0, 0, 0, 409, 0, 0, 0, 0, 0, 415, 0,
  409, 0, 418, 419, 0, 419, 0, 260, 260, 260, 260, 260, 260, 446, 260, 451, 260, 260, 260, 260, 0, 0, 0, 0, 0, 465, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 465, 0, 0, 0, 457, 260, 260, 260, 0, 0, 0, 0, 464, 0, 467, 0, 0, 0, 0, 0, 598, 0, 0, 0, 0, 0,
  0, 0, 0, 802, 0, 189, 516, 189, 189, 189, 189, 189, 409, 0, 0, 467, 525, 526, 189, 189, 189, 189, 189, 189, 1316, 189,
  189, 189, 189, 189, 189, 189, 189, 189, 0, 0, 343, 343, 343, 343, 343, 532, 189, 189, 516, 189, 0, 343, 542, 343, 343,
  343, 343, 556, 562, 564, 343, 343, 343, 343, 343, 1341, 343, 343, 343, 343, 343, 1348, 0, 0, 0, 0, 0, 565654, 0, 0,
  669696, 0, 0, 0, 0, 0, 0, 0, 211, 0, 0, 0, 0, 0, 0, 0, 0, 0, 124928, 0, 124928, 0, 0, 0, 0, 343, 343, 343, 343, 576,
  343, 343, 343, 343, 343, 0, 0, 0, 189, 189, 0, 0, 189, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 200, 0, 229, 260, 662, 260, 260,
  260, 260, 665, 666, 260, 260, 260, 260, 260, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 131072, 131072, 0, 0, 676, 0, 0,
  189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 1025, 189, 1027, 189, 710, 189, 189, 189, 189, 189, 189,
  189, 189, 189, 623, 676, 0, 720, 189, 189, 189, 189, 189, 1468, 343, 343, 343, 343, 343, 343, 343, 343, 1477, 0, 343,
  343, 757, 343, 343, 343, 343, 343, 343, 343, 764, 765, 343, 343, 343, 343, 343, 343, 343, 1074, 343, 343, 343, 343,
  343, 343, 1078, 343, 0, 0, 806, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 986, 0, 0, 260, 260, 260, 844, 260, 260, 260,
  260, 260, 260, 260, 260, 260, 260, 853, 0, 0, 189, 0, 0, 0, 0, 0, 0, 0, 0, 0, 227, 0, 0, 0, 189, 189, 1133, 189, 189,
  189, 189, 189, 189, 189, 189, 189, 189, 0, 0, 632, 189, 189, 189, 0, 0, 856, 0, 0, 0, 0, 0, 860, 853, 189, 189, 189,
  864, 189, 189, 189, 189, 189, 1525, 343, 343, 343, 343, 343, 343, 343, 0, 189, 189, 189, 189, 189, 1159, 189, 189,
  343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 1065, 343, 1067, 343, 189, 189, 189, 899, 189, 189, 189,
  189, 904, 189, 49883, 343, 343, 343, 343, 910, 343, 926, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343,
  343, 343, 938, 343, 343, 941, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0, 0, 0, 0, 0, 0, 1283, 961, 0, 0, 0, 0, 0,
  966, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 102400, 0, 0, 0, 0, 102400, 260, 1003, 260, 260, 0, 0, 0, 0, 0, 1010, 0, 0, 189,
  189, 189, 189, 189, 189, 189, 1251, 189, 343, 343, 343, 343, 343, 343, 343, 1516, 343, 0, 0, 0, 189, 189, 189, 260,
  260, 260, 1121, 260, 260, 260, 260, 260, 260, 260, 260, 260, 0, 1128, 0, 0, 189, 0, 0, 0, 0, 0, 0, 0, 0, 231, 0, 0, 0,
  0, 0, 1287, 0, 1288, 0, 0, 0, 0, 1292, 1293, 0, 0, 1141, 189, 189, 189, 189, 1146, 189, 189, 189, 189, 189, 189, 189,
  189, 189, 189, 1379, 189, 189, 189, 189, 343, 189, 189, 1246, 189, 1248, 189, 189, 189, 189, 343, 343, 343, 343, 343,
  1258, 343, 343, 343, 343, 343, 1430, 343, 343, 0, 1432, 0, 0, 0, 0, 0, 1360, 1260, 343, 343, 1263, 343, 343, 343, 343,
  343, 343, 343, 343, 343, 343, 343, 343, 766, 343, 343, 343, 189, 189, 189, 1313, 189, 189, 189, 189, 189, 189, 189,
  189, 1321, 189, 1322, 189, 189, 189, 189, 1158, 189, 189, 189, 343, 343, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0,
  189, 189, 1521, 189, 189, 189, 1327, 343, 343, 1330, 343, 343, 343, 343, 343, 343, 1335, 343, 343, 343, 343, 343, 929,
  343, 343, 343, 343, 343, 935, 343, 343, 343, 343, 343, 343, 343, 1343, 343, 343, 343, 0, 0, 0, 0, 0, 201, 202, 203, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 984, 0, 828, 0, 0, 0, 0, 0, 1352, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 565653, 565653,
  189, 189, 189, 1373, 189, 189, 189, 189, 189, 189, 189, 189, 1381, 189, 189, 343, 343, 343, 343, 343, 1455, 343, 0, 0,
  0, 0, 0, 1360, 189, 189, 189, 189, 189, 189, 886, 189, 189, 189, 189, 189, 189, 189, 189, 189, 343, 1050, 343, 343,
  343, 343, 343, 343, 343, 343, 1401, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1360, 189, 189, 189, 189, 1418, 189, 189, 343,
  343, 343, 343, 1422, 343, 343, 343, 343, 343, 343, 343, 1175, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 920,
  343, 343, 343, 343, 343, 343, 343, 343, 343, 1429, 343, 343, 343, 0, 0, 0, 0, 0, 0, 0, 1360, 1509, 343, 343, 343, 343,
  343, 343, 343, 343, 1517, 0, 0, 0, 189, 189, 189, 189, 189, 189, 1376, 189, 189, 189, 189, 189, 189, 189, 189, 343,
  343, 343, 343, 343, 343, 343, 1168, 189, 189, 1523, 1524, 189, 343, 343, 343, 343, 343, 1529, 1530, 343, 0, 189, 189,
  189, 189, 343, 343, 343, 343, 343, 343, 189, 189, 189, 189, 1546, 189, 343, 1556, 189, 343, 189, 343, 189, 343, 189,
  343, 0, 0, 0, 0, 0, 0, 598, 0, 0, 0, 0, 0, 799, 0, 0, 0, 0, 0, 0, 24576, 26624, 0, 0, 0, 0, 0, 22528, 0, 0, 275, 275,
  275, 275, 0, 0, 297, 297, 297, 0, 297, 0, 297, 297, 297, 297, 297, 297, 297, 297, 324, 297, 324, 297, 297, 297, 297,
  297, 297, 275, 297, 297, 324, 324, 359, 324, 324, 324, 324, 324, 324, 324, 359, 359, 359, 359, 359, 359, 324, 324,
  359, 0, 0, 393, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 223, 0, 0, 0, 0, 0, 626, 0, 0, 0, 0, 787, 0, 0, 0, 793, 598, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 401, 0, 0, 0, 223, 223, 880, 189, 189, 189, 884, 189, 189, 189, 189, 189, 189, 189, 189,
  189, 189, 189, 49883, 343, 343, 343, 908, 343, 189, 897, 189, 189, 189, 189, 189, 189, 189, 189, 49883, 343, 343, 343,
  343, 343, 343, 343, 343, 1266, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0, 0, 0, 1360, 189, 189, 189, 0, 0, 963, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1103, 0, 0, 0, 260, 260, 260, 260, 993, 260, 260, 260, 260, 260, 260, 260, 260, 260,
  260, 849, 260, 260, 260, 0, 0, 189, 189, 189, 1018, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 189, 1253,
  343, 343, 343, 343, 343, 343, 343, 343, 1057, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 767,
  343, 343, 189, 1245, 189, 189, 189, 189, 189, 189, 189, 343, 343, 1255, 343, 343, 343, 343, 343, 343, 343, 1391, 343,
  343, 343, 343, 343, 343, 343, 343, 0, 778, 645, 0, 0, 0, 0, 0, 189, 189, 1416, 189, 189, 189, 189, 343, 343, 343, 343,
  343, 343, 343, 1425, 343, 343, 343, 343, 343, 1499, 1500, 0, 1502, 189, 189, 189, 189, 1506, 189, 189, 189, 189, 189,
  714, 189, 189, 718, 189, 0, 0, 0, 189, 189, 189, 189, 189, 189, 522, 0, 462, 0, 0, 0, 189, 189, 189, 495, 189, 189,
  189, 189, 189, 189, 189, 189, 189, 49883, 598, 732, 734, 343, 343, 343, 343, 343, 343, 343, 1550, 343, 189, 189, 189,
  189, 343, 343, 343, 343, 189, 189, 189, 189, 343, 343, 343, 343, 343, 343, 189, 189, 1544, 1545, 189, 189, 189, 189,
  189, 871, 189, 189, 874, 189, 189, 189, 189, 189, 879, 189, 0, 0, 189, 0, 0, 0, 0, 0, 0, 0, 221, 0, 0, 0, 0, 0, 598,
  0, 0, 0, 797, 0, 0, 0, 801, 0, 0, 0, 325, 0, 325, 0, 0, 0, 0, 0, 0, 260, 0, 0, 325, 325, 360, 325, 325, 325, 325, 325,
  325, 325, 360, 360, 360, 360, 360, 360, 325, 325, 360, 0, 260, 260, 260, 260, 260, 654, 260, 260, 260, 260, 260, 260,
  260, 260, 260, 0, 1410, 189, 189, 189, 189, 189, 189, 189, 189, 189, 889, 189, 189, 189, 189, 189, 189, 343, 343, 743,
  343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 343, 1077, 343, 343, 260, 260, 843, 260, 260, 260, 260,
  260, 260, 260, 260, 260, 260, 260, 0, 0, 0, 0, 0, 0, 0, 0, 189, 189, 189, 189, 189, 500, 189, 506, 189, 189, 189, 189,
  0, 855, 0, 0, 0, 0, 0, 0, 0, 0, 189, 189, 189, 189, 189, 189, 189, 189, 189, 695, 189, 189, 0, 0, 24576, 26624, 0, 0,
  252, 252, 0, 22528, 252, 252, 276, 276, 276, 276, 252, 252, 0, 0, 0, 252, 0, 252, 252, 0, 252, 252, 252, 252, 252,
  252, 326, 252, 326, 252, 252, 252, 252, 252, 252, 276, 252, 252, 326, 326, 361, 326, 326, 326, 326, 326, 326, 326,
  361, 361, 361, 361, 361, 361, 326, 326, 361, 0, 327, 0, 327, 0, 0, 0, 0, 0, 0, 260, 0, 0, 327, 327, 362, 327, 327,
  327, 327, 327, 327, 327, 362, 362, 362, 362, 362, 362, 327, 327, 362, 223, 0, 0, 408, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1102, 0, 0, 0, 0, 472, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 565654, 67584, 472, 0, 0, 0, 189, 189, 189, 497,
  189, 189, 189, 189, 189, 189, 189, 189, 1048, 1049, 343, 343, 343, 343, 343, 343, 631, 0, 0, 635, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1115, 260, 260, 260, 770, 343, 343, 343, 343, 343, 343, 343, 0, 0, 0, 0, 0, 783, 0, 0, 0, 475, 0, 468,
  0, 0, 0, 0, 0, 431, 0, 0, 389, 0, 0, 789, 0, 0, 0, 598, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 600, 601, 0, 0, 0, 0, 0, 260,
  260, 260, 260, 260, 260, 260, 995, 260, 260, 260, 260, 260, 260, 260, 1364, 260, 0, 0, 1366, 189, 189, 189, 189, 189,
  189, 189, 424, 0, 465, 0, 0, 486, 189, 189, 189, 189, 189, 504, 189, 189, 189, 189, 189, 189, 189, 1045, 189, 189,
  189, 189, 189, 189, 343, 343, 343, 343, 343, 343, 343, 343, 343, 1478, 0, 331776, 0, 0, 0, 331776, 331776, 331776, 0,
  0, 0, 0, 0, 0, 0, 0, 812, 0, 0, 0, 0, 0, 0, 0, 0, 0, 331776, 0, 331776, 0, 0, 0, 331776, 0, 0, 0, 0, 331776, 331776,
  0, 0, 0, 0, 0, 331776, 0, 331776, 331776, 0, 0, 331776, 332019, 332019, 0, 0, 0, 0, 0, 332019, 0, 0, 0, 0, 331776, 0,
  0, 0, 0, 0, 331776, 0, 331776, 331776, 0, 0, 0, 0, 0, 333824, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1206, 0, 0, 0, 0,
  335872, 335872, 335872, 0, 335872, 0, 335872, 335872, 335872, 335872, 335872, 335872, 335872, 335872, 335872, 0, 0, 0,
  337920, 0, 244, 244, 0, 0, 0, 0, 0, 244, 337920, 337920, 0, 0, 0, 0, 189, 189, 490, 189, 189, 499, 189, 505, 189, 508,
  189, 189, 337920, 0, 337920, 0, 337920, 337920, 337920, 337920, 337920, 337920, 337920, 337920, 337920, 0, 0, 0,
  337920, 0, 337920, 337920, 0, 337920, 337920, 337920, 337920, 337920, 337920, 0, 0, 51200, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1358, 0, 0, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200,
  51200, 51200, 51200, 0, 51200, 0, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 51200, 51200, 0, 0, 0, 0, 193, 194, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 189, 189, 189, 189, 189, 189, 189, 189, 189,
  189, 189, 189, 189, 561152, 561152, 845824, 0, 0, 0, 688128, 0, 0, 778240, 813056, 843776, 0, 667648, 0, 0, 0, 589, 0,
  0, 0, 0, 598, 0, 0, 0, 0, 0, 0, 0, 260, 834, 835, 260, 260, 260, 260, 840, 260, 757760, 802816, 561152, 813056,
  561152, 561152, 561152, 843776, 782336, 0, 0, 0, 0, 0, 704512, 0, 0, 189, 0, 0, 0, 0, 0, 0, 0, 0, 232, 238, 0, 0, 0,
  0, 714752, 0, 0, 0, 0, 0, 0, 0, 0, 833536, 0, 0
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  147, 155, 163, 171, 179, 194, 219, 226, 239, 246, 254, 275, 305, 270, 186, 488, 231, 735, 261, 283, 298, 290, 313,
  321, 329, 337, 345, 353, 684, 210, 361, 371, 210, 384, 380, 210, 210, 210, 210, 210, 210, 210, 210, 210, 210, 210,
  210, 210, 372, 483, 392, 400, 408, 715, 416, 477, 730, 424, 646, 432, 446, 887, 454, 462, 470, 496, 519, 504, 512,
  527, 535, 543, 551, 559, 567, 575, 583, 591, 599, 607, 615, 623, 631, 639, 654, 662, 670, 678, 692, 700, 708, 723,
  743, 201, 750, 758, 766, 774, 923, 782, 790, 798, 821, 806, 814, 829, 881, 837, 845, 853, 867, 875, 895, 903, 859,
  911, 931, 939, 947, 955, 963, 971, 979, 987, 995, 1008, 210, 1002, 210, 210, 1006, 208, 210, 1019, 918, 211, 363, 210,
  438, 210, 1016, 210, 210, 210, 210, 210, 266, 1027, 2245, 1031, 1041, 1036, 1036, 1036, 1037, 1045, 1036, 1036, 1036,
  1034, 1036, 1049, 1053, 1060, 1057, 1067, 1063, 1071, 1075, 1079, 2351, 1086, 1950, 1950, 1766, 1949, 1950, 1093,
  1509, 1105, 1356, 1112, 1950, 1950, 1950, 1428, 2142, 1156, 1157, 1157, 1157, 1157, 1532, 1131, 1430, 1428, 1166,
  1157, 1157, 1119, 1773, 2026, 2031, 2036, 1095, 2118, 1295, 1322, 1950, 1099, 1950, 1950, 1950, 1950, 1950, 1950,
  1950, 1950, 1096, 1950, 1950, 1767, 1950, 2007, 2107, 1106, 1356, 1358, 1950, 1950, 1428, 2142, 2142, 2142, 1157,
  1157, 1157, 1157, 1160, 2142, 1176, 2142, 1168, 1157, 1157, 1157, 1157, 1123, 1777, 1950, 1950, 1950, 1950, 2339,
  1218, 1356, 1356, 1107, 1950, 1429, 2142, 2142, 1156, 1157, 1157, 1158, 1950, 1950, 1950, 1088, 1355, 1356, 1108,
  1428, 2142, 2142, 2142, 2142, 1530, 1157, 1157, 1157, 1157, 1355, 1164, 2142, 2142, 2144, 1157, 1157, 1160, 2106,
  1173, 2142, 1190, 1157, 1157, 2106, 1950, 2106, 1357, 1429, 2142, 1190, 1157, 1157, 1127, 1775, 1131, 1950, 1950,
  1950, 1140, 2141, 2144, 1158, 1527, 2143, 1158, 1177, 2144, 1159, 2142, 1156, 1181, 1191, 1185, 2144, 1189, 1169,
  2145, 1195, 1198, 1203, 1215, 1274, 1222, 1236, 1236, 1236, 1229, 1232, 1241, 1236, 1225, 1235, 1247, 1251, 1277,
  1260, 1264, 1267, 1271, 1281, 1285, 1290, 1300, 1304, 1950, 1950, 1254, 1707, 1313, 1950, 1950, 1950, 1950, 1950,
  1950, 1097, 1950, 1619, 1950, 1950, 1950, 1950, 1950, 1950, 1950, 1864, 1950, 1950, 1950, 2305, 1950, 1950, 1950,
  1950, 2306, 1950, 1950, 1950, 1337, 1344, 1943, 1350, 1362, 1370, 1374, 1378, 1382, 1386, 1390, 1393, 1397, 1479,
  1950, 2258, 1403, 1950, 1950, 1208, 1416, 1421, 1434, 1438, 1468, 1474, 1950, 1950, 1478, 1950, 2259, 1404, 1514,
  1991, 1632, 1516, 1950, 1950, 1950, 1864, 1536, 1950, 1542, 2287, 1486, 1552, 1950, 1950, 1099, 1950, 1950, 1950,
  1950, 1544, 1832, 2229, 1559, 1563, 1950, 1950, 1950, 1864, 1950, 1584, 1590, 1605, 1950, 1950, 2391, 2230, 1579,
  1639, 1950, 1950, 1950, 1950, 1571, 1332, 1952, 1693, 1594, 1950, 1598, 1602, 1332, 1950, 1206, 1950, 2313, 1483,
  1490, 1950, 1950, 1096, 1327, 1331, 1950, 1950, 1950, 1353, 1356, 1358, 1177, 2142, 2390, 1611, 1580, 1566, 1950,
  1950, 1210, 1617, 1636, 1706, 1950, 1410, 1572, 1088, 1366, 1645, 2191, 1950, 1650, 1613, 1657, 1950, 1211, 1088,
  1365, 1623, 2188, 2192, 1950, 1831, 1629, 1663, 1646, 1667, 2316, 2231, 1691, 1950, 1674, 1684, 2166, 1493, 2053,
  1705, 2216, 1688, 1698, 1704, 2217, 1719, 1711, 1716, 1720, 1712, 1146, 1724, 2032, 1728, 1743, 1750, 1751, 1752,
  1510, 1756, 1950, 1950, 1764, 1771, 1950, 1950, 1845, 1618, 1446, 1950, 1984, 1781, 1785, 1082, 1795, 1653, 1806,
  1810, 1814, 1817, 1820, 1824, 1825, 1115, 1464, 1950, 1950, 1829, 1950, 1836, 1944, 1333, 2304, 1850, 1843, 1538,
  1849, 1854, 1858, 2322, 1862, 2380, 1868, 1950, 1872, 1950, 1876, 1884, 2228, 2375, 1618, 1923, 1838, 1950, 1890,
  1096, 1895, 1507, 2202, 1899, 1903, 1950, 1625, 1912, 1863, 1950, 1921, 1927, 1950, 1625, 1932, 1915, 1950, 1950,
  1764, 1670, 1950, 1880, 1680, 1839, 1333, 2304, 1417, 1936, 2396, 2199, 1950, 1209, 1329, 1950, 1089, 1950, 1694,
  1521, 1554, 1958, 1950, 1950, 1948, 1950, 1950, 1956, 1962, 1950, 1950, 1764, 1463, 2228, 1677, 1922, 1981, 1950,
  2027, 2025, 2023, 1950, 1891, 1988, 1950, 1950, 1995, 1950, 1891, 2001, 1950, 1950, 1567, 1950, 1950, 2159, 1309,
  1950, 2005, 2228, 1879, 1143, 1982, 1950, 1321, 1548, 1950, 1555, 1990, 1950, 1950, 1950, 1555, 1990, 1950, 2011,
  1878, 1983, 1095, 1547, 1319, 1950, 1444, 1450, 2171, 1457, 1461, 1950, 2387, 2020, 1950, 1950, 1950, 2138, 1765,
  1464, 1950, 1497, 2286, 1504, 1405, 1950, 1950, 1950, 1354, 1107, 1429, 2142, 2142, 1679, 1095, 2117, 1322, 1317,
  1950, 1950, 1315, 2026, 2040, 1950, 1906, 2044, 1950, 1296, 1517, 1950, 1134, 1291, 1731, 1292, 1950, 1135, 1293,
  1132, 1950, 1135, 1293, 1292, 1132, 1132, 1133, 1134, 2050, 1294, 1950, 1950, 1950, 2125, 1586, 2064, 2068, 2072,
  2076, 2080, 2084, 2088, 2092, 2096, 2097, 1950, 1950, 1094, 1950, 1499, 2226, 1408, 2101, 1950, 1089, 2105, 1323,
  2111, 1950, 2149, 1928, 1950, 1997, 1950, 1500, 2153, 1745, 2157, 1256, 1950, 1950, 1149, 2163, 2302, 1346, 1737,
  1950, 1399, 2122, 2129, 2135, 1734, 2170, 1950, 1950, 1659, 1802, 1917, 2131, 2285, 1101, 2185, 1746, 2158, 1089,
  1950, 1922, 2357, 1424, 1950, 1950, 1950, 2196, 2206, 1440, 2215, 1950, 1950, 1199, 2211, 2221, 1950, 1950, 1759,
  1152, 2124, 1950, 2269, 2279, 1997, 1950, 2225, 2059, 2235, 1950, 2354, 2358, 1426, 1950, 1950, 1800, 2264, 2046,
  1114, 1950, 1950, 1286, 2175, 2181, 1950, 1950, 1571, 1405, 1951, 1950, 1576, 1524, 1950, 1760, 2177, 2265, 1997,
  1100, 2239, 2060, 2243, 1305, 2249, 1426, 1950, 1798, 2263, 2113, 1950, 2273, 1950, 1950, 1340, 1440, 1114, 1950,
  1545, 1950, 1950, 1950, 1950, 1950, 1950, 1500, 2227, 1479, 2057, 1983, 2209, 2255, 1094, 1453, 2276, 1950, 1409,
  1136, 1941, 2115, 1950, 2252, 2283, 1700, 1787, 1406, 1950, 1939, 2291, 1950, 2295, 2300, 2310, 1407, 1908, 2291,
  1950, 2296, 1885, 1411, 2320, 1791, 1886, 2326, 2331, 2344, 2327, 2336, 1412, 1789, 2343, 2348, 2332, 2362, 2363,
  2364, 2368, 2371, 2374, 1950, 1950, 1950, 1950, 1950, 1950, 1470, 2016, 2379, 1607, 2014, 2015, 1965, 2384, 1739,
  1968, 1971, 1974, 1977, 1237, 1243, 2395, 1950, 1546, 1950, 1950, 1950, 1098, 1950, 1950, 1950, 1950, 1950, 1950,
  1641, 1950, 1545, 1950, 1950, 1950, 1950, 1546, 1950, 1950, 1950, 1950, 1950, 2400, 2667, 2783, 2403, 2427, 2440,
  2404, 2471, 2462, 2470, 2470, 2470, 2470, 2657, 2444, 2450, 2453, 2470, 2472, 2462, 2451, 2464, 2469, 2466, 2470,
  2470, 2662, 2468, 2536, 2537, 2487, 2474, 2474, 2474, 2493, 2488, 2488, 2527, 2494, 2529, 2475, 2489, 2488, 2492,
  2539, 2542, 2490, 2540, 2545, 2544, 2547, 2548, 2400, 2667, 2460, 2404, 2404, 2686, 2454, 2404, 2560, 2404, 2404,
  2402, 2404, 2404, 2550, 2404, 2514, 2404, 2404, 2404, 2405, 2404, 2404, 2404, 2407, 2425, 2404, 2587, 2535, 2535,
  2535, 2404, 2404, 2535, 2535, 2615, 2404, 2404, 2404, 2781, 2751, 2448, 2606, 2495, 2683, 2404, 2477, 2478, 2752,
  2411, 2477, 2478, 2432, 2404, 2404, 2404, 2411, 2404, 2404, 2404, 2417, 2404, 3001, 2685, 2404, 2404, 2686, 2519,
  2401, 2825, 2404, 2404, 2688, 2483, 2972, 2614, 2782, 2827, 2751, 2751, 2751, 2751, 2530, 2404, 2404, 2446, 2404,
  2607, 2607, 2553, 2751, 2751, 2751, 2607, 2535, 2535, 2446, 2607, 2404, 2606, 2607, 2607, 2751, 2404, 2606, 2607,
  2751, 2751, 2530, 2607, 2751, 2607, 2607, 2607, 2827, 2751, 2751, 2827, 2827, 2827, 2404, 2404, 2404, 2420, 2512,
  2614, 2566, 2404, 2404, 2699, 2404, 2404, 2404, 2513, 3002, 2401, 2758, 2993, 2769, 2404, 2404, 2713, 2587, 2576,
  2582, 2569, 2422, 2422, 2569, 2578, 2571, 2422, 2437, 2422, 2573, 2575, 2581, 2422, 2422, 2422, 2422, 2438, 2582,
  2583, 2422, 2422, 2437, 3019, 2522, 2580, 2404, 2522, 2521, 2771, 2593, 2405, 2436, 2404, 2404, 2403, 2688, 2597,
  2598, 2603, 2603, 2602, 2605, 2618, 2632, 2620, 2620, 2622, 2404, 2625, 2770, 2422, 2769, 2422, 2437, 2595, 2599,
  2600, 2627, 2630, 2629, 2631, 2633, 2404, 2404, 2404, 2430, 2635, 2404, 2404, 2404, 2433, 2404, 2404, 2404, 2447,
  2476, 2416, 2404, 2404, 2523, 2446, 2404, 2404, 2404, 2455, 2943, 2404, 2404, 2590, 2531, 2659, 2404, 2404, 2404,
  2907, 2476, 2404, 2409, 2563, 2404, 2404, 2404, 2689, 2418, 2664, 3002, 2500, 2783, 2566, 2404, 2404, 2404, 2477,
  2417, 2477, 2678, 2698, 2516, 2995, 2783, 2701, 2703, 2404, 2404, 2404, 2946, 2459, 2458, 2707, 2404, 2404, 2714,
  2535, 2535, 2535, 2535, 2446, 2404, 2404, 2709, 2584, 2404, 2404, 2753, 2433, 2428, 2711, 2404, 2712, 2716, 2719,
  2719, 2717, 2721, 2722, 2724, 2725, 2727, 2728, 2729, 2733, 2733, 2732, 2732, 2730, 2730, 2735, 2736, 2740, 2736,
  2736, 2736, 2736, 2737, 2738, 2404, 2404, 2404, 2948, 2608, 2742, 2792, 2404, 2404, 2404, 2484, 2404, 2404, 2404,
  2512, 2404, 2661, 2747, 2404, 2404, 2404, 2555, 2433, 2754, 3007, 2404, 2404, 2758, 2586, 2404, 2404, 2607, 2607,
  2607, 2476, 3008, 2756, 2404, 2762, 2766, 2764, 2404, 2404, 2404, 2971, 2404, 2884, 2404, 2404, 2404, 3000, 2404,
  2797, 2611, 2404, 2404, 2807, 2983, 2642, 2768, 2757, 2773, 2775, 2777, 2404, 2404, 2404, 3001, 2636, 2508, 2510,
  2404, 2404, 2404, 3010, 2404, 2507, 2509, 2511, 2912, 2404, 2404, 2690, 2404, 2404, 2780, 2695, 2434, 2561, 2985,
  2987, 2779, 2640, 2566, 2404, 2404, 2818, 2637, 2612, 2611, 2404, 2404, 2405, 2424, 2693, 2692, 2435, 2788, 2614,
  2641, 2404, 2404, 2506, 2404, 2506, 2502, 2790, 2979, 2404, 2404, 2404, 2636, 2404, 2695, 2434, 2666, 2804, 2566,
  2404, 2404, 2826, 2607, 2750, 2751, 2751, 2477, 2478, 2745, 2792, 2404, 2404, 2405, 2675, 2404, 2613, 2404, 2404,
  2406, 2404, 2404, 2404, 2903, 2476, 2966, 2566, 2404, 2404, 2407, 2682, 2445, 2425, 2525, 2561, 2656, 2986, 2998,
  2783, 2980, 2404, 2404, 2404, 2644, 2512, 2799, 2608, 2742, 2404, 2433, 2669, 2433, 2517, 2561, 2656, 2986, 2999,
  2518, 2404, 2404, 2616, 2520, 2909, 2806, 2517, 2561, 2985, 2433, 2428, 2744, 2566, 2616, 2404, 2404, 2670, 2426,
  2561, 2985, 2809, 2792, 2404, 2404, 2408, 2408, 2980, 2404, 2806, 2504, 2562, 2985, 2500, 3000, 2404, 2404, 2404,
  2645, 2428, 2744, 2404, 2404, 2423, 2889, 2832, 2404, 2670, 2684, 2435, 2794, 2998, 2428, 2656, 2986, 2999, 2967,
  2404, 2404, 2410, 2404, 2744, 2404, 2616, 2404, 2806, 2812, 2999, 2637, 2404, 2404, 2840, 3000, 2814, 2832, 2404,
  2404, 2431, 2516, 2433, 2669, 2426, 2800, 2428, 2749, 2615, 2404, 2404, 2893, 2637, 2519, 3002, 2401, 2404, 2404,
  2901, 2404, 2404, 2687, 2863, 2433, 2669, 2457, 2669, 2401, 2669, 2554, 2749, 2982, 2404, 2404, 2433, 2669, 2404,
  2404, 2802, 2404, 2404, 2433, 2994, 2823, 2801, 2637, 2404, 2404, 2404, 2648, 2404, 2825, 2802, 2404, 2404, 2404,
  2519, 2608, 2409, 2506, 2781, 2637, 2404, 2802, 2404, 2409, 2864, 2409, 2506, 2915, 2404, 2404, 2915, 2404, 2404,
  2958, 2586, 2671, 2404, 2441, 2697, 2404, 2409, 2834, 2404, 2404, 2459, 2650, 2645, 2638, 2825, 2404, 2404, 2825,
  2404, 2404, 2506, 2506, 2404, 2404, 2974, 2480, 2483, 2404, 2586, 2404, 2404, 2404, 2652, 2404, 2404, 2836, 2404,
  2404, 2478, 2478, 2478, 2478, 2552, 2404, 2560, 2404, 2502, 3014, 2585, 2637, 2404, 2868, 2429, 2404, 2404, 2660,
  2561, 2615, 2838, 2501, 2502, 2404, 2404, 2974, 2516, 2591, 2608, 2745, 2956, 2840, 2851, 2851, 2845, 2842, 2844,
  2847, 2848, 2850, 2851, 2851, 2854, 2851, 2851, 2852, 2858, 2856, 2855, 2856, 2856, 2856, 2856, 2404, 2860, 3000,
  2404, 2404, 2502, 2588, 2869, 2686, 2404, 2863, 2404, 2404, 2501, 2404, 2866, 2966, 2404, 2404, 2502, 2861, 2871,
  2404, 2404, 2412, 2556, 2873, 2978, 2404, 2981, 2404, 2875, 2404, 2413, 2878, 2791, 2404, 2404, 2404, 2654, 2883,
  2404, 2672, 2558, 2673, 2557, 2879, 2559, 2404, 2672, 2404, 2404, 2502, 3000, 2404, 2404, 2781, 2404, 2404, 3001,
  2404, 2404, 2886, 2404, 2404, 2404, 2681, 2555, 2660, 2896, 2996, 2640, 2404, 2409, 2896, 2965, 2404, 2981, 2606,
  2606, 2404, 2404, 2515, 2990, 2660, 2497, 2499, 2997, 2791, 2403, 2404, 2962, 2404, 2891, 2404, 2404, 2404, 2686,
  2404, 2984, 2403, 2404, 2404, 2867, 2660, 2483, 2498, 2676, 2655, 2553, 2615, 2404, 2404, 2989, 2783, 2404, 2404,
  2649, 2404, 2404, 2404, 2677, 2404, 2404, 2404, 2404, 2403, 2404, 2407, 2682, 2898, 2445, 2553, 2589, 3003, 2887,
  2403, 2404, 2407, 2407, 2408, 2697, 2695, 2696, 3013, 3012, 3012, 2421, 2421, 3012, 3016, 3016, 3017, 2519, 2506,
  2404, 2404, 2404, 2687, 2560, 2496, 2445, 2821, 2404, 2404, 2404, 2691, 2645, 2403, 2404, 2404, 2514, 2404, 2496,
  2445, 3003, 2760, 2404, 2586, 2404, 3001, 2503, 2685, 2781, 2893, 2637, 2404, 2408, 2404, 2407, 2404, 2407, 2682,
  2445, 2821, 2404, 2409, 2655, 2476, 2404, 2404, 2404, 2409, 2876, 2637, 2404, 2404, 2829, 2502, 3000, 2404, 2687,
  2876, 2637, 2404, 2868, 2447, 2476, 2404, 2404, 2531, 2964, 2411, 2404, 2433, 2404, 2409, 2684, 2705, 2404, 2654,
  2484, 2404, 2417, 2743, 2651, 2911, 2654, 3001, 2690, 2404, 2914, 2646, 2694, 2654, 2404, 2456, 2917, 2411, 2919,
  2922, 2922, 2920, 2927, 2929, 2931, 2925, 2924, 2922, 2922, 2933, 2933, 2922, 2922, 2923, 2923, 2935, 2936, 2938,
  2936, 2936, 2936, 2936, 2459, 2650, 2404, 3004, 2940, 2404, 2404, 2404, 2713, 2404, 2941, 2760, 2404, 2404, 2531,
  2977, 2404, 2404, 2563, 2404, 2563, 2899, 2942, 2784, 2404, 2404, 2519, 2404, 2404, 2944, 2404, 2404, 2567, 2964,
  2404, 2950, 2952, 2404, 2409, 2905, 2563, 2607, 2607, 2607, 2607, 2751, 2751, 2607, 2430, 2954, 2951, 2956, 2505,
  2636, 2404, 2484, 2645, 2401, 2404, 2404, 2404, 2748, 3005, 2759, 2403, 2404, 2410, 2705, 2669, 2960, 2404, 2404,
  2404, 2763, 2975, 2483, 2534, 2608, 2610, 2810, 2668, 2614, 2956, 2403, 2497, 2969, 2983, 2404, 2416, 2404, 2806,
  2428, 2985, 2809, 2404, 2420, 2479, 2483, 2563, 2615, 2981, 2404, 2405, 2660, 2996, 2639, 2782, 2784, 2404, 2417,
  2479, 2482, 2533, 2563, 2965, 2404, 2404, 2404, 2820, 2401, 2609, 2614, 2782, 2784, 2424, 2693, 2505, 2636, 2404,
  2404, 2404, 2670, 2684, 2428, 2651, 2401, 2404, 2402, 2425, 2497, 2636, 2484, 2401, 2402, 2404, 2404, 2623, 2415,
  2995, 2759, 2403, 2404, 2417, 2480, 2533, 2830, 2783, 2404, 2417, 2513, 2665, 2608, 2995, 2759, 2783, 2403, 2404,
  2404, 2407, 2693, 2565, 2983, 2404, 2654, 2995, 2404, 2417, 2704, 2404, 2417, 2704, 3004, 2831, 2641, 2519, 2404,
  2404, 2404, 2786, 2796, 2404, 2531, 2561, 2615, 2404, 2515, 2532, 2561, 2831, 2831, 2641, 2404, 2404, 2669, 2404,
  2404, 2404, 2653, 2404, 2404, 2990, 2429, 2404, 2433, 3006, 2404, 2404, 2816, 2637, 2661, 2992, 2404, 2404, 2672,
  2674, 2419, 2531, 2561, 2404, 2404, 2404, 2512, 2661, 2429, 2404, 2512, 2661, 2429, 3001, 2524, 2503, 2685, 2561,
  2404, 2429, 2404, 2419, 2419, 2661, 2429, 2404, 2478, 2564, 2404, 2404, 2686, 2483, 2639, 2760, 2404, 2404, 2512,
  2661, 2404, 2512, 2661, 2404, 2660, 2404, 2660, 2531, 2481, 2481, 2481, 2404, 2404, 2404, 2860, 2680, 2404, 2404,
  2404, 2881, 2404, 2679, 2442, 2404, 2485, 2757, 2404, 2404, 2812, 2999, 2980, 3020, 2404, 2404, 2404, 2895, 4, 262144,
  0, -2147483648, 0, 0, 1, 0, 2, 0, 4, 32, 0, 5, 395264, 134225920, 8192, 0, 16, 256, 0, 24, 1, 1, 2, 8, 32, 8192, 8192,
  32768, 0, 28, 64, 0, 32, 14336, 16384, 1, 3, 3, 603979776, 0, 38, 38, 603987968, 8192, 65536, 0, 48, 56, 16793600,
  268451840, 268451840, 1073758208, 16384, 8, 2048, 32, 32768, 16, 134217728, -2147483648, 16924672, 268451840,
  1073758208, -2147467264, 67144064, 536908416, 16793600, 16793600, 16384, 16384, 16448, 16448, 50348032, 50348032,
  131072, 0, 64, 64, 384, 1024, 1024, 2048, 4096, 0, 104, 50348032, 1124089856, 50348032, 147456, 268582912, 1392525312,
  1124089856, 1124089856, 131072, 48, 2048, 8192, 196608, 262144, 1048576, 0, 128, 128, 8192, 4194304, 0, 174, 129024,
  133693440, 2013265920, 0, 256, 512, 0, 384, 2048, 12288, 0, 512, 1, 65, 1, 32768, 128, 14336, 1124155392, 1124089856,
  139264, 8519680, 0, 1024, 4096, 49152, 65536, 65536, 81920, 81984, 1342308472, 147456, 1350713464, 139264, 268582912,
  -796770184, -796770184, -779992968, -796770184, 1124220928, 1401045112, 256, 32896, 64, 131072, 8388608, 4, 64, 1280,
  997376, -1879048192, 0, 16384, 32768, 65536, 131072, 8192, 536870912, 0, 1408, 16777217, 1, 16385, 1, 67, 268435459,
  131137, 65, 32769, 67, 3, 67, 65, 65537, 131073, 1, 536903680, 67108864, 0, 65536, 100663296, 0, 4096, 65536, 131139,
  131139, 258342979, 258342979, -1889265451, 258343127, -1889265451, -1889265451, 258343123, 526778583, 258343127,
  258343127, 258349271, 0, 131072, 131072, 262144, 2097152, 16777216, 0, 12288, 16777216, 33554432, 0, 8192,
  -1889134377, 1, -1889134377, 526844139, -1889134377, 0, 131136, 9175552, 1, 7, 1082918401, 1082924691, 1082924689,
  1082924689, -1889134377, -1889101609, 1340999379, 256, 536870912, 1073741824, 0, 262144, 16777216, 268435456, 0,
  405504, 9961472, 0, 524288, 264200, 8912896, 0, 1048576, 32768, 524288, 524288, 0, 2048, 65536, 524288, 147520,
  15204352, 256, 1024, 16384, 4228224, 512, 1024, 32768, 1048576, 2097152, 8388608, 0, 6, 0, 7, 112, 1280, 262144,
  524288, -2147483648, 16, 2, 2, 4, 48, 32, 128, 0, 8, 0, 12, 2048, 0, 14, 32, 2048, 8, 8, 16, 16, 64, -2147483648,
  1024, 1050624, 32768, 134217728, 32768, 6291456, 80, 16, 536903680, 134250496, 545292320, 1442560, 0, 4194304, 65536,
  814778401, 814778409, 814778409, 831567912, 831567912, 16789512, 16789512, 814778409, 16789512, 831555625, 18232072,
  831555625, 831555625, 831563817, 831567913, 831555689, 831567913, 831567913, 871954478, 831567913, 2147088558,
  2147088558, 2147088559, 2147088559, 1006237870, 2147088558, 1048576, 134217728, 1048576, 8388608, 16777216, 80, 0,
  6291456, 8388608, 8519680, 8519680, 32, 8388608, 768, 9437184, 805306368, 0, 16777216, 67108864, -2147483648, 40, 0,
  26214400, 805306368, 40, 47104, 17825792, 0, 33562624, 1, 10223616, 43008, 47104, 46, 63488, 66584576, 805306368,
  32768, 9437184, 0, 67108864, 134217728, 268435456, -2147483648, 10240, 14336, 32768, 16252928, 98304, 100663296,
  268435456, 536870912, 98304, 16252928, 6, 8, 12288, 512, 32768, 8388608, 67108864, 1073741824, 8388608, 268435456, 6,
  32, 536870912, 14680064, 33554432, 67108864, 128, 65536, 14680064, 100663296, 128, 100663296, 128, 67108864, 512,
  131072, 67108864, 4, 6291456, 4, 4194304, 131072, 8519680, 512, 262144, 33554432, 134217728, 1073741824, 4194304,
  1073741824, 536903680, 1073741824, 128, 4194816, 8388672, 8388672, 455544069, 321326341, 388435205, 295961921,
  295961921, 321326469, 329518401, 455544197, 329649477, 329715013, 329715013, 329731405, 329715013, 396832119,
  -1750123145, -1750123145, 330763589, -1750123145, 128, 16384, 67108864, 512, 4194304, 67108864, 460800, 27262976, 0,
  134217728, 1610612736, 27262976, 268435456, 460800, 18874368, 264192, 0, 536870912, 468992, 27262976, 100663296, 13,
  477184, 28311552, 0, 805306368, 64, 8388608, 100663296, 4, 112, 12, 212992, 32768, 536870912, 4, 2048, 196608, 64,
  2048, 462848, 128, 134217728, 4, 65536, 48, 8192, 48, 65536, 8, 134217744, 1049088, 0, 939524096, 536870914, 0,
  1073741824, -2147219448, -2147219448, -2147215348, -2147215348, -2138826740, -2054940660, -2054940660, -2071717876,
  -2071717876, 629145638, 92274692, 1166016516, 92282884, -2138826740, 629145606, -2138826740, -2054940660, -1652090404,
  -2054416372, -1616388644, -1616388644, -1649992228, -1616388644, 12, 266240, 25165824, 201326592, 0, 790528, 4,
  25165824, 28, 448, 1472, 512000, 60817408, 0, 1472, 2048, 201326592, 268435456, 4, 16777216, 36, 0, 786432, 0, 49152,
  2097152, 33554432, 268435456, 1610612736, 4194304, 536870912, 1024, 49152, 262144, 24, 64, 1408, 49152, 33554432,
  402653184, 1610612736, 0, 100663296, 1073741824, 4096, 524288, 1048576, 14680064, 16777216, 384, 4096, 134217728,
  32768, 33554432, 536870912, 4096, 262144, 10485760, 16777216, 100663296, 134217728, 0, 32768, 131072, 524288, 262144,
  8388608, 393216, 0, 34816, 2, 16, 24, 24, 8, 4194816, 26, 26, 1, 17, 27, 25
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "EPSILON",
  "END",
  "DirCommentContents",
  "IntegerLiteral",
  "DecimalLiteral",
  "DoubleLiteral",
  "StringLiteral",
  "PredefinedEntityRef",
  "'""""'",
  "EscapeApos",
  "ElementContentChar",
  "QuotAttrContentChar",
  "AposAttrContentChar",
  "S",
  "S",
  "CharRef",
  "NCName",
  "QName",
  "PITarget",
  "CommentContents",
  "PragmaContents",
  "DirPIContents",
  "CDataSection",
  "Wildcard",
  "EOF",
  "'!='",
  "'""'",
  "'#)'",
  "'$'",
  "''''",
  "'('",
  "'(#'",
  "'(:'",
  "')'",
  "'*'",
  "'*'",
  "'+'",
  "'+'",
  "','",
  "'-'",
  "'-->'",
  "'.'",
  "'..'",
  "'/'",
  "'//'",
  "'/>'",
  "':)'",
  "'::'",
  "':='",
  "';'",
  "'<'",
  "'<!--'",
  "'</'",
  "'<<'",
  "'<='",
  "'<?'",
  "'='",
  "'>'",
  "'>='",
  "'>>'",
  "'?'",
  "'?>'",
  "'@'",
  "'['",
  "']'",
  "'ancestor'",
  "'ancestor-or-self'",
  "'and'",
  "'as'",
  "'ascending'",
  "'at'",
  "'attribute'",
  "'base-uri'",
  "'boundary-space'",
  "'by'",
  "'case'",
  "'cast'",
  "'castable'",
  "'child'",
  "'collation'",
  "'comment'",
  "'construction'",
  "'copy-namespaces'",
  "'declare'",
  "'default'",
  "'descendant'",
  "'descendant-or-self'",
  "'descending'",
  "'div'",
  "'document'",
  "'document-node'",
  "'element'",
  "'else'",
  "'empty'",
  "'empty-sequence'",
  "'encoding'",
  "'eq'",
  "'every'",
  "'except'",
  "'external'",
  "'following'",
  "'following-sibling'",
  "'for'",
  "'function'",
  "'ge'",
  "'greatest'",
  "'gt'",
  "'idiv'",
  "'if'",
  "'import'",
  "'in'",
  "'inherit'",
  "'instance'",
  "'intersect'",
  "'is'",
  "'item'",
  "'lax'",
  "'le'",
  "'least'",
  "'let'",
  "'lt'",
  "'mod'",
  "'module'",
  "'namespace'",
  "'ne'",
  "'no-inherit'",
  "'no-preserve'",
  "'node'",
  "'of'",
  "'option'",
  "'or'",
  "'order'",
  "'ordered'",
  "'ordering'",
  "'parent'",
  "'preceding'",
  "'preceding-sibling'",
  "'preserve'",
  "'processing-instruction'",
  "'return'",
  "'satisfies'",
  "'schema'",
  "'schema-attribute'",
  "'schema-element'",
  "'self'",
  "'some'",
  "'stable'",
  "'strict'",
  "'strip'",
  "'text'",
  "'then'",
  "'to'",
  "'treat'",
  "'typeswitch'",
  "'union'",
  "'unordered'",
  "'validate'",
  "'variable'",
  "'version'",
  "'where'",
  "'xquery'",
  "'{'",
  "'{{'",
  "'|'",
  "'}'",
  "'}}'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 2048,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer) as xs:integer+
{
  if ($current-state = 0) then
    let $result := $result idiv 2048
    return
      if ($result != 0) then
      (
        $result mod 256 - 1,
        $begin,
        $end - $result idiv 256
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 8
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 8 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 2)
    let $current := $current + 1
    let $i0 := 2048 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 2047) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 2048, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer) as xs:string*
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 5
    let $i0 := $t * 1562 + $state - 1
    let $i1 := $i0 idiv 2
    let $i2 := $i1 idiv 4
    let $i3 := $i2 idiv 8
    return p:token((), $p:EXPECTED[$i0 mod 2 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 mod 8 + $p:EXPECTED[$i3 + 1] + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[2 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[4 + $m]
};

(:~
 : The index of the parser state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk := 1;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the token that has been shifted.
 :)
declare variable $p:b0 := 2;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the token that has been shifted.
 :)
declare variable $p:e0 := 3;

(:~
 : The index of the parser state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 := 4;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 := 5;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 := 6;

(:~
 : The index of the parser state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 := 7;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 := 8;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 := 9;

(:~
 : The index of the parser state for accessing the code of the
 : level-3-lookahead token.
 :)
declare variable $p:l3 := 10;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-3-lookahead token.
 :)
declare variable $p:b3 := 11;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-3-lookahead token.
 :)
declare variable $p:e3 := 12;

(:~
 : The index of the parser state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error := 13;

(:~
 : The index of the parser state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result := 14;

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    if ($error/@o) then
      concat
      (
        "syntax error, found ", $p:TOKEN[$error/@o + 1], "&#10;",
        "while expecting ", $p:TOKEN[$error/@x + 1], "&#10;",
        "after scanning ", string($error/@e - $begin), " characters at line ",
        string($line), ", column ", string($column), "&#10;",
        "...", substring($input, $begin, 32), "..."
      )
    else
      let $expected := p:expected-token-set($error/@s)
      return
        concat
        (
          "lexical analysis failed&#10;",
          "while expecting ",
          "["[exists($expected[2])],
          string-join($expected, ", "),
          "]"[exists($expected[2])],
          "&#10;",
          "after scanning ", string($error/@e - $begin), " characters at line ",
          string($line), ", column ", string($column), "&#10;",
          "...", substring($input, $begin, 32), "..."
        )
};

(:~
 : Shift one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:shift($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    $state[position() >= $p:l1 and position() <= $p:e3],
    0,
    $state[$p:e3],
    $state[position() >= $p:e3],
    if ($state[$p:e0] != $state[$p:b1]) then
      text {substring($input, $state[$p:e0], $state[$p:b1] - $state[$p:e0])}
    else
      (),
    let $name := $p:TOKEN[1 + $state[$p:l1]]
    let $content := substring($input, $state[$p:b1], $state[$p:e1] - $state[$p:b1])
    return
      if (starts-with($name, "'")) then
		    element TOKEN {$content}
	    else
	      element {$name} {$content}
  )
  else
  (
    $state[position() < $p:error],
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] < 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    $state[position() > $p:error]
  )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer) as xs:integer+
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 14) then                                (: S^WS :)
      p:matchW($input, $match[3], $token-set)
    else if ($match[1] = 32) then                           (: '(.' :)
      let $state := p:parse-Whitespace($input, (0, 0, 0, $match, 0, $match[3], 0, 0, 0, 0, false()))
      return p:matchW($input, $state[$p:e0], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:matchW($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      $state[position() > $p:lk and position() < $p:l1],
      $match,
      0, $match[3], 0,
      $state[position() > $p:e2]
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] != 0) then
      $state[position() >= $p:l2 and position() <= $p:e2]
    else
      p:matchW($input, $state[$p:b2], $set)
  return
  (
    $match[1] * 256 + $state[$p:l1],
    $state[position() > $p:lk and position() < $p:l2],
    $match,
    0, $match[3], 0,
    $state[position() > $p:e3]
  )
};

(:~
 : Lookahead one token on level 3 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead3W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] != 0) then
      $state[position() >= $p:l3 and position() <= $p:e3]
    else
      p:matchW($input, $state[$p:b3], $set)
  return
  (
    $match[1] * 65536 + $state[$p:lk],
    $state[position() > $p:lk and position() < $p:l3],
    $match,
    $state[position() > $p:e3]
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:match($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      $state[position() > $p:lk and position() < $p:l1],
      $match,
      0, $match[3], 0,
      $state[position() > $p:e2]
    )
};

(:~
 : Reduce the result stack. Pop $count element, wrap them in a
 : new element named $name, and push the new element.
 :
 : @param $state the parser state.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @return the updated parser state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer) as item()+
{
  $state[position() <= $count],
  element {$name}
  {
    $state[position() > $count]
  }
};

(:~
 : Parse the 1st loop of production Comment (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Comment-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(63, $input, $state)          (: CommentContents | '(.' | '.)' :)
    return
      if ($state[$p:l1] = 46) then                          (: '.)' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 19) then                      (: CommentContents :)
            let $state := p:shift(19, $input, $state)       (: CommentContents :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-Comment($input, $state)
            return $state
        return p:parse-Comment-1($input, $state)
};

(:~
 : Parse Comment.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Comment($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(32, $input, $state)                 (: '(.' :)
  let $state := p:parse-Comment-1($input, $state)
  let $state := p:shift(46, $input, $state)                 (: '.)' :)
  return p:reduce($state, "Comment", $count)
};

(:~
 : Parse the 1st loop of production Whitespace (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Whitespace-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(23, $input, $state)          (: END | S^WS | '(.' :)
    return
      if ($state[$p:l1] = 1) then                           (: END :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 14) then                      (: S^WS :)
            let $state := p:shift(14, $input, $state)       (: S^WS :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-Comment($input, $state)
            return $state
        return p:parse-Whitespace-1($input, $state)
};

(:~
 : Parse Whitespace.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Whitespace($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Whitespace-1($input, $state)
  return p:reduce($state, "Whitespace", $count)
};

(:~
 : Parse Value.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Value($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(13, $input, $state)            (: StringLiteral | QName^Token :)
  let $state :=
    if ($state[$p:l1] = 6) then                             (: StringLiteral :)
      let $state := p:shift(6, $input, $state)              (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(17, $input, $state)             (: QName^Token :)
      return $state
  return p:reduce($state, "Value", $count)
};

(:~
 : Parse Key.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Key($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(17, $input, $state)                 (: QName^Token :)
  return p:reduce($state, "Key", $count)
};

(:~
 : Parse the 1st loop of production KeyValuePairs (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KeyValuePairs-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(67, $input, $state)         (: S^WS | QName^Token | EOF | '(.' :)
    return
      if ($state[$p:l1] != 17) then                         (: QName^Token :)
        $state
      else
        let $state := p:parse-Key($input, $state)
        let $state := p:lookahead1W(99, $input, $state)     (: S^WS | QName^Token | EOF | '(.' | '=' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 56) then                 (: '=' :)
            let $state := p:shift(56, $input, $state)       (: '=' :)
            let $state := p:lookahead1W(64, $input, $state) (: StringLiteral | S^WS | QName^Token | '(.' :)
            let $state := p:parse-Value($input, $state)
            return $state
          else
            $state
        return p:parse-KeyValuePairs-1($input, $state)
};

(:~
 : Parse KeyValuePairs.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KeyValuePairs($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-KeyValuePairs-1($input, $state)
  let $state := p:shift(24, $input, $state)                 (: EOF :)
  return p:reduce($state, "KeyValuePairs", $count)
};

(:~
 : Parse QueryBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QueryBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "QueryBody", $count)
};

(:~
 : Parse MainModule.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MainModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Prolog($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-QueryBody($input, $state)
  return p:reduce($state, "MainModule", $count)
};

(:~
 : Parse OptionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OptionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(83, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(53, $input, $state)           (: S^WS | '(.' | 'option' :)
  let $state := p:shift(129, $input, $state)                (: 'option' :)
  let $state := p:lookahead1W(162, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:lookahead1W(24, $input, $state)           (: StringLiteral | S^WS | '(.' :)
  let $state := p:shift(6, $input, $state)                  (: StringLiteral :)
  return p:reduce($state, "OptionDecl", $count)
};

(:~
 : Parse Param.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Param($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(5, $input, $state)             (: '$' :)
  let $state := p:shift(28, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(162, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:lookahead1W(101, $input, $state)          (: S^WS | '(.' | ')' | ',' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 68) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "Param", $count)
};

(:~
 : Parse the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(73, $input, $state)         (: S^WS | '(.' | ')' | ',' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:shift(38, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-Param($input, $state)
        return p:parse-ParamList-1($input, $state)
};

(:~
 : Parse ParamList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Param($input, $state)
  let $state := p:parse-ParamList-1($input, $state)
  return p:reduce($state, "ParamList", $count)
};

(:~
 : Parse FunctionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(83, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(48, $input, $state)           (: S^WS | '(.' | 'function' :)
  let $state := p:shift(103, $input, $state)                (: 'function' :)
  let $state := p:lookahead1W(148, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'child' | 'collation' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'else' | 'empty' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'module' | 'ne' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'return' | 'satisfies' | 'self' |
                                                               'some' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-FunctionName($input, $state)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(68, $input, $state)           (: S^WS | '$' | '(.' | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28) then                       (: '$' :)
      let $state := p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(106, $input, $state)          (: S^WS | '(.' | 'as' | 'external' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 68) then                       (: 'as' :)
      let $state := p:shift(68, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(89, $input, $state)           (: S^WS | '(.' | 'external' | '{' :)
  let $state :=
    if ($state[$p:l1] = 161) then                           (: '{' :)
      let $state := p:parse-EnclosedExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(99, $input, $state)             (: 'external' :)
      return $state
  return p:reduce($state, "FunctionDecl", $count)
};

(:~
 : Parse NodeComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 114) then                           (: 'is' :)
      let $state := p:shift(114, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '<<' :)
      let $state := p:shift(53, $input, $state)             (: '<<' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(59, $input, $state)             (: '>>' :)
      return $state
  return p:reduce($state, "NodeComp", $count)
};

(:~
 : Parse GeneralComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 56) then                            (: '=' :)
      let $state := p:shift(56, $input, $state)             (: '=' :)
      return $state
    else if ($state[$p:l1] = 25) then                       (: '!=' :)
      let $state := p:shift(25, $input, $state)             (: '!=' :)
      return $state
    else if ($state[$p:l1] = 50) then                       (: '<' :)
      let $state := p:shift(50, $input, $state)             (: '<' :)
      return $state
    else if ($state[$p:l1] = 54) then                       (: '<=' :)
      let $state := p:shift(54, $input, $state)             (: '<=' :)
      return $state
    else if ($state[$p:l1] = 57) then                       (: '>' :)
      let $state := p:shift(57, $input, $state)             (: '>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(58, $input, $state)             (: '>=' :)
      return $state
  return p:reduce($state, "GeneralComp", $count)
};

(:~
 : Parse ValueComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 96) then                            (: 'eq' :)
      let $state := p:shift(96, $input, $state)             (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'ne' :)
      let $state := p:shift(124, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'lt' :)
      let $state := p:shift(120, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'le' :)
      let $state := p:shift(117, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'gt' :)
      let $state := p:shift(106, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(104, $input, $state)            (: 'ge' :)
      return $state
  return p:reduce($state, "ValueComp", $count)
};

(:~
 : Parse SingleType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(158, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-AtomicType($input, $state)
  let $state := p:lookahead1W(143, $input, $state)          (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 60) then                       (: '?' :)
      let $state := p:shift(60, $input, $state)             (: '?' :)
      return $state
    else
      $state
  return p:reduce($state, "SingleType", $count)
};

(:~
 : Parse Pragma.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Pragma($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(6, $input, $state)             (: '(#' :)
  let $state := p:shift(31, $input, $state)                 (: '(#' :)
  let $state := p:lookahead1(159, $input, $state)           (: S | QName^Token | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 13) then                       (: S :)
      let $state := p:shift(13, $input, $state)             (: S :)
      return $state
    else
      $state
  let $state := p:lookahead1(158, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:lookahead1(14, $input, $state)            (: S | '#)' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 13) then                       (: S :)
      let $state := p:shift(13, $input, $state)             (: S :)
      let $state := p:lookahead1(2, $input, $state)         (: PragmaContents :)
      let $state := p:shift(20, $input, $state)             (: PragmaContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(4, $input, $state)             (: '#)' :)
  let $state := p:shift(27, $input, $state)                 (: '#)' :)
  return p:reduce($state, "Pragma", $count)
};

(:~
 : Parse the 1st loop of production ExtensionExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(72, $input, $state)         (: S^WS | '(#' | '(.' | '{' :)
    return
      if ($state[$p:l1] != 31) then                         (: '(#' :)
        $state
      else
        p:parse-ExtensionExpr-1($input, $state)
};

(:~
 : Parse ExtensionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExtensionExpr-1($input, $state)
  let $state := p:shift(161, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(173, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 164) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(62, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(164, $input, $state)                (: '}' :)
  return p:reduce($state, "ExtensionExpr", $count)
};

(:~
 : Parse AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 62) then                       (: '@' :)
      let $state := p:shift(62, $input, $state)             (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-NodeTest($input, $state)
  return p:reduce($state, "AbbrevForwardStep", $count)
};

(:~
 : Parse ForwardAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 78) then                            (: 'child' :)
      let $state := p:shift(78, $input, $state)             (: 'child' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'descendant' :)
      let $state := p:shift(85, $input, $state)             (: 'descendant' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'attribute' :)
      let $state := p:shift(71, $input, $state)             (: 'attribute' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'self' :)
      let $state := p:shift(144, $input, $state)            (: 'self' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'descendant-or-self' :)
      let $state := p:shift(86, $input, $state)             (: 'descendant-or-self' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'following-sibling' :)
      let $state := p:shift(101, $input, $state)            (: 'following-sibling' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(100, $input, $state)            (: 'following' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
  return p:reduce($state, "ForwardAxis", $count)
};

(:~
 : Parse ForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 71) then                            (: 'attribute' :)
      let $state := p:lookahead2W(152, $input, $state)      (: S^WS | EOF | '!=' | '(' | '(.' | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 78                             (: 'descendant' :)
          or $state[$p:l1] = 85                             (: 'descendant-or-self' :)
          or $state[$p:l1] = 86                             (: 'following' :)
          or $state[$p:l1] = 100                            (: 'following-sibling' :)
          or $state[$p:l1] = 101                            (: 'self' :)
          or $state[$p:l1] = 144) then                      (: 'self' :)
      let $state := p:lookahead2W(150, $input, $state)      (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 12103                               (: 'attribute' '::' :)
     or $state[$p:lk] = 12110                               (: 'child' '::' :)
     or $state[$p:lk] = 12117                               (: 'descendant' '::' :)
     or $state[$p:lk] = 12118                               (: 'descendant-or-self' '::' :)
     or $state[$p:lk] = 12132                               (: 'following' '::' :)
     or $state[$p:lk] = 12133                               (: 'following-sibling' '::' :)
     or $state[$p:lk] = 12176) then                         (: 'self' '::' :)
      let $state := p:parse-ForwardAxis($input, $state)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-NodeTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AbbrevForwardStep($input, $state)
      return $state
  return p:reduce($state, "ForwardStep", $count)
};

(:~
 : Parse AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(42, $input, $state)                 (: '..' :)
  return p:reduce($state, "AbbrevReverseStep", $count)
};

(:~
 : Parse NameTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 23) then                            (: Wildcard :)
      let $state := p:shift(23, $input, $state)             (: Wildcard :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  return p:reduce($state, "NameTest", $count)
};

(:~
 : Parse NodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(160, $input, $state)           (: QName^Token | Wildcard | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 71                                  (: 'comment' :)
     or $state[$p:l1] = 80                                  (: 'document-node' :)
     or $state[$p:l1] = 90                                  (: 'element' :)
     or $state[$p:l1] = 91                                  (: 'node' :)
     or $state[$p:l1] = 127                                 (: 'processing-instruction' :)
     or $state[$p:l1] = 138                                 (: 'schema-attribute' :)
     or $state[$p:l1] = 142                                 (: 'schema-element' :)
     or $state[$p:l1] = 143                                 (: 'text' :)
     or $state[$p:l1] = 149) then                           (: 'text' :)
      let $state := p:lookahead2W(149, $input, $state)      (: S^WS | EOF | '!=' | '(' | '(.' | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 7751                                (: 'attribute' '(' :)
     or $state[$p:lk] = 7760                                (: 'comment' '(' :)
     or $state[$p:lk] = 7770                                (: 'document-node' '(' :)
     or $state[$p:lk] = 7771                                (: 'element' '(' :)
     or $state[$p:lk] = 7807                                (: 'node' '(' :)
     or $state[$p:lk] = 7818                                (: 'processing-instruction' '(' :)
     or $state[$p:lk] = 7822                                (: 'schema-attribute' '(' :)
     or $state[$p:lk] = 7823                                (: 'schema-element' '(' :)
     or $state[$p:lk] = 7829) then                          (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NameTest($input, $state)
      return $state
  return p:reduce($state, "NodeTest", $count)
};

(:~
 : Parse ReverseAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 134) then                           (: 'parent' :)
      let $state := p:shift(134, $input, $state)            (: 'parent' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 65) then                       (: 'ancestor' :)
      let $state := p:shift(65, $input, $state)             (: 'ancestor' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'preceding-sibling' :)
      let $state := p:shift(136, $input, $state)            (: 'preceding-sibling' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'preceding' :)
      let $state := p:shift(135, $input, $state)            (: 'preceding' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(66, $input, $state)             (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
  return p:reduce($state, "ReverseAxis", $count)
};

(:~
 : Parse ReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 42) then                            (: '..' :)
      let $state := p:parse-AbbrevReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ReverseAxis($input, $state)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-NodeTest($input, $state)
      return $state
  return p:reduce($state, "ReverseStep", $count)
};

(:~
 : Parse AxisStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 65                                  (: 'ancestor-or-self' :)
     or $state[$p:l1] = 66                                  (: 'parent' :)
     or $state[$p:l1] = 134                                 (: 'preceding' :)
     or $state[$p:l1] = 135                                 (: 'preceding-sibling' :)
     or $state[$p:l1] = 136) then                           (: 'preceding-sibling' :)
      let $state := p:lookahead2W(150, $input, $state)      (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 42                                  (: '..' :)
     or $state[$p:lk] = 12097                               (: 'ancestor' '::' :)
     or $state[$p:lk] = 12098                               (: 'ancestor-or-self' '::' :)
     or $state[$p:lk] = 12166                               (: 'parent' '::' :)
     or $state[$p:lk] = 12167                               (: 'preceding' '::' :)
     or $state[$p:lk] = 12168) then                         (: 'preceding-sibling' '::' :)
      let $state := p:parse-ReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-PredicateList($input, $state)
  return p:reduce($state, "AxisStep", $count)
};

(:~
 : Parse Predicate.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(63, $input, $state)                 (: '[' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(36, $input, $state)           (: S^WS | '(.' | ']' :)
  let $state := p:shift(64, $input, $state)                 (: ']' :)
  return p:reduce($state, "Predicate", $count)
};

(:~
 : Parse the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(147, $input, $state)        (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 63) then                         (: '[' :)
        $state
      else
        let $state := p:parse-Predicate($input, $state)
        return p:parse-PredicateList-1($input, $state)
};

(:~
 : Parse PredicateList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PredicateList-1($input, $state)
  return p:reduce($state, "PredicateList", $count)
};

(:~
 : Parse CompPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(138, $input, $state)                (: 'processing-instruction' :)
  let $state := p:lookahead1W(127, $input, $state)          (: S^WS | NCName^Token | '(.' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '{' :)
  let $state :=
    if ($state[$p:l1] = 161) then                           (: '{' :)
      let $state := p:shift(161, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(62, $input, $state)       (: S^WS | '(.' | '}' :)
      let $state := p:shift(164, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NCName($input, $state)
      return $state
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(161, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(173, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 164) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(62, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(164, $input, $state)                (: '}' :)
  return p:reduce($state, "CompPIConstructor", $count)
};

(:~
 : Parse CompCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(80, $input, $state)                 (: 'comment' :)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(161, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(62, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(164, $input, $state)                (: '}' :)
  return p:reduce($state, "CompCommentConstructor", $count)
};

(:~
 : Parse CompTextConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompTextConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(149, $input, $state)                (: 'text' :)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(161, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(62, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(164, $input, $state)                (: '}' :)
  return p:reduce($state, "CompTextConstructor", $count)
};

(:~
 : Parse CompAttrConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompAttrConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(71, $input, $state)                 (: 'attribute' :)
  let $state := p:lookahead1W(165, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
  let $state :=
    if ($state[$p:l1] = 161) then                           (: '{' :)
      let $state := p:shift(161, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(62, $input, $state)       (: S^WS | '(.' | '}' :)
      let $state := p:shift(164, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(161, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(173, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 164) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(62, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(164, $input, $state)                (: '}' :)
  return p:reduce($state, "CompAttrConstructor", $count)
};

(:~
 : Parse ContentExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContentExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "ContentExpr", $count)
};

(:~
 : Parse CompElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(91, $input, $state)                 (: 'element' :)
  let $state := p:lookahead1W(165, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
  let $state :=
    if ($state[$p:l1] = 161) then                           (: '{' :)
      let $state := p:shift(161, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(62, $input, $state)       (: S^WS | '(.' | '}' :)
      let $state := p:shift(164, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(161, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(173, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 164) then                     (: '}' :)
      let $state := p:parse-ContentExpr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(62, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(164, $input, $state)                (: '}' :)
  return p:reduce($state, "CompElemConstructor", $count)
};

(:~
 : Parse CompDocConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompDocConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(89, $input, $state)                 (: 'document' :)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(161, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(62, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(164, $input, $state)                (: '}' :)
  return p:reduce($state, "CompDocConstructor", $count)
};

(:~
 : Parse ComputedConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComputedConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 89) then                            (: 'document' :)
      let $state := p:parse-CompDocConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'element' :)
      let $state := p:parse-CompElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'attribute' :)
      let $state := p:parse-CompAttrConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'text' :)
      let $state := p:parse-CompTextConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'comment' :)
      let $state := p:parse-CompCommentConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CompPIConstructor($input, $state)
      return $state
  return p:reduce($state, "ComputedConstructor", $count)
};

(:~
 : Parse DirPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(55, $input, $state)                 (: '<?' :)
  let $state := p:lookahead1(1, $input, $state)             (: PITarget :)
  let $state := p:shift(18, $input, $state)                 (: PITarget :)
  let $state := p:lookahead1(17, $input, $state)            (: S | '?>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 13) then                       (: S :)
      let $state := p:shift(13, $input, $state)             (: S :)
      let $state := p:lookahead1(3, $input, $state)         (: DirPIContents :)
      let $state := p:shift(21, $input, $state)             (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(10, $input, $state)            (: '?>' :)
  let $state := p:shift(61, $input, $state)                 (: '?>' :)
  return p:reduce($state, "DirPIConstructor", $count)
};

(:~
 : Parse DirCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(51, $input, $state)                 (: '<!--' :)
  let $state := p:lookahead1(0, $input, $state)             (: DirCommentContents :)
  let $state := p:shift(2, $input, $state)                  (: DirCommentContents :)
  let $state := p:lookahead1(7, $input, $state)             (: '-->' :)
  let $state := p:shift(40, $input, $state)                 (: '-->' :)
  return p:reduce($state, "DirCommentConstructor", $count)
};

(:~
 : Parse DirElemContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 50                                  (: '<' :)
     or $state[$p:l1] = 51                                  (: '<!--' :)
     or $state[$p:l1] = 55) then                            (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 22) then                       (: CDataSection :)
      let $state := p:shift(22, $input, $state)             (: CDataSection :)
      return $state
    else if ($state[$p:l1] = 10) then                       (: ElementContentChar :)
      let $state := p:shift(10, $input, $state)             (: ElementContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return p:reduce($state, "DirElemContent", $count)
};

(:~
 : Parse AposAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AposAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 12) then                            (: AposAttrContentChar :)
      let $state := p:shift(12, $input, $state)             (: AposAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return p:reduce($state, "AposAttrValueContent", $count)
};

(:~
 : Parse EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(161, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(62, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(164, $input, $state)                (: '}' :)
  return p:reduce($state, "EnclosedExpr", $count)
};

(:~
 : Parse CommonContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommonContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 7) then                             (: PredefinedEntityRef :)
      let $state := p:shift(7, $input, $state)              (: PredefinedEntityRef :)
      return $state
    else if ($state[$p:l1] = 15) then                       (: CharRef :)
      let $state := p:shift(15, $input, $state)             (: CharRef :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: '{{' :)
      let $state := p:shift(162, $input, $state)            (: '{{' :)
      return $state
    else if ($state[$p:l1] = 165) then                      (: '}}' :)
      let $state := p:shift(165, $input, $state)            (: '}}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EnclosedExpr($input, $state)
      return $state
  return p:reduce($state, "CommonContent", $count)
};

(:~
 : Parse QuotAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuotAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 11) then                            (: QuotAttrContentChar :)
      let $state := p:shift(11, $input, $state)             (: QuotAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return p:reduce($state, "QuotAttrValueContent", $count)
};

(:~
 : Parse the 1st loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(115, $input, $state)         (: PredefinedEntityRef | EscapeQuot | QuotAttrContentChar |
                                                               CharRef | '"' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 26) then                          (: '"' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 8) then                       (: EscapeQuot :)
            let $state := p:shift(8, $input, $state)        (: EscapeQuot :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-QuotAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-1($input, $state)
};

(:~
 : Parse the 2nd loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(116, $input, $state)         (: PredefinedEntityRef | EscapeApos | AposAttrContentChar |
                                                               CharRef | "'" | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 29) then                          (: "'" :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 9) then                       (: EscapeApos :)
            let $state := p:shift(9, $input, $state)        (: EscapeApos :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-AposAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-2($input, $state)
};

(:~
 : Parse DirAttributeValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(18, $input, $state)            (: '"' | "'" :)
  let $state :=
    if ($state[$p:l1] = 26) then                            (: '"' :)
      let $state := p:shift(26, $input, $state)             (: '"' :)
      let $state := p:parse-DirAttributeValue-1($input, $state)
      let $state := p:shift(26, $input, $state)             (: '"' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(29, $input, $state)             (: "'" :)
      let $state := p:parse-DirAttributeValue-2($input, $state)
      let $state := p:shift(29, $input, $state)             (: "'" :)
      return $state
  return p:reduce($state, "DirAttributeValue", $count)
};

(:~
 : Parse the 1st loop of production DirAttributeList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(26, $input, $state)          (: S | '/>' | '>' :)
    return
      if ($state[$p:l1] != 13) then                         (: S :)
        $state
      else
        let $state := p:shift(13, $input, $state)           (: S :)
        let $state := p:lookahead1(163, $input, $state)     (: S | QName^Token | '/>' | '>' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 13                      (: S :)
               and $state[$p:l1] != 45                      (: '/>' :)
               and $state[$p:l1] != 57) then                (: '>' :)
            let $state := p:parse-QName($input, $state)
            let $state := p:lookahead1(15, $input, $state)  (: S | '=' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 13) then             (: S :)
                let $state := p:shift(13, $input, $state)   (: S :)
                return $state
              else
                $state
            let $state := p:lookahead1(8, $input, $state)   (: '=' :)
            let $state := p:shift(56, $input, $state)       (: '=' :)
            let $state := p:lookahead1(25, $input, $state)  (: S | '"' | "'" :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 13) then             (: S :)
                let $state := p:shift(13, $input, $state)   (: S :)
                return $state
              else
                $state
            let $state := p:parse-DirAttributeValue($input, $state)
            return $state
          else
            $state
        return p:parse-DirAttributeList-1($input, $state)
};

(:~
 : Parse DirAttributeList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-DirAttributeList-1($input, $state)
  return p:reduce($state, "DirAttributeList", $count)
};

(:~
 : Parse the 1st loop of production DirElemConstructor (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(122, $input, $state)         (: PredefinedEntityRef | ElementContentChar | CharRef |
                                                               CDataSection | '<' | '<!--' | '</' | '<?' | '{' | '{{' |
                                                               '}}' :)
    return
      if ($state[$p:l1] = 52) then                          (: '</' :)
        $state
      else
        let $state := p:parse-DirElemContent($input, $state)
        return p:parse-DirElemConstructor-1($input, $state)
};

(:~
 : Parse DirElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(50, $input, $state)                 (: '<' :)
  let $state := p:lookahead1(158, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:parse-DirAttributeList($input, $state)
  let $state := p:lookahead1(19, $input, $state)            (: '/>' | '>' :)
  let $state :=
    if ($state[$p:l1] = 45) then                            (: '/>' :)
      let $state := p:shift(45, $input, $state)             (: '/>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(57, $input, $state)             (: '>' :)
      let $state := p:parse-DirElemConstructor-1($input, $state)
      let $state := p:shift(52, $input, $state)             (: '</' :)
      let $state := p:lookahead1(158, $input, $state)       (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state := p:parse-QName($input, $state)
      let $state := p:lookahead1(16, $input, $state)        (: S | '>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 13) then                   (: S :)
          let $state := p:shift(13, $input, $state)         (: S :)
          return $state
        else
          $state
      let $state := p:lookahead1(9, $input, $state)         (: '>' :)
      let $state := p:shift(57, $input, $state)             (: '>' :)
      return $state
  return p:reduce($state, "DirElemConstructor", $count)
};

(:~
 : Parse DirectConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirectConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 50) then                            (: '<' :)
      let $state := p:parse-DirElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 51) then                       (: '<!--' :)
      let $state := p:parse-DirCommentConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-DirPIConstructor($input, $state)
      return $state
  return p:reduce($state, "DirectConstructor", $count)
};

(:~
 : Parse Constructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Constructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 50                                  (: '<' :)
     or $state[$p:l1] = 51                                  (: '<!--' :)
     or $state[$p:l1] = 55) then                            (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ComputedConstructor($input, $state)
      return $state
  return p:reduce($state, "Constructor", $count)
};

(:~
 : Parse UnorderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnorderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(155, $input, $state)                (: 'unordered' :)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(161, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(62, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(164, $input, $state)                (: '}' :)
  return p:reduce($state, "UnorderedExpr", $count)
};

(:~
 : Parse OrderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(132, $input, $state)                (: 'ordered' :)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(161, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(62, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(164, $input, $state)                (: '}' :)
  return p:reduce($state, "OrderedExpr", $count)
};

(:~
 : Parse the 1st loop of production FunctionCall (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionCall-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(73, $input, $state)         (: S^WS | '(.' | ')' | ',' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:shift(38, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-FunctionCall-1($input, $state)
};

(:~
 : Parse FunctionCall.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-FunctionName($input, $state)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(171, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | ')' | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: ')' :)
      let $state := p:parse-ExprSingle($input, $state)
      let $state := p:parse-FunctionCall-1($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  return p:reduce($state, "FunctionCall", $count)
};

(:~
 : Parse ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(41, $input, $state)                 (: '.' :)
  return p:reduce($state, "ContextItemExpr", $count)
};

(:~
 : Parse ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(171, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | ')' | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: ')' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  return p:reduce($state, "ParenthesizedExpr", $count)
};

(:~
 : Parse VarRef.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(28, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(162, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  return p:reduce($state, "VarRef", $count)
};

(:~
 : Parse NumericLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 3) then                             (: IntegerLiteral :)
      let $state := p:shift(3, $input, $state)              (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 4) then                        (: DecimalLiteral :)
      let $state := p:shift(4, $input, $state)              (: DecimalLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(5, $input, $state)              (: DoubleLiteral :)
      return $state
  return p:reduce($state, "NumericLiteral", $count)
};

(:~
 : Parse Literal.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Literal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 6) then                             (: StringLiteral :)
      let $state := p:shift(6, $input, $state)              (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NumericLiteral($input, $state)
      return $state
  return p:reduce($state, "Literal", $count)
};

(:~
 : Parse PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(161, $input, $state)           (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | QName^Token | '$' | '(' | '.' | '<' |
                                                               '<!--' | '<?' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'element' | 'else' | 'empty' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'module' | 'ne' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'self' | 'some' | 'stable' | 'text' | 'to' | 'treat' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 89                                  (: 'ordered' :)
     or $state[$p:l1] = 132                                 (: 'unordered' :)
     or $state[$p:l1] = 155) then                           (: 'unordered' :)
      let $state := p:lookahead2W(71, $input, $state)       (: S^WS | '(' | '(.' | '{' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 3                                   (: IntegerLiteral :)
     or $state[$p:lk] = 4                                   (: DecimalLiteral :)
     or $state[$p:lk] = 5                                   (: DoubleLiteral :)
     or $state[$p:lk] = 6) then                             (: StringLiteral :)
      let $state := p:parse-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 28) then                       (: '$' :)
      let $state := p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 30) then                       (: '(' :)
      let $state := p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 41) then                       (: '.' :)
      let $state := p:parse-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 41348) then                    (: 'ordered' '{' :)
      let $state := p:parse-OrderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 41371) then                    (: 'unordered' '{' :)
      let $state := p:parse-UnorderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 50                             (: '<' :)
          or $state[$p:lk] = 51                             (: '<!--' :)
          or $state[$p:lk] = 55                             (: '<?' :)
          or $state[$p:lk] = 71                             (: 'attribute' :)
          or $state[$p:lk] = 80                             (: 'comment' :)
          or $state[$p:lk] = 91                             (: 'element' :)
          or $state[$p:lk] = 138                            (: 'processing-instruction' :)
          or $state[$p:lk] = 149                            (: 'text' :)
          or $state[$p:lk] = 41305) then                    (: 'document' '{' :)
      let $state := p:parse-Constructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionCall($input, $state)
      return $state
  return p:reduce($state, "PrimaryExpr", $count)
};

(:~
 : Parse FilterExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FilterExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PrimaryExpr($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-PredicateList($input, $state)
  return p:reduce($state, "FilterExpr", $count)
};

(:~
 : Parse StepExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(168, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(.' | '.' | '..' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 71) then                            (: 'attribute' :)
      let $state := p:lookahead2W(175, $input, $state)      (: S^WS | QName^Token | EOF | '!=' | '(' | '(.' | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] = 19271) then                     (: 'attribute' 'case' :)
          let $state := p:lookahead3W(166, $input, $state)  (: S^WS | QName^Token | '$' | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 20295) then                (: 'attribute' 'collation' :)
          let $state := p:lookahead3W(66, $input, $state)   (: StringLiteral | S^WS | '(.' | '{' :)
          return $state
        else if ($state[$p:lk] = 21575) then                (: 'attribute' 'default' :)
          let $state := p:lookahead3W(100, $input, $state)  (: S^WS | '$' | '(.' | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 23879) then                (: 'attribute' 'empty' :)
          let $state := p:lookahead3W(108, $input, $state)  (: S^WS | '(.' | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 28743) then                (: 'attribute' 'instance' :)
          let $state := p:lookahead3W(94, $input, $state)   (: S^WS | '(.' | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 33607) then                (: 'attribute' 'order' :)
          let $state := p:lookahead3W(85, $input, $state)   (: S^WS | '(.' | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 37447) then                (: 'attribute' 'stable' :)
          let $state := p:lookahead3W(95, $input, $state)   (: S^WS | '(.' | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 17735                      (: 'attribute' 'descending' :)
              or $state[$p:lk] = 22343) then                (: 'attribute' 'descending' :)
          let $state := p:lookahead3W(114, $input, $state)  (: S^WS | '(.' | ',' | 'collation' | 'empty' | 'return' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 26183                      (: 'attribute' 'let' :)
              or $state[$p:lk] = 30535) then                (: 'attribute' 'let' :)
          let $state := p:lookahead3W(70, $input, $state)   (: S^WS | '$' | '(.' | '{' :)
          return $state
        else if ($state[$p:lk] = 19527                      (: 'attribute' 'castable' :)
              or $state[$p:lk] = 19783                      (: 'attribute' 'treat' :)
              or $state[$p:lk] = 38983) then                (: 'attribute' 'treat' :)
          let $state := p:lookahead3W(83, $input, $state)   (: S^WS | '(.' | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 17223                      (: 'attribute' 'div' :)
              or $state[$p:lk] = 22599                      (: 'attribute' 'else' :)
              or $state[$p:lk] = 23623                      (: 'attribute' 'eq' :)
              or $state[$p:lk] = 24647                      (: 'attribute' 'except' :)
              or $state[$p:lk] = 25159                      (: 'attribute' 'ge' :)
              or $state[$p:lk] = 26695                      (: 'attribute' 'gt' :)
              or $state[$p:lk] = 27207                      (: 'attribute' 'idiv' :)
              or $state[$p:lk] = 27463                      (: 'attribute' 'intersect' :)
              or $state[$p:lk] = 28999                      (: 'attribute' 'is' :)
              or $state[$p:lk] = 29255                      (: 'attribute' 'le' :)
              or $state[$p:lk] = 30023                      (: 'attribute' 'lt' :)
              or $state[$p:lk] = 30791                      (: 'attribute' 'mod' :)
              or $state[$p:lk] = 31047                      (: 'attribute' 'ne' :)
              or $state[$p:lk] = 31815                      (: 'attribute' 'or' :)
              or $state[$p:lk] = 33351                      (: 'attribute' 'return' :)
              or $state[$p:lk] = 35655                      (: 'attribute' 'satisfies' :)
              or $state[$p:lk] = 35911                      (: 'attribute' 'to' :)
              or $state[$p:lk] = 38727                      (: 'attribute' 'union' :)
              or $state[$p:lk] = 39495                      (: 'attribute' 'where' :)
              or $state[$p:lk] = 40775) then                (: 'attribute' 'where' :)
          let $state := p:lookahead3W(172, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'element' :)
      let $state := p:lookahead2W(174, $input, $state)      (: S^WS | QName^Token | EOF | '!=' | '(' | '(.' | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] = 19291) then                     (: 'element' 'case' :)
          let $state := p:lookahead3W(166, $input, $state)  (: S^WS | QName^Token | '$' | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 20315) then                (: 'element' 'collation' :)
          let $state := p:lookahead3W(66, $input, $state)   (: StringLiteral | S^WS | '(.' | '{' :)
          return $state
        else if ($state[$p:lk] = 21595) then                (: 'element' 'default' :)
          let $state := p:lookahead3W(100, $input, $state)  (: S^WS | '$' | '(.' | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 23899) then                (: 'element' 'empty' :)
          let $state := p:lookahead3W(108, $input, $state)  (: S^WS | '(.' | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 28763) then                (: 'element' 'instance' :)
          let $state := p:lookahead3W(94, $input, $state)   (: S^WS | '(.' | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 33627) then                (: 'element' 'order' :)
          let $state := p:lookahead3W(85, $input, $state)   (: S^WS | '(.' | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 37467) then                (: 'element' 'stable' :)
          let $state := p:lookahead3W(95, $input, $state)   (: S^WS | '(.' | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 17755                      (: 'element' 'descending' :)
              or $state[$p:lk] = 22363) then                (: 'element' 'descending' :)
          let $state := p:lookahead3W(114, $input, $state)  (: S^WS | '(.' | ',' | 'collation' | 'empty' | 'return' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 26203                      (: 'element' 'let' :)
              or $state[$p:lk] = 30555) then                (: 'element' 'let' :)
          let $state := p:lookahead3W(70, $input, $state)   (: S^WS | '$' | '(.' | '{' :)
          return $state
        else if ($state[$p:lk] = 19547                      (: 'element' 'castable' :)
              or $state[$p:lk] = 19803                      (: 'element' 'treat' :)
              or $state[$p:lk] = 39003) then                (: 'element' 'treat' :)
          let $state := p:lookahead3W(83, $input, $state)   (: S^WS | '(.' | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 17243                      (: 'element' 'div' :)
              or $state[$p:lk] = 22619                      (: 'element' 'else' :)
              or $state[$p:lk] = 23643                      (: 'element' 'eq' :)
              or $state[$p:lk] = 24667                      (: 'element' 'except' :)
              or $state[$p:lk] = 25179                      (: 'element' 'ge' :)
              or $state[$p:lk] = 26715                      (: 'element' 'gt' :)
              or $state[$p:lk] = 27227                      (: 'element' 'idiv' :)
              or $state[$p:lk] = 27483                      (: 'element' 'intersect' :)
              or $state[$p:lk] = 29019                      (: 'element' 'is' :)
              or $state[$p:lk] = 29275                      (: 'element' 'le' :)
              or $state[$p:lk] = 30043                      (: 'element' 'lt' :)
              or $state[$p:lk] = 30811                      (: 'element' 'mod' :)
              or $state[$p:lk] = 31067                      (: 'element' 'ne' :)
              or $state[$p:lk] = 31835                      (: 'element' 'or' :)
              or $state[$p:lk] = 33371                      (: 'element' 'return' :)
              or $state[$p:lk] = 35675                      (: 'element' 'satisfies' :)
              or $state[$p:lk] = 35931                      (: 'element' 'to' :)
              or $state[$p:lk] = 38747                      (: 'element' 'union' :)
              or $state[$p:lk] = 39515                      (: 'element' 'where' :)
              or $state[$p:lk] = 40795) then                (: 'element' 'where' :)
          let $state := p:lookahead3W(172, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'processing-instruction' :)
      let $state := p:lookahead2W(155, $input, $state)      (: S^WS | NCName^Token | EOF | '!=' | '(' | '(.' | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] = 19338) then                     (: 'processing-instruction' 'case' :)
          let $state := p:lookahead3W(166, $input, $state)  (: S^WS | QName^Token | '$' | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 20362) then                (: 'processing-instruction' 'collation' :)
          let $state := p:lookahead3W(66, $input, $state)   (: StringLiteral | S^WS | '(.' | '{' :)
          return $state
        else if ($state[$p:lk] = 21642) then                (: 'processing-instruction' 'default' :)
          let $state := p:lookahead3W(100, $input, $state)  (: S^WS | '$' | '(.' | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 23946) then                (: 'processing-instruction' 'empty' :)
          let $state := p:lookahead3W(108, $input, $state)  (: S^WS | '(.' | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 28810) then                (: 'processing-instruction' 'instance' :)
          let $state := p:lookahead3W(94, $input, $state)   (: S^WS | '(.' | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 33674) then                (: 'processing-instruction' 'order' :)
          let $state := p:lookahead3W(85, $input, $state)   (: S^WS | '(.' | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 37514) then                (: 'processing-instruction' 'stable' :)
          let $state := p:lookahead3W(95, $input, $state)   (: S^WS | '(.' | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 17802                      (: 'processing-instruction' 'descending' :)
              or $state[$p:lk] = 22410) then                (: 'processing-instruction' 'descending' :)
          let $state := p:lookahead3W(114, $input, $state)  (: S^WS | '(.' | ',' | 'collation' | 'empty' | 'return' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 26250                      (: 'processing-instruction' 'let' :)
              or $state[$p:lk] = 30602) then                (: 'processing-instruction' 'let' :)
          let $state := p:lookahead3W(70, $input, $state)   (: S^WS | '$' | '(.' | '{' :)
          return $state
        else if ($state[$p:lk] = 19594                      (: 'processing-instruction' 'castable' :)
              or $state[$p:lk] = 19850                      (: 'processing-instruction' 'treat' :)
              or $state[$p:lk] = 39050) then                (: 'processing-instruction' 'treat' :)
          let $state := p:lookahead3W(83, $input, $state)   (: S^WS | '(.' | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 17290                      (: 'processing-instruction' 'div' :)
              or $state[$p:lk] = 22666                      (: 'processing-instruction' 'else' :)
              or $state[$p:lk] = 23690                      (: 'processing-instruction' 'eq' :)
              or $state[$p:lk] = 24714                      (: 'processing-instruction' 'except' :)
              or $state[$p:lk] = 25226                      (: 'processing-instruction' 'ge' :)
              or $state[$p:lk] = 26762                      (: 'processing-instruction' 'gt' :)
              or $state[$p:lk] = 27274                      (: 'processing-instruction' 'idiv' :)
              or $state[$p:lk] = 27530                      (: 'processing-instruction' 'intersect' :)
              or $state[$p:lk] = 29066                      (: 'processing-instruction' 'is' :)
              or $state[$p:lk] = 29322                      (: 'processing-instruction' 'le' :)
              or $state[$p:lk] = 30090                      (: 'processing-instruction' 'lt' :)
              or $state[$p:lk] = 30858                      (: 'processing-instruction' 'mod' :)
              or $state[$p:lk] = 31114                      (: 'processing-instruction' 'ne' :)
              or $state[$p:lk] = 31882                      (: 'processing-instruction' 'or' :)
              or $state[$p:lk] = 33418                      (: 'processing-instruction' 'return' :)
              or $state[$p:lk] = 35722                      (: 'processing-instruction' 'satisfies' :)
              or $state[$p:lk] = 35978                      (: 'processing-instruction' 'to' :)
              or $state[$p:lk] = 38794                      (: 'processing-instruction' 'union' :)
              or $state[$p:lk] = 39562                      (: 'processing-instruction' 'where' :)
              or $state[$p:lk] = 40842) then                (: 'processing-instruction' 'where' :)
          let $state := p:lookahead3W(172, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 80                             (: 'document' :)
          or $state[$p:l1] = 89                             (: 'ordered' :)
          or $state[$p:l1] = 132                            (: 'text' :)
          or $state[$p:l1] = 149                            (: 'unordered' :)
          or $state[$p:l1] = 155) then                      (: 'unordered' :)
      let $state := p:lookahead2W(153, $input, $state)      (: S^WS | EOF | '!=' | '(' | '(.' | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 65                             (: 'ancestor-or-self' :)
          or $state[$p:l1] = 66                             (: 'child' :)
          or $state[$p:l1] = 78                             (: 'descendant' :)
          or $state[$p:l1] = 85                             (: 'descendant-or-self' :)
          or $state[$p:l1] = 86                             (: 'following' :)
          or $state[$p:l1] = 100                            (: 'following-sibling' :)
          or $state[$p:l1] = 101                            (: 'parent' :)
          or $state[$p:l1] = 134                            (: 'preceding' :)
          or $state[$p:l1] = 135                            (: 'preceding-sibling' :)
          or $state[$p:l1] = 136                            (: 'self' :)
          or $state[$p:l1] = 144) then                      (: 'self' :)
      let $state := p:lookahead2W(152, $input, $state)      (: S^WS | EOF | '!=' | '(' | '(.' | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 17                             (: 'and' :)
          or $state[$p:l1] = 67                             (: 'ascending' :)
          or $state[$p:l1] = 69                             (: 'case' :)
          or $state[$p:l1] = 75                             (: 'cast' :)
          or $state[$p:l1] = 76                             (: 'castable' :)
          or $state[$p:l1] = 77                             (: 'collation' :)
          or $state[$p:l1] = 79                             (: 'declare' :)
          or $state[$p:l1] = 83                             (: 'default' :)
          or $state[$p:l1] = 84                             (: 'descending' :)
          or $state[$p:l1] = 87                             (: 'div' :)
          or $state[$p:l1] = 88                             (: 'else' :)
          or $state[$p:l1] = 92                             (: 'empty' :)
          or $state[$p:l1] = 93                             (: 'eq' :)
          or $state[$p:l1] = 96                             (: 'every' :)
          or $state[$p:l1] = 97                             (: 'except' :)
          or $state[$p:l1] = 98                             (: 'for' :)
          or $state[$p:l1] = 102                            (: 'ge' :)
          or $state[$p:l1] = 104                            (: 'gt' :)
          or $state[$p:l1] = 106                            (: 'idiv' :)
          or $state[$p:l1] = 107                            (: 'import' :)
          or $state[$p:l1] = 109                            (: 'instance' :)
          or $state[$p:l1] = 112                            (: 'intersect' :)
          or $state[$p:l1] = 113                            (: 'is' :)
          or $state[$p:l1] = 114                            (: 'le' :)
          or $state[$p:l1] = 117                            (: 'let' :)
          or $state[$p:l1] = 119                            (: 'lt' :)
          or $state[$p:l1] = 120                            (: 'mod' :)
          or $state[$p:l1] = 121                            (: 'module' :)
          or $state[$p:l1] = 122                            (: 'ne' :)
          or $state[$p:l1] = 124                            (: 'or' :)
          or $state[$p:l1] = 130                            (: 'order' :)
          or $state[$p:l1] = 131                            (: 'return' :)
          or $state[$p:l1] = 139                            (: 'satisfies' :)
          or $state[$p:l1] = 140                            (: 'some' :)
          or $state[$p:l1] = 145                            (: 'stable' :)
          or $state[$p:l1] = 146                            (: 'to' :)
          or $state[$p:l1] = 151                            (: 'treat' :)
          or $state[$p:l1] = 152                            (: 'union' :)
          or $state[$p:l1] = 154                            (: 'validate' :)
          or $state[$p:l1] = 156                            (: 'where' :)
          or $state[$p:l1] = 159                            (: 'xquery' :)
          or $state[$p:l1] = 160) then                      (: 'xquery' :)
      let $state := p:lookahead2W(149, $input, $state)      (: S^WS | EOF | '!=' | '(' | '(.' | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 3                                   (: IntegerLiteral :)
     or $state[$p:lk] = 4                                   (: DecimalLiteral :)
     or $state[$p:lk] = 5                                   (: DoubleLiteral :)
     or $state[$p:lk] = 6                                   (: StringLiteral :)
     or $state[$p:lk] = 28                                  (: '$' :)
     or $state[$p:lk] = 30                                  (: '(' :)
     or $state[$p:lk] = 41                                  (: '.' :)
     or $state[$p:lk] = 50                                  (: '<' :)
     or $state[$p:lk] = 51                                  (: '<!--' :)
     or $state[$p:lk] = 55                                  (: '<?' :)
     or $state[$p:lk] = 4234                                (: 'processing-instruction' NCName^Token :)
     or $state[$p:lk] = 4423                                (: 'attribute' QName^Token :)
     or $state[$p:lk] = 4443                                (: 'element' QName^Token :)
     or $state[$p:lk] = 7697                                (: QName^Token '(' :)
     or $state[$p:lk] = 7745                                (: 'ancestor' '(' :)
     or $state[$p:lk] = 7746                                (: 'ancestor-or-self' '(' :)
     or $state[$p:lk] = 7747                                (: 'and' '(' :)
     or $state[$p:lk] = 7749                                (: 'ascending' '(' :)
     or $state[$p:lk] = 7755                                (: 'case' '(' :)
     or $state[$p:lk] = 7756                                (: 'cast' '(' :)
     or $state[$p:lk] = 7757                                (: 'castable' '(' :)
     or $state[$p:lk] = 7758                                (: 'child' '(' :)
     or $state[$p:lk] = 7759                                (: 'collation' '(' :)
     or $state[$p:lk] = 7763                                (: 'declare' '(' :)
     or $state[$p:lk] = 7764                                (: 'default' '(' :)
     or $state[$p:lk] = 7765                                (: 'descendant' '(' :)
     or $state[$p:lk] = 7766                                (: 'descendant-or-self' '(' :)
     or $state[$p:lk] = 7767                                (: 'descending' '(' :)
     or $state[$p:lk] = 7768                                (: 'div' '(' :)
     or $state[$p:lk] = 7769                                (: 'document' '(' :)
     or $state[$p:lk] = 7772                                (: 'else' '(' :)
     or $state[$p:lk] = 7773                                (: 'empty' '(' :)
     or $state[$p:lk] = 7776                                (: 'eq' '(' :)
     or $state[$p:lk] = 7777                                (: 'every' '(' :)
     or $state[$p:lk] = 7778                                (: 'except' '(' :)
     or $state[$p:lk] = 7780                                (: 'following' '(' :)
     or $state[$p:lk] = 7781                                (: 'following-sibling' '(' :)
     or $state[$p:lk] = 7782                                (: 'for' '(' :)
     or $state[$p:lk] = 7784                                (: 'ge' '(' :)
     or $state[$p:lk] = 7786                                (: 'gt' '(' :)
     or $state[$p:lk] = 7787                                (: 'idiv' '(' :)
     or $state[$p:lk] = 7789                                (: 'import' '(' :)
     or $state[$p:lk] = 7792                                (: 'instance' '(' :)
     or $state[$p:lk] = 7793                                (: 'intersect' '(' :)
     or $state[$p:lk] = 7794                                (: 'is' '(' :)
     or $state[$p:lk] = 7797                                (: 'le' '(' :)
     or $state[$p:lk] = 7799                                (: 'let' '(' :)
     or $state[$p:lk] = 7800                                (: 'lt' '(' :)
     or $state[$p:lk] = 7801                                (: 'mod' '(' :)
     or $state[$p:lk] = 7802                                (: 'module' '(' :)
     or $state[$p:lk] = 7804                                (: 'ne' '(' :)
     or $state[$p:lk] = 7810                                (: 'or' '(' :)
     or $state[$p:lk] = 7811                                (: 'order' '(' :)
     or $state[$p:lk] = 7812                                (: 'ordered' '(' :)
     or $state[$p:lk] = 7814                                (: 'parent' '(' :)
     or $state[$p:lk] = 7815                                (: 'preceding' '(' :)
     or $state[$p:lk] = 7816                                (: 'preceding-sibling' '(' :)
     or $state[$p:lk] = 7819                                (: 'return' '(' :)
     or $state[$p:lk] = 7820                                (: 'satisfies' '(' :)
     or $state[$p:lk] = 7824                                (: 'self' '(' :)
     or $state[$p:lk] = 7825                                (: 'some' '(' :)
     or $state[$p:lk] = 7826                                (: 'stable' '(' :)
     or $state[$p:lk] = 7831                                (: 'to' '(' :)
     or $state[$p:lk] = 7832                                (: 'treat' '(' :)
     or $state[$p:lk] = 7834                                (: 'union' '(' :)
     or $state[$p:lk] = 7835                                (: 'unordered' '(' :)
     or $state[$p:lk] = 7836                                (: 'validate' '(' :)
     or $state[$p:lk] = 7839                                (: 'where' '(' :)
     or $state[$p:lk] = 7840                                (: 'xquery' '(' :)
     or $state[$p:lk] = 16711                               (: 'attribute' 'ancestor' :)
     or $state[$p:lk] = 16731                               (: 'element' 'ancestor' :)
     or $state[$p:lk] = 16967                               (: 'attribute' 'ancestor-or-self' :)
     or $state[$p:lk] = 16987                               (: 'element' 'ancestor-or-self' :)
     or $state[$p:lk] = 18247                               (: 'attribute' 'attribute' :)
     or $state[$p:lk] = 18267                               (: 'element' 'attribute' :)
     or $state[$p:lk] = 20039                               (: 'attribute' 'child' :)
     or $state[$p:lk] = 20059                               (: 'element' 'child' :)
     or $state[$p:lk] = 20551                               (: 'attribute' 'comment' :)
     or $state[$p:lk] = 20571                               (: 'element' 'comment' :)
     or $state[$p:lk] = 21319                               (: 'attribute' 'declare' :)
     or $state[$p:lk] = 21339                               (: 'element' 'declare' :)
     or $state[$p:lk] = 21831                               (: 'attribute' 'descendant' :)
     or $state[$p:lk] = 21851                               (: 'element' 'descendant' :)
     or $state[$p:lk] = 22087                               (: 'attribute' 'descendant-or-self' :)
     or $state[$p:lk] = 22107                               (: 'element' 'descendant-or-self' :)
     or $state[$p:lk] = 22855                               (: 'attribute' 'document' :)
     or $state[$p:lk] = 22875                               (: 'element' 'document' :)
     or $state[$p:lk] = 23111                               (: 'attribute' 'document-node' :)
     or $state[$p:lk] = 23131                               (: 'element' 'document-node' :)
     or $state[$p:lk] = 23367                               (: 'attribute' 'element' :)
     or $state[$p:lk] = 23387                               (: 'element' 'element' :)
     or $state[$p:lk] = 24135                               (: 'attribute' 'empty-sequence' :)
     or $state[$p:lk] = 24155                               (: 'element' 'empty-sequence' :)
     or $state[$p:lk] = 24903                               (: 'attribute' 'every' :)
     or $state[$p:lk] = 24923                               (: 'element' 'every' :)
     or $state[$p:lk] = 25671                               (: 'attribute' 'following' :)
     or $state[$p:lk] = 25691                               (: 'element' 'following' :)
     or $state[$p:lk] = 25927                               (: 'attribute' 'following-sibling' :)
     or $state[$p:lk] = 25947                               (: 'element' 'following-sibling' :)
     or $state[$p:lk] = 27719                               (: 'attribute' 'if' :)
     or $state[$p:lk] = 27739                               (: 'element' 'if' :)
     or $state[$p:lk] = 27975                               (: 'attribute' 'import' :)
     or $state[$p:lk] = 27995                               (: 'element' 'import' :)
     or $state[$p:lk] = 29511                               (: 'attribute' 'item' :)
     or $state[$p:lk] = 29531                               (: 'element' 'item' :)
     or $state[$p:lk] = 31303                               (: 'attribute' 'module' :)
     or $state[$p:lk] = 31323                               (: 'element' 'module' :)
     or $state[$p:lk] = 32583                               (: 'attribute' 'node' :)
     or $state[$p:lk] = 32603                               (: 'element' 'node' :)
     or $state[$p:lk] = 33863                               (: 'attribute' 'ordered' :)
     or $state[$p:lk] = 33883                               (: 'element' 'ordered' :)
     or $state[$p:lk] = 34375                               (: 'attribute' 'parent' :)
     or $state[$p:lk] = 34395                               (: 'element' 'parent' :)
     or $state[$p:lk] = 34631                               (: 'attribute' 'preceding' :)
     or $state[$p:lk] = 34651                               (: 'element' 'preceding' :)
     or $state[$p:lk] = 34887                               (: 'attribute' 'preceding-sibling' :)
     or $state[$p:lk] = 34907                               (: 'element' 'preceding-sibling' :)
     or $state[$p:lk] = 35399                               (: 'attribute' 'processing-instruction' :)
     or $state[$p:lk] = 35419                               (: 'element' 'processing-instruction' :)
     or $state[$p:lk] = 36423                               (: 'attribute' 'schema-attribute' :)
     or $state[$p:lk] = 36443                               (: 'element' 'schema-attribute' :)
     or $state[$p:lk] = 36679                               (: 'attribute' 'schema-element' :)
     or $state[$p:lk] = 36699                               (: 'element' 'schema-element' :)
     or $state[$p:lk] = 36935                               (: 'attribute' 'self' :)
     or $state[$p:lk] = 36955                               (: 'element' 'self' :)
     or $state[$p:lk] = 37191                               (: 'attribute' 'some' :)
     or $state[$p:lk] = 37211                               (: 'element' 'some' :)
     or $state[$p:lk] = 38215                               (: 'attribute' 'text' :)
     or $state[$p:lk] = 38235                               (: 'element' 'text' :)
     or $state[$p:lk] = 39239                               (: 'attribute' 'typeswitch' :)
     or $state[$p:lk] = 39259                               (: 'element' 'typeswitch' :)
     or $state[$p:lk] = 39751                               (: 'attribute' 'unordered' :)
     or $state[$p:lk] = 39771                               (: 'element' 'unordered' :)
     or $state[$p:lk] = 40007                               (: 'attribute' 'validate' :)
     or $state[$p:lk] = 40027                               (: 'element' 'validate' :)
     or $state[$p:lk] = 41031                               (: 'attribute' 'xquery' :)
     or $state[$p:lk] = 41051                               (: 'element' 'xquery' :)
     or $state[$p:lk] = 41287                               (: 'attribute' '{' :)
     or $state[$p:lk] = 41296                               (: 'comment' '{' :)
     or $state[$p:lk] = 41305                               (: 'document' '{' :)
     or $state[$p:lk] = 41307                               (: 'element' '{' :)
     or $state[$p:lk] = 41348                               (: 'ordered' '{' :)
     or $state[$p:lk] = 41354                               (: 'processing-instruction' '{' :)
     or $state[$p:lk] = 41365                               (: 'text' '{' :)
     or $state[$p:lk] = 41371                               (: 'unordered' '{' :)
     or $state[$p:lk] = 10568519                            (: 'attribute' 'and' '{' :)
     or $state[$p:lk] = 10568539                            (: 'element' 'and' '{' :)
     or $state[$p:lk] = 10568586                            (: 'processing-instruction' 'and' '{' :)
     or $state[$p:lk] = 10569031                            (: 'attribute' 'ascending' '{' :)
     or $state[$p:lk] = 10569051                            (: 'element' 'ascending' '{' :)
     or $state[$p:lk] = 10569098                            (: 'processing-instruction' 'ascending' '{' :)
     or $state[$p:lk] = 10570567                            (: 'attribute' 'case' '{' :)
     or $state[$p:lk] = 10570587                            (: 'element' 'case' '{' :)
     or $state[$p:lk] = 10570634                            (: 'processing-instruction' 'case' '{' :)
     or $state[$p:lk] = 10570823                            (: 'attribute' 'cast' '{' :)
     or $state[$p:lk] = 10570843                            (: 'element' 'cast' '{' :)
     or $state[$p:lk] = 10570890                            (: 'processing-instruction' 'cast' '{' :)
     or $state[$p:lk] = 10571079                            (: 'attribute' 'castable' '{' :)
     or $state[$p:lk] = 10571099                            (: 'element' 'castable' '{' :)
     or $state[$p:lk] = 10571146                            (: 'processing-instruction' 'castable' '{' :)
     or $state[$p:lk] = 10571591                            (: 'attribute' 'collation' '{' :)
     or $state[$p:lk] = 10571611                            (: 'element' 'collation' '{' :)
     or $state[$p:lk] = 10571658                            (: 'processing-instruction' 'collation' '{' :)
     or $state[$p:lk] = 10572871                            (: 'attribute' 'default' '{' :)
     or $state[$p:lk] = 10572891                            (: 'element' 'default' '{' :)
     or $state[$p:lk] = 10572938                            (: 'processing-instruction' 'default' '{' :)
     or $state[$p:lk] = 10573639                            (: 'attribute' 'descending' '{' :)
     or $state[$p:lk] = 10573659                            (: 'element' 'descending' '{' :)
     or $state[$p:lk] = 10573706                            (: 'processing-instruction' 'descending' '{' :)
     or $state[$p:lk] = 10573895                            (: 'attribute' 'div' '{' :)
     or $state[$p:lk] = 10573915                            (: 'element' 'div' '{' :)
     or $state[$p:lk] = 10573962                            (: 'processing-instruction' 'div' '{' :)
     or $state[$p:lk] = 10574919                            (: 'attribute' 'else' '{' :)
     or $state[$p:lk] = 10574939                            (: 'element' 'else' '{' :)
     or $state[$p:lk] = 10574986                            (: 'processing-instruction' 'else' '{' :)
     or $state[$p:lk] = 10575175                            (: 'attribute' 'empty' '{' :)
     or $state[$p:lk] = 10575195                            (: 'element' 'empty' '{' :)
     or $state[$p:lk] = 10575242                            (: 'processing-instruction' 'empty' '{' :)
     or $state[$p:lk] = 10575943                            (: 'attribute' 'eq' '{' :)
     or $state[$p:lk] = 10575963                            (: 'element' 'eq' '{' :)
     or $state[$p:lk] = 10576010                            (: 'processing-instruction' 'eq' '{' :)
     or $state[$p:lk] = 10576455                            (: 'attribute' 'except' '{' :)
     or $state[$p:lk] = 10576475                            (: 'element' 'except' '{' :)
     or $state[$p:lk] = 10576522                            (: 'processing-instruction' 'except' '{' :)
     or $state[$p:lk] = 10577479                            (: 'attribute' 'for' '{' :)
     or $state[$p:lk] = 10577499                            (: 'element' 'for' '{' :)
     or $state[$p:lk] = 10577546                            (: 'processing-instruction' 'for' '{' :)
     or $state[$p:lk] = 10577991                            (: 'attribute' 'ge' '{' :)
     or $state[$p:lk] = 10578011                            (: 'element' 'ge' '{' :)
     or $state[$p:lk] = 10578058                            (: 'processing-instruction' 'ge' '{' :)
     or $state[$p:lk] = 10578503                            (: 'attribute' 'gt' '{' :)
     or $state[$p:lk] = 10578523                            (: 'element' 'gt' '{' :)
     or $state[$p:lk] = 10578570                            (: 'processing-instruction' 'gt' '{' :)
     or $state[$p:lk] = 10578759                            (: 'attribute' 'idiv' '{' :)
     or $state[$p:lk] = 10578779                            (: 'element' 'idiv' '{' :)
     or $state[$p:lk] = 10578826                            (: 'processing-instruction' 'idiv' '{' :)
     or $state[$p:lk] = 10580039                            (: 'attribute' 'instance' '{' :)
     or $state[$p:lk] = 10580059                            (: 'element' 'instance' '{' :)
     or $state[$p:lk] = 10580106                            (: 'processing-instruction' 'instance' '{' :)
     or $state[$p:lk] = 10580295                            (: 'attribute' 'intersect' '{' :)
     or $state[$p:lk] = 10580315                            (: 'element' 'intersect' '{' :)
     or $state[$p:lk] = 10580362                            (: 'processing-instruction' 'intersect' '{' :)
     or $state[$p:lk] = 10580551                            (: 'attribute' 'is' '{' :)
     or $state[$p:lk] = 10580571                            (: 'element' 'is' '{' :)
     or $state[$p:lk] = 10580618                            (: 'processing-instruction' 'is' '{' :)
     or $state[$p:lk] = 10581319                            (: 'attribute' 'le' '{' :)
     or $state[$p:lk] = 10581339                            (: 'element' 'le' '{' :)
     or $state[$p:lk] = 10581386                            (: 'processing-instruction' 'le' '{' :)
     or $state[$p:lk] = 10581831                            (: 'attribute' 'let' '{' :)
     or $state[$p:lk] = 10581851                            (: 'element' 'let' '{' :)
     or $state[$p:lk] = 10581898                            (: 'processing-instruction' 'let' '{' :)
     or $state[$p:lk] = 10582087                            (: 'attribute' 'lt' '{' :)
     or $state[$p:lk] = 10582107                            (: 'element' 'lt' '{' :)
     or $state[$p:lk] = 10582154                            (: 'processing-instruction' 'lt' '{' :)
     or $state[$p:lk] = 10582343                            (: 'attribute' 'mod' '{' :)
     or $state[$p:lk] = 10582363                            (: 'element' 'mod' '{' :)
     or $state[$p:lk] = 10582410                            (: 'processing-instruction' 'mod' '{' :)
     or $state[$p:lk] = 10583111                            (: 'attribute' 'ne' '{' :)
     or $state[$p:lk] = 10583131                            (: 'element' 'ne' '{' :)
     or $state[$p:lk] = 10583178                            (: 'processing-instruction' 'ne' '{' :)
     or $state[$p:lk] = 10584647                            (: 'attribute' 'or' '{' :)
     or $state[$p:lk] = 10584667                            (: 'element' 'or' '{' :)
     or $state[$p:lk] = 10584714                            (: 'processing-instruction' 'or' '{' :)
     or $state[$p:lk] = 10584903                            (: 'attribute' 'order' '{' :)
     or $state[$p:lk] = 10584923                            (: 'element' 'order' '{' :)
     or $state[$p:lk] = 10584970                            (: 'processing-instruction' 'order' '{' :)
     or $state[$p:lk] = 10586951                            (: 'attribute' 'return' '{' :)
     or $state[$p:lk] = 10586971                            (: 'element' 'return' '{' :)
     or $state[$p:lk] = 10587018                            (: 'processing-instruction' 'return' '{' :)
     or $state[$p:lk] = 10587207                            (: 'attribute' 'satisfies' '{' :)
     or $state[$p:lk] = 10587227                            (: 'element' 'satisfies' '{' :)
     or $state[$p:lk] = 10587274                            (: 'processing-instruction' 'satisfies' '{' :)
     or $state[$p:lk] = 10588743                            (: 'attribute' 'stable' '{' :)
     or $state[$p:lk] = 10588763                            (: 'element' 'stable' '{' :)
     or $state[$p:lk] = 10588810                            (: 'processing-instruction' 'stable' '{' :)
     or $state[$p:lk] = 10590023                            (: 'attribute' 'to' '{' :)
     or $state[$p:lk] = 10590043                            (: 'element' 'to' '{' :)
     or $state[$p:lk] = 10590090                            (: 'processing-instruction' 'to' '{' :)
     or $state[$p:lk] = 10590279                            (: 'attribute' 'treat' '{' :)
     or $state[$p:lk] = 10590299                            (: 'element' 'treat' '{' :)
     or $state[$p:lk] = 10590346                            (: 'processing-instruction' 'treat' '{' :)
     or $state[$p:lk] = 10590791                            (: 'attribute' 'union' '{' :)
     or $state[$p:lk] = 10590811                            (: 'element' 'union' '{' :)
     or $state[$p:lk] = 10590858                            (: 'processing-instruction' 'union' '{' :)
     or $state[$p:lk] = 10592071                            (: 'attribute' 'where' '{' :)
     or $state[$p:lk] = 10592091                            (: 'element' 'where' '{' :)
     or $state[$p:lk] = 10592138) then                      (: 'processing-instruction' 'where' '{' :)
      let $state := p:parse-FilterExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AxisStep($input, $state)
      return $state
  return p:reduce($state, "StepExpr", $count)
};

(:~
 : Parse the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(145, $input, $state)        (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 43                               (: '/' :)
      and $state[$p:l1] != 44) then                         (: '//' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 43) then                      (: '/' :)
            let $state := p:shift(43, $input, $state)       (: '/' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(44, $input, $state)       (: '//' :)
            return $state
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-StepExpr($input, $state)
        return p:parse-RelativePathExpr-1($input, $state)
};

(:~
 : Parse RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-StepExpr($input, $state)
  let $state := p:parse-RelativePathExpr-1($input, $state)
  return p:reduce($state, "RelativePathExpr", $count)
};

(:~
 : Parse PathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 43) then                            (: '/' :)
      let $state := p:shift(43, $input, $state)             (: '/' :)
      let $state := p:lookahead1W(176, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | EOF |
                                                               '!=' | '$' | '(' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               '.' | '..' | ';' | '<' | '<!--' | '<<' | '<=' | '<?' |
                                                               '=' | '>' | '>=' | '>>' | '@' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '|' | '}' :)
      let $state :=
        if ($state[$p:l1] = 24                              (: EOF :)
         or $state[$p:l1] = 25                              (: '!=' :)
         or $state[$p:l1] = 33                              (: ')' :)
         or $state[$p:l1] = 34                              (: '*' :)
         or $state[$p:l1] = 36                              (: '+' :)
         or $state[$p:l1] = 38                              (: ',' :)
         or $state[$p:l1] = 39                              (: '-' :)
         or $state[$p:l1] = 49                              (: ';' :)
         or $state[$p:l1] = 53                              (: '<<' :)
         or $state[$p:l1] = 54                              (: '<=' :)
         or $state[$p:l1] = 56                              (: '=' :)
         or $state[$p:l1] = 57                              (: '>' :)
         or $state[$p:l1] = 58                              (: '>=' :)
         or $state[$p:l1] = 59                              (: '>>' :)
         or $state[$p:l1] = 64                              (: ']' :)
         or $state[$p:l1] = 163                             (: '|' :)
         or $state[$p:l1] = 164) then                       (: '}' :)
          $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 44) then                       (: '//' :)
      let $state := p:shift(44, $input, $state)             (: '//' :)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
  return p:reduce($state, "PathExpr", $count)
};

(:~
 : Parse ValidationMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidationMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 116) then                           (: 'lax' :)
      let $state := p:shift(116, $input, $state)            (: 'lax' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(147, $input, $state)            (: 'strict' :)
      return $state
  return p:reduce($state, "ValidationMode", $count)
};

(:~
 : Parse ValidateExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidateExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(156, $input, $state)                (: 'validate' :)
  let $state := p:lookahead1W(109, $input, $state)          (: S^WS | '(.' | 'lax' | 'strict' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 161) then                     (: '{' :)
      let $state := p:parse-ValidationMode($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(161, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(62, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(164, $input, $state)                (: '}' :)
  return p:reduce($state, "ValidateExpr", $count)
};

(:~
 : Parse ValueExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 156) then                           (: 'validate' :)
      let $state := p:lookahead2W(157, $input, $state)      (: S^WS | EOF | '!=' | '(' | '(.' | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'lax' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'strict' | 'to' | 'treat' | 'union' |
                                                               'where' | '{' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 29852                               (: 'validate' 'lax' :)
     or $state[$p:lk] = 37788                               (: 'validate' 'strict' :)
     or $state[$p:lk] = 41372) then                         (: 'validate' '{' :)
      let $state := p:parse-ValidateExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 31) then                       (: '(#' :)
      let $state := p:parse-ExtensionExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-PathExpr($input, $state)
      return $state
  return p:reduce($state, "ValueExpr", $count)
};

(:~
 : Parse the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(169, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
    return
      if ($state[$p:l1] != 36                               (: '+' :)
      and $state[$p:l1] != 39) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 39) then                      (: '-' :)
            let $state := p:shift(39, $input, $state)       (: '-' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(36, $input, $state)       (: '+' :)
            return $state
        return p:parse-UnaryExpr-1($input, $state)
};

(:~
 : Parse UnaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-UnaryExpr-1($input, $state)
  let $state := p:parse-ValueExpr($input, $state)
  return p:reduce($state, "UnaryExpr", $count)
};

(:~
 : Parse CastExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-UnaryExpr($input, $state)
  let $state := p:lookahead1W(144, $input, $state)          (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76) then                       (: 'cast' :)
      let $state := p:shift(76, $input, $state)             (: 'cast' :)
      let $state := p:lookahead1W(37, $input, $state)       (: S^WS | '(.' | 'as' :)
      let $state := p:shift(68, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "CastExpr", $count)
};

(:~
 : Parse CastableExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-CastExpr($input, $state)
  let $state := p:lookahead1W(142, $input, $state)          (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'castable' | 'collation' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'castable' :)
      let $state := p:shift(77, $input, $state)             (: 'castable' :)
      let $state := p:lookahead1W(37, $input, $state)       (: S^WS | '(.' | 'as' :)
      let $state := p:shift(68, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "CastableExpr", $count)
};

(:~
 : Parse TreatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-CastableExpr($input, $state)
  let $state := p:lookahead1W(141, $input, $state)          (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 152) then                      (: 'treat' :)
      let $state := p:shift(152, $input, $state)            (: 'treat' :)
      let $state := p:lookahead1W(37, $input, $state)       (: S^WS | '(.' | 'as' :)
      let $state := p:shift(68, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "TreatExpr", $count)
};

(:~
 : Parse InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-TreatExpr($input, $state)
  let $state := p:lookahead1W(140, $input, $state)          (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 112) then                      (: 'instance' :)
      let $state := p:shift(112, $input, $state)            (: 'instance' :)
      let $state := p:lookahead1W(52, $input, $state)       (: S^WS | '(.' | 'of' :)
      let $state := p:shift(128, $input, $state)            (: 'of' :)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "InstanceofExpr", $count)
};

(:~
 : Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(139, $input, $state)        (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 98                               (: 'except' :)
      and $state[$p:l1] != 113) then                        (: 'intersect' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 113) then                     (: 'intersect' :)
            let $state := p:shift(113, $input, $state)      (: 'intersect' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(98, $input, $state)       (: 'except' :)
            return $state
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-InstanceofExpr($input, $state)
        return p:parse-IntersectExceptExpr-1($input, $state)
};

(:~
 : Parse IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-InstanceofExpr($input, $state)
  let $state := p:parse-IntersectExceptExpr-1($input, $state)
  return p:reduce($state, "IntersectExceptExpr", $count)
};

(:~
 : Parse the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(137, $input, $state)        (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 154                              (: 'union' :)
      and $state[$p:l1] != 163) then                        (: '|' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 154) then                     (: 'union' :)
            let $state := p:shift(154, $input, $state)      (: 'union' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(163, $input, $state)      (: '|' :)
            return $state
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-IntersectExceptExpr($input, $state)
        return p:parse-UnionExpr-1($input, $state)
};

(:~
 : Parse UnionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-IntersectExceptExpr($input, $state)
  let $state := p:parse-UnionExpr-1($input, $state)
  return p:reduce($state, "UnionExpr", $count)
};

(:~
 : Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(136, $input, $state)        (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'where' | '}' :)
    return
      if ($state[$p:l1] != 34                               (: '*' :)
      and $state[$p:l1] != 88                               (: 'div' :)
      and $state[$p:l1] != 107                              (: 'idiv' :)
      and $state[$p:l1] != 121) then                        (: 'mod' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 34) then                      (: '*' :)
            let $state := p:shift(34, $input, $state)       (: '*' :)
            return $state
          else if ($state[$p:l1] = 88) then                 (: 'div' :)
            let $state := p:shift(88, $input, $state)       (: 'div' :)
            return $state
          else if ($state[$p:l1] = 107) then                (: 'idiv' :)
            let $state := p:shift(107, $input, $state)      (: 'idiv' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(121, $input, $state)      (: 'mod' :)
            return $state
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-UnionExpr($input, $state)
        return p:parse-MultiplicativeExpr-1($input, $state)
};

(:~
 : Parse MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-UnionExpr($input, $state)
  let $state := p:parse-MultiplicativeExpr-1($input, $state)
  return p:reduce($state, "MultiplicativeExpr", $count)
};

(:~
 : Parse the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(134, $input, $state)        (: S^WS | EOF | '!=' | '(.' | ')' | '+' | ',' | '-' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'eq' | 'for' | 'ge' |
                                                               'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'where' | '}' :)
    return
      if ($state[$p:l1] != 36                               (: '+' :)
      and $state[$p:l1] != 39) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 36) then                      (: '+' :)
            let $state := p:shift(36, $input, $state)       (: '+' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(39, $input, $state)       (: '-' :)
            return $state
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-MultiplicativeExpr($input, $state)
        return p:parse-AdditiveExpr-1($input, $state)
};

(:~
 : Parse AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-MultiplicativeExpr($input, $state)
  let $state := p:parse-AdditiveExpr-1($input, $state)
  return p:reduce($state, "AdditiveExpr", $count)
};

(:~
 : Parse RangeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-AdditiveExpr($input, $state)
  let $state := p:lookahead1W(130, $input, $state)          (: S^WS | EOF | '!=' | '(.' | ')' | ',' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'eq' | 'for' | 'ge' |
                                                               'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'where' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 151) then                      (: 'to' :)
      let $state := p:shift(151, $input, $state)            (: 'to' :)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-AdditiveExpr($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "RangeExpr", $count)
};

(:~
 : Parse ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-RangeExpr($input, $state)
  let $state := p:lookahead1W(129, $input, $state)          (: S^WS | EOF | '!=' | '(.' | ')' | ',' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'eq' | 'for' | 'ge' |
                                                               'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'where' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 25                             (: '!=' :)
          or $state[$p:l1] = 50                             (: '<' :)
          or $state[$p:l1] = 53                             (: '<<' :)
          or $state[$p:l1] = 54                             (: '<=' :)
          or $state[$p:l1] = 56                             (: '=' :)
          or $state[$p:l1] = 57                             (: '>' :)
          or $state[$p:l1] = 58                             (: '>=' :)
          or $state[$p:l1] = 59                             (: '>>' :)
          or $state[$p:l1] = 96                             (: 'eq' :)
          or $state[$p:l1] = 104                            (: 'ge' :)
          or $state[$p:l1] = 106                            (: 'gt' :)
          or $state[$p:l1] = 114                            (: 'is' :)
          or $state[$p:l1] = 117                            (: 'le' :)
          or $state[$p:l1] = 120                            (: 'lt' :)
          or $state[$p:l1] = 124) then                      (: 'ne' :)
      let $state :=
        if ($state[$p:l1] = 96                              (: 'eq' :)
         or $state[$p:l1] = 104                             (: 'ge' :)
         or $state[$p:l1] = 106                             (: 'gt' :)
         or $state[$p:l1] = 117                             (: 'le' :)
         or $state[$p:l1] = 120                             (: 'lt' :)
         or $state[$p:l1] = 124) then                       (: 'ne' :)
          let $state := p:parse-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 53                         (: '<<' :)
              or $state[$p:l1] = 59                         (: '>>' :)
              or $state[$p:l1] = 114) then                  (: 'is' :)
          let $state := p:parse-NodeComp($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-RangeExpr($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "ComparisonExpr", $count)
};

(:~
 : Parse the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(124, $input, $state)        (: S^WS | EOF | '(.' | ')' | ',' | ';' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'for' | 'let' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'where' |
                                                               '}' :)
    return
      if ($state[$p:l1] != 67) then                         (: 'and' :)
        $state
      else
        let $state := p:shift(67, $input, $state)           (: 'and' :)
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-ComparisonExpr($input, $state)
        return p:parse-AndExpr-1($input, $state)
};

(:~
 : Parse AndExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ComparisonExpr($input, $state)
  let $state := p:parse-AndExpr-1($input, $state)
  return p:reduce($state, "AndExpr", $count)
};

(:~
 : Parse the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(123, $input, $state)        (: S^WS | EOF | '(.' | ')' | ',' | ';' | ']' | 'ascending' |
                                                               'case' | 'collation' | 'default' | 'descending' |
                                                               'else' | 'empty' | 'for' | 'let' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'where' | '}' :)
    return
      if ($state[$p:l1] != 130) then                        (: 'or' :)
        $state
      else
        let $state := p:shift(130, $input, $state)          (: 'or' :)
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-AndExpr($input, $state)
        return p:parse-OrExpr-1($input, $state)
};

(:~
 : Parse OrExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-AndExpr($input, $state)
  let $state := p:parse-OrExpr-1($input, $state)
  return p:reduce($state, "OrExpr", $count)
};

(:~
 : Parse IfExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(108, $input, $state)                (: 'if' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | '(.' | 'then' :)
  let $state := p:shift(150, $input, $state)                (: 'then' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | '(.' | 'else' :)
  let $state := p:shift(92, $input, $state)                 (: 'else' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "IfExpr", $count)
};

(:~
 : Parse CaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(11, $input, $state)            (: 'case' :)
  let $state := p:shift(75, $input, $state)                 (: 'case' :)
  let $state := p:lookahead1W(164, $input, $state)          (: S^WS | QName^Token | '$' | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28) then                       (: '$' :)
      let $state := p:shift(28, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(162, $input, $state)      (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(37, $input, $state)       (: S^WS | '(.' | 'as' :)
      let $state := p:shift(68, $input, $state)             (: 'as' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-SequenceType($input, $state)
  let $state := p:lookahead1W(56, $input, $state)           (: S^WS | '(.' | 'return' :)
  let $state := p:shift(139, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "CaseClause", $count)
};

(:~
 : Parse the 1st loop of production Expr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(113, $input, $state)        (: S^WS | EOF | '(.' | ')' | ',' | ']' | '}' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:shift(38, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-Expr-1($input, $state)
};

(:~
 : Parse Expr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-Expr-1($input, $state)
  return p:reduce($state, "Expr", $count)
};

(:~
 : Parse the 1st loop of production TypeswitchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(22, $input, $state)         (: EPSILON | S^WS | '(.' :)
    let $state := p:parse-CaseClause($input, $state)
    let $state := p:lookahead1W(86, $input, $state)         (: S^WS | '(.' | 'case' | 'default' :)
    return
      if ($state[$p:l1] != 75) then                         (: 'case' :)
        $state
      else
        p:parse-TypeswitchExpr-1($input, $state)
};

(:~
 : Parse TypeswitchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(153, $input, $state)                (: 'typeswitch' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-TypeswitchExpr-1($input, $state)
  let $state := p:shift(84, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(69, $input, $state)           (: S^WS | '$' | '(.' | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28) then                       (: '$' :)
      let $state := p:shift(28, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(162, $input, $state)      (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state := p:parse-VarName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(56, $input, $state)           (: S^WS | '(.' | 'return' :)
  let $state := p:shift(139, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "TypeswitchExpr", $count)
};

(:~
 : Parse the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(77, $input, $state)         (: S^WS | '(.' | ',' | 'satisfies' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:shift(38, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(28, $input, $state)     (: S^WS | '$' | '(.' :)
        let $state := p:shift(28, $input, $state)           (: '$' :)
        let $state := p:lookahead1W(162, $input, $state)    (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
        let $state := p:parse-VarName($input, $state)
        let $state := p:lookahead1W(82, $input, $state)     (: S^WS | '(.' | 'as' | 'in' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 68) then                 (: 'as' :)
            let $state := p:parse-TypeDeclaration($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(49, $input, $state)     (: S^WS | '(.' | 'in' :)
        let $state := p:shift(110, $input, $state)          (: 'in' :)
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-QuantifiedExpr-1($input, $state)
};

(:~
 : Parse QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 145) then                           (: 'some' :)
      let $state := p:shift(145, $input, $state)            (: 'some' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(97, $input, $state)             (: 'every' :)
      return $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '$' | '(.' :)
  let $state := p:shift(28, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(162, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(82, $input, $state)           (: S^WS | '(.' | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 68) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | '(.' | 'in' :)
  let $state := p:shift(110, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-QuantifiedExpr-1($input, $state)
  let $state := p:shift(140, $input, $state)                (: 'satisfies' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "QuantifiedExpr", $count)
};

(:~
 : Parse OrderModifier.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderModifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(117, $input, $state)          (: S^WS | '(.' | ',' | 'ascending' | 'collation' |
                                                               'descending' | 'empty' | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69                             (: 'ascending' :)
          or $state[$p:l1] = 87) then                       (: 'descending' :)
      let $state :=
        if ($state[$p:l1] = 69) then                        (: 'ascending' :)
          let $state := p:shift(69, $input, $state)         (: 'ascending' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(87, $input, $state)         (: 'descending' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(111, $input, $state)          (: S^WS | '(.' | ',' | 'collation' | 'empty' | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 93) then                       (: 'empty' :)
      let $state := p:shift(93, $input, $state)             (: 'empty' :)
      let $state := p:lookahead1W(90, $input, $state)       (: S^WS | '(.' | 'greatest' | 'least' :)
      let $state :=
        if ($state[$p:l1] = 105) then                       (: 'greatest' :)
          let $state := p:shift(105, $input, $state)        (: 'greatest' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(118, $input, $state)        (: 'least' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(103, $input, $state)          (: S^WS | '(.' | ',' | 'collation' | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 79) then                       (: 'collation' :)
      let $state := p:shift(79, $input, $state)             (: 'collation' :)
      let $state := p:lookahead1W(24, $input, $state)       (: StringLiteral | S^WS | '(.' :)
      let $state := p:parse-URILiteral($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "OrderModifier", $count)
};

(:~
 : Parse OrderSpec.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-OrderModifier($input, $state)
  return p:reduce($state, "OrderSpec", $count)
};

(:~
 : Parse the 1st loop of production OrderSpecList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(76, $input, $state)         (: S^WS | '(.' | ',' | 'return' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:shift(38, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-OrderSpec($input, $state)
        return p:parse-OrderSpecList-1($input, $state)
};

(:~
 : Parse OrderSpecList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-OrderSpec($input, $state)
  let $state := p:parse-OrderSpecList-1($input, $state)
  return p:reduce($state, "OrderSpecList", $count)
};

(:~
 : Parse OrderByClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderByClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 131) then                           (: 'order' :)
      let $state := p:shift(131, $input, $state)            (: 'order' :)
      let $state := p:lookahead1W(40, $input, $state)       (: S^WS | '(.' | 'by' :)
      let $state := p:shift(74, $input, $state)             (: 'by' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(146, $input, $state)            (: 'stable' :)
      let $state := p:lookahead1W(54, $input, $state)       (: S^WS | '(.' | 'order' :)
      let $state := p:shift(131, $input, $state)            (: 'order' :)
      let $state := p:lookahead1W(40, $input, $state)       (: S^WS | '(.' | 'by' :)
      let $state := p:shift(74, $input, $state)             (: 'by' :)
      return $state
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-OrderSpecList($input, $state)
  return p:reduce($state, "OrderByClause", $count)
};

(:~
 : Parse WhereClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WhereClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(159, $input, $state)                (: 'where' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "WhereClause", $count)
};

(:~
 : Parse the 1st loop of production LetClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(120, $input, $state)        (: S^WS | '(.' | ',' | 'for' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:shift(38, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(28, $input, $state)     (: S^WS | '$' | '(.' :)
        let $state := p:shift(28, $input, $state)           (: '$' :)
        let $state := p:lookahead1W(162, $input, $state)    (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
        let $state := p:parse-VarName($input, $state)
        let $state := p:lookahead1W(78, $input, $state)     (: S^WS | '(.' | ':=' | 'as' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 68) then                 (: 'as' :)
            let $state := p:parse-TypeDeclaration($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(33, $input, $state)     (: S^WS | '(.' | ':=' :)
        let $state := p:shift(48, $input, $state)           (: ':=' :)
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-LetClause-1($input, $state)
};

(:~
 : Parse LetClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(119, $input, $state)                (: 'let' :)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '$' | '(.' :)
  let $state := p:shift(28, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(162, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(78, $input, $state)           (: S^WS | '(.' | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 68) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(33, $input, $state)           (: S^WS | '(.' | ':=' :)
  let $state := p:shift(48, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-LetClause-1($input, $state)
  return p:reduce($state, "LetClause", $count)
};

(:~
 : Parse PositionalVar.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PositionalVar($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(70, $input, $state)                 (: 'at' :)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '$' | '(.' :)
  let $state := p:shift(28, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(162, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  return p:reduce($state, "PositionalVar", $count)
};

(:~
 : Parse VarName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "VarName", $count)
};

(:~
 : Parse the 1st loop of production ForClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(120, $input, $state)        (: S^WS | '(.' | ',' | 'for' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:shift(38, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(28, $input, $state)     (: S^WS | '$' | '(.' :)
        let $state := p:shift(28, $input, $state)           (: '$' :)
        let $state := p:lookahead1W(162, $input, $state)    (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
        let $state := p:parse-VarName($input, $state)
        let $state := p:lookahead1W(105, $input, $state)    (: S^WS | '(.' | 'as' | 'at' | 'in' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 68) then                 (: 'as' :)
            let $state := p:parse-TypeDeclaration($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(84, $input, $state)     (: S^WS | '(.' | 'at' | 'in' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 70) then                 (: 'at' :)
            let $state := p:parse-PositionalVar($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(49, $input, $state)     (: S^WS | '(.' | 'in' :)
        let $state := p:shift(110, $input, $state)          (: 'in' :)
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-ForClause-1($input, $state)
};

(:~
 : Parse ForClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(102, $input, $state)                (: 'for' :)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '$' | '(.' :)
  let $state := p:shift(28, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(162, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(105, $input, $state)          (: S^WS | '(.' | 'as' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 68) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(84, $input, $state)           (: S^WS | '(.' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'at' :)
      let $state := p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | '(.' | 'in' :)
  let $state := p:shift(110, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-ForClause-1($input, $state)
  return p:reduce($state, "ForClause", $count)
};

(:~
 : Parse the 1st loop of production FLWORExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] = 102) then                         (: 'for' :)
        let $state := p:parse-ForClause($input, $state)
        return $state
      else if ($state[$p:error]) then
        $state
      else
        let $state := p:parse-LetClause($input, $state)
        return $state
    let $state := p:lookahead1W(119, $input, $state)        (: S^WS | '(.' | 'for' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
    return
      if ($state[$p:l1] != 102                              (: 'for' :)
      and $state[$p:l1] != 119) then                        (: 'let' :)
        $state
      else
        p:parse-FLWORExpr-1($input, $state)
};

(:~
 : Parse FLWORExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-FLWORExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 159) then                      (: 'where' :)
      let $state := p:parse-WhereClause($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(110, $input, $state)          (: S^WS | '(.' | 'order' | 'return' | 'stable' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 139) then                     (: 'return' :)
      let $state := p:parse-OrderByClause($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(56, $input, $state)           (: S^WS | '(.' | 'return' :)
  let $state := p:shift(139, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "FLWORExpr", $count)
};

(:~
 : Parse ExprSingle.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(169, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 108                                 (: 'typeswitch' :)
     or $state[$p:l1] = 153) then                           (: 'typeswitch' :)
      let $state := p:lookahead2W(149, $input, $state)      (: S^WS | EOF | '!=' | '(' | '(.' | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 97                             (: 'for' :)
          or $state[$p:l1] = 102                            (: 'let' :)
          or $state[$p:l1] = 119                            (: 'some' :)
          or $state[$p:l1] = 145) then                      (: 'some' :)
      let $state := p:lookahead2W(151, $input, $state)      (: S^WS | EOF | '!=' | '$' | '(' | '(.' | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 7270                                (: 'for' '$' :)
     or $state[$p:lk] = 7287) then                          (: 'let' '$' :)
      let $state := p:parse-FLWORExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 7265                           (: 'every' '$' :)
          or $state[$p:lk] = 7313) then                     (: 'some' '$' :)
      let $state := p:parse-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 7833) then                     (: 'typeswitch' '(' :)
      let $state := p:parse-TypeswitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 7788) then                     (: 'if' '(' :)
      let $state := p:parse-IfExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-OrExpr($input, $state)
      return $state
  return p:reduce($state, "ExprSingle", $count)
};

(:~
 : Parse OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 60) then                            (: '?' :)
      let $state := p:shift(60, $input, $state)             (: '?' :)
      return $state
    else if ($state[$p:l1] = 35) then                       (: '*' :)
      let $state := p:shift(35, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(37, $input, $state)             (: '+' :)
      return $state
  return p:reduce($state, "OccurrenceIndicator", $count)
};

(:~
 : Parse AtomicType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AtomicType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "AtomicType", $count)
};

(:~
 : Parse AnyKindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(127, $input, $state)                (: 'node' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  return p:reduce($state, "AnyKindTest", $count)
};

(:~
 : Parse TextTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(149, $input, $state)                (: 'text' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  return p:reduce($state, "TextTest", $count)
};

(:~
 : Parse CommentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(80, $input, $state)                 (: 'comment' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  return p:reduce($state, "CommentTest", $count)
};

(:~
 : Parse PITest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PITest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(138, $input, $state)                (: 'processing-instruction' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(128, $input, $state)          (: StringLiteral | S^WS | NCName^Token | '(.' | ')' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 6) then                         (: StringLiteral :)
          let $state := p:shift(6, $input, $state)          (: StringLiteral :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  return p:reduce($state, "PITest", $count)
};

(:~
 : Parse AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-AttributeName($input, $state)
  return p:reduce($state, "AttributeDeclaration", $count)
};

(:~
 : Parse SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(142, $input, $state)                (: 'schema-attribute' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(162, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  return p:reduce($state, "SchemaAttributeTest", $count)
};

(:~
 : Parse AttributeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "AttributeName", $count)
};

(:~
 : Parse AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 34) then                            (: '*' :)
      let $state := p:shift(34, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AttributeName($input, $state)
      return $state
  return p:reduce($state, "AttribNameOrWildcard", $count)
};

(:~
 : Parse AttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(71, $input, $state)                 (: 'attribute' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(167, $input, $state)          (: S^WS | QName^Token | '(.' | ')' | '*' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: ')' :)
      let $state := p:parse-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(73, $input, $state)       (: S^WS | '(.' | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38) then                   (: ',' :)
          let $state := p:shift(38, $input, $state)         (: ',' :)
          let $state := p:lookahead1W(162, $input, $state)  (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
          let $state := p:parse-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  return p:reduce($state, "AttributeTest", $count)
};

(:~
 : Parse ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ElementName($input, $state)
  return p:reduce($state, "ElementDeclaration", $count)
};

(:~
 : Parse SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(143, $input, $state)                (: 'schema-element' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(162, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  return p:reduce($state, "SchemaElementTest", $count)
};

(:~
 : Parse TypeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "TypeName", $count)
};

(:~
 : Parse ElementName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "ElementName", $count)
};

(:~
 : Parse ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 34) then                            (: '*' :)
      let $state := p:shift(34, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ElementName($input, $state)
      return $state
  return p:reduce($state, "ElementNameOrWildcard", $count)
};

(:~
 : Parse ElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(91, $input, $state)                 (: 'element' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(167, $input, $state)          (: S^WS | QName^Token | '(.' | ')' | '*' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: ')' :)
      let $state := p:parse-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(73, $input, $state)       (: S^WS | '(.' | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38) then                   (: ',' :)
          let $state := p:shift(38, $input, $state)         (: ',' :)
          let $state := p:lookahead1W(162, $input, $state)  (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
          let $state := p:parse-TypeName($input, $state)
          let $state := p:lookahead1W(74, $input, $state)   (: S^WS | '(.' | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 60) then               (: '?' :)
              let $state := p:shift(60, $input, $state)     (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  return p:reduce($state, "ElementTest", $count)
};

(:~
 : Parse DocumentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(90, $input, $state)                 (: 'document-node' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(102, $input, $state)          (: S^WS | '(.' | ')' | 'element' | 'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 91) then                        (: 'element' :)
          let $state := p:parse-ElementTest($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  return p:reduce($state, "DocumentTest", $count)
};

(:~
 : Parse KindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 90) then                            (: 'document-node' :)
      let $state := p:parse-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'element' :)
      let $state := p:parse-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'attribute' :)
      let $state := p:parse-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'schema-element' :)
      let $state := p:parse-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'schema-attribute' :)
      let $state := p:parse-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'processing-instruction' :)
      let $state := p:parse-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'comment' :)
      let $state := p:parse-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'text' :)
      let $state := p:parse-TextTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AnyKindTest($input, $state)
      return $state
  return p:reduce($state, "KindTest", $count)
};

(:~
 : Parse ItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 71                                  (: 'comment' :)
     or $state[$p:l1] = 80                                  (: 'document-node' :)
     or $state[$p:l1] = 90                                  (: 'element' :)
     or $state[$p:l1] = 91                                  (: 'item' :)
     or $state[$p:l1] = 115                                 (: 'node' :)
     or $state[$p:l1] = 127                                 (: 'processing-instruction' :)
     or $state[$p:l1] = 138                                 (: 'schema-attribute' :)
     or $state[$p:l1] = 142                                 (: 'schema-element' :)
     or $state[$p:l1] = 143                                 (: 'text' :)
     or $state[$p:l1] = 149) then                           (: 'text' :)
      let $state := p:lookahead2W(156, $input, $state)      (: S^WS | EOF | '!=' | '(' | '(.' | ')' | '*' | '*' | '+' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'and' | 'ascending' |
                                                               'at' | 'case' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'external' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'union' | 'where' | '{' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 7751                                (: 'attribute' '(' :)
     or $state[$p:lk] = 7760                                (: 'comment' '(' :)
     or $state[$p:lk] = 7770                                (: 'document-node' '(' :)
     or $state[$p:lk] = 7771                                (: 'element' '(' :)
     or $state[$p:lk] = 7807                                (: 'node' '(' :)
     or $state[$p:lk] = 7818                                (: 'processing-instruction' '(' :)
     or $state[$p:lk] = 7822                                (: 'schema-attribute' '(' :)
     or $state[$p:lk] = 7823                                (: 'schema-element' '(' :)
     or $state[$p:lk] = 7829) then                          (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 7795) then                     (: 'item' '(' :)
      let $state := p:shift(115, $input, $state)            (: 'item' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | '(' | '(.' :)
      let $state := p:shift(30, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | '(.' | ')' :)
      let $state := p:shift(33, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AtomicType($input, $state)
      return $state
  return p:reduce($state, "ItemType", $count)
};

(:~
 : Parse SequenceType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(158, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 94) then                            (: 'empty-sequence' :)
      let $state := p:lookahead2W(156, $input, $state)      (: S^WS | EOF | '!=' | '(' | '(.' | ')' | '*' | '*' | '+' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'and' | 'ascending' |
                                                               'at' | 'case' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'external' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'union' | 'where' | '{' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 7774) then                          (: 'empty-sequence' '(' :)
      let $state := p:shift(94, $input, $state)             (: 'empty-sequence' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | '(' | '(.' :)
      let $state := p:shift(30, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | '(.' | ')' :)
      let $state := p:shift(33, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ItemType($input, $state)
      let $state := p:lookahead1W(154, $input, $state)      (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '*' | '+' | '+' |
                                                               ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'and' | 'ascending' | 'at' |
                                                               'case' | 'collation' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'eq' | 'except' | 'external' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'in' | 'instance' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'union' | 'where' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 35                         (: '*' :)
              or $state[$p:l1] = 37                         (: '+' :)
              or $state[$p:l1] = 60) then                   (: '?' :)
          let $state := p:parse-OccurrenceIndicator($input, $state)
          return $state
        else
          $state
      return $state
  return p:reduce($state, "SequenceType", $count)
};

(:~
 : Parse TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(68, $input, $state)                 (: 'as' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-SequenceType($input, $state)
  return p:reduce($state, "TypeDeclaration", $count)
};

(:~
 : Parse FunctionName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(146, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'else' | 'empty' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'module' | 'ne' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'return' |
                                                               'satisfies' | 'self' | 'some' | 'stable' | 'to' |
                                                               'treat' | 'union' | 'unordered' | 'validate' | 'where' |
                                                               'xquery' :)
  let $state :=
    if ($state[$p:l1] = 65) then                            (: 'ancestor' :)
      let $state := p:shift(65, $input, $state)             (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 66) then                       (: 'ancestor-or-self' :)
      let $state := p:shift(66, $input, $state)             (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 67) then                       (: 'and' :)
      let $state := p:shift(67, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 69) then                       (: 'ascending' :)
      let $state := p:shift(69, $input, $state)             (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'case' :)
      let $state := p:shift(75, $input, $state)             (: 'case' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'cast' :)
      let $state := p:shift(76, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'castable' :)
      let $state := p:shift(77, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'child' :)
      let $state := p:shift(78, $input, $state)             (: 'child' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'collation' :)
      let $state := p:shift(79, $input, $state)             (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'declare' :)
      let $state := p:shift(83, $input, $state)             (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'default' :)
      let $state := p:shift(84, $input, $state)             (: 'default' :)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'descendant' :)
      let $state := p:shift(85, $input, $state)             (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'descendant-or-self' :)
      let $state := p:shift(86, $input, $state)             (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'descending' :)
      let $state := p:shift(87, $input, $state)             (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'div' :)
      let $state := p:shift(88, $input, $state)             (: 'div' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'document' :)
      let $state := p:shift(89, $input, $state)             (: 'document' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'else' :)
      let $state := p:shift(92, $input, $state)             (: 'else' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'empty' :)
      let $state := p:shift(93, $input, $state)             (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'eq' :)
      let $state := p:shift(96, $input, $state)             (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'every' :)
      let $state := p:shift(97, $input, $state)             (: 'every' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'except' :)
      let $state := p:shift(98, $input, $state)             (: 'except' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'following' :)
      let $state := p:shift(100, $input, $state)            (: 'following' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'following-sibling' :)
      let $state := p:shift(101, $input, $state)            (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'for' :)
      let $state := p:shift(102, $input, $state)            (: 'for' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'ge' :)
      let $state := p:shift(104, $input, $state)            (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'gt' :)
      let $state := p:shift(106, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'idiv' :)
      let $state := p:shift(107, $input, $state)            (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 109) then                      (: 'import' :)
      let $state := p:shift(109, $input, $state)            (: 'import' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'instance' :)
      let $state := p:shift(112, $input, $state)            (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'intersect' :)
      let $state := p:shift(113, $input, $state)            (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 114) then                      (: 'is' :)
      let $state := p:shift(114, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'le' :)
      let $state := p:shift(117, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'let' :)
      let $state := p:shift(119, $input, $state)            (: 'let' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'lt' :)
      let $state := p:shift(120, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'mod' :)
      let $state := p:shift(121, $input, $state)            (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'module' :)
      let $state := p:shift(122, $input, $state)            (: 'module' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'ne' :)
      let $state := p:shift(124, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'or' :)
      let $state := p:shift(130, $input, $state)            (: 'or' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'order' :)
      let $state := p:shift(131, $input, $state)            (: 'order' :)
      return $state
    else if ($state[$p:l1] = 132) then                      (: 'ordered' :)
      let $state := p:shift(132, $input, $state)            (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'parent' :)
      let $state := p:shift(134, $input, $state)            (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'preceding' :)
      let $state := p:shift(135, $input, $state)            (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'preceding-sibling' :)
      let $state := p:shift(136, $input, $state)            (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'return' :)
      let $state := p:shift(139, $input, $state)            (: 'return' :)
      return $state
    else if ($state[$p:l1] = 140) then                      (: 'satisfies' :)
      let $state := p:shift(140, $input, $state)            (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'self' :)
      let $state := p:shift(144, $input, $state)            (: 'self' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'some' :)
      let $state := p:shift(145, $input, $state)            (: 'some' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'stable' :)
      let $state := p:shift(146, $input, $state)            (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'to' :)
      let $state := p:shift(151, $input, $state)            (: 'to' :)
      return $state
    else if ($state[$p:l1] = 152) then                      (: 'treat' :)
      let $state := p:shift(152, $input, $state)            (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'union' :)
      let $state := p:shift(154, $input, $state)            (: 'union' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'unordered' :)
      let $state := p:shift(155, $input, $state)            (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 156) then                      (: 'validate' :)
      let $state := p:shift(156, $input, $state)            (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'where' :)
      let $state := p:shift(159, $input, $state)            (: 'where' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'xquery' :)
      let $state := p:shift(160, $input, $state)            (: 'xquery' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(17, $input, $state)             (: QName^Token :)
      return $state
  return p:reduce($state, "FunctionName", $count)
};

(:~
 : Parse QName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(158, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 71) then                            (: 'attribute' :)
      let $state := p:shift(71, $input, $state)             (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'comment' :)
      let $state := p:shift(80, $input, $state)             (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'document-node' :)
      let $state := p:shift(90, $input, $state)             (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'element' :)
      let $state := p:shift(91, $input, $state)             (: 'element' :)
      return $state
    else if ($state[$p:l1] = 94) then                       (: 'empty-sequence' :)
      let $state := p:shift(94, $input, $state)             (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'if' :)
      let $state := p:shift(108, $input, $state)            (: 'if' :)
      return $state
    else if ($state[$p:l1] = 115) then                      (: 'item' :)
      let $state := p:shift(115, $input, $state)            (: 'item' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'node' :)
      let $state := p:shift(127, $input, $state)            (: 'node' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'processing-instruction' :)
      let $state := p:shift(138, $input, $state)            (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'schema-attribute' :)
      let $state := p:shift(142, $input, $state)            (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'schema-element' :)
      let $state := p:shift(143, $input, $state)            (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'text' :)
      let $state := p:shift(149, $input, $state)            (: 'text' :)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'typeswitch' :)
      let $state := p:shift(153, $input, $state)            (: 'typeswitch' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionName($input, $state)
      return $state
  return p:reduce($state, "QName", $count)
};

(:~
 : Parse VarDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(83, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WS | '(.' | 'variable' :)
  let $state := p:shift(157, $input, $state)                (: 'variable' :)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '$' | '(.' :)
  let $state := p:shift(28, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(162, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:lookahead1W(104, $input, $state)          (: S^WS | '(.' | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 68) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | '(.' | ':=' | 'external' :)
  let $state :=
    if ($state[$p:l1] = 48) then                            (: ':=' :)
      let $state := p:shift(48, $input, $state)             (: ':=' :)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-ExprSingle($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(99, $input, $state)             (: 'external' :)
      return $state
  return p:reduce($state, "VarDecl", $count)
};

(:~
 : Parse the 1st loop of production ModuleImport (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleImport-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(75, $input, $state)         (: S^WS | '(.' | ',' | ';' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:shift(38, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(24, $input, $state)     (: StringLiteral | S^WS | '(.' :)
        let $state := p:parse-URILiteral($input, $state)
        return p:parse-ModuleImport-1($input, $state)
};

(:~
 : Parse ModuleImport.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleImport($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(109, $input, $state)                (: 'import' :)
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | '(.' | 'module' :)
  let $state := p:shift(122, $input, $state)                (: 'module' :)
  let $state := p:lookahead1W(65, $input, $state)           (: StringLiteral | S^WS | '(.' | 'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 123) then                      (: 'namespace' :)
      let $state := p:shift(123, $input, $state)            (: 'namespace' :)
      let $state := p:lookahead1W(126, $input, $state)      (: S^WS | NCName^Token | '(.' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' :)
      let $state := p:parse-NCName($input, $state)
      let $state := p:lookahead1W(35, $input, $state)       (: S^WS | '(.' | '=' :)
      let $state := p:shift(56, $input, $state)             (: '=' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(24, $input, $state)           (: StringLiteral | S^WS | '(.' :)
  let $state := p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | '(.' | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'at' :)
      let $state := p:shift(70, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(24, $input, $state)       (: StringLiteral | S^WS | '(.' :)
      let $state := p:parse-URILiteral($input, $state)
      let $state := p:parse-ModuleImport-1($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "ModuleImport", $count)
};

(:~
 : Parse SchemaPrefix.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaPrefix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 123) then                           (: 'namespace' :)
      let $state := p:shift(123, $input, $state)            (: 'namespace' :)
      let $state := p:lookahead1W(126, $input, $state)      (: S^WS | NCName^Token | '(.' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' :)
      let $state := p:parse-NCName($input, $state)
      let $state := p:lookahead1W(35, $input, $state)       (: S^WS | '(.' | '=' :)
      let $state := p:shift(56, $input, $state)             (: '=' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(84, $input, $state)             (: 'default' :)
      let $state := p:lookahead1W(45, $input, $state)       (: S^WS | '(.' | 'element' :)
      let $state := p:shift(91, $input, $state)             (: 'element' :)
      let $state := p:lookahead1W(51, $input, $state)       (: S^WS | '(.' | 'namespace' :)
      let $state := p:shift(123, $input, $state)            (: 'namespace' :)
      return $state
  return p:reduce($state, "SchemaPrefix", $count)
};

(:~
 : Parse the 1st loop of production SchemaImport (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaImport-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(75, $input, $state)         (: S^WS | '(.' | ',' | ';' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:shift(38, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(24, $input, $state)     (: StringLiteral | S^WS | '(.' :)
        let $state := p:parse-URILiteral($input, $state)
        return p:parse-SchemaImport-1($input, $state)
};

(:~
 : Parse SchemaImport.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaImport($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(109, $input, $state)                (: 'import' :)
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | '(.' | 'schema' :)
  let $state := p:shift(141, $input, $state)                (: 'schema' :)
  let $state := p:lookahead1W(98, $input, $state)           (: StringLiteral | S^WS | '(.' | 'default' | 'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 6) then                       (: StringLiteral :)
      let $state := p:parse-SchemaPrefix($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(24, $input, $state)           (: StringLiteral | S^WS | '(.' :)
  let $state := p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | '(.' | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'at' :)
      let $state := p:shift(70, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(24, $input, $state)       (: StringLiteral | S^WS | '(.' :)
      let $state := p:parse-URILiteral($input, $state)
      let $state := p:parse-SchemaImport-1($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "SchemaImport", $count)
};

(:~
 : Parse Import.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Import($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 109) then                           (: 'import' :)
      let $state := p:lookahead2W(92, $input, $state)       (: S^WS | '(.' | 'module' | 'schema' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 36205) then                         (: 'import' 'schema' :)
      let $state := p:parse-SchemaImport($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ModuleImport($input, $state)
      return $state
  return p:reduce($state, "Import", $count)
};

(:~
 : Parse NamespaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(83, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(51, $input, $state)           (: S^WS | '(.' | 'namespace' :)
  let $state := p:shift(123, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(126, $input, $state)          (: S^WS | NCName^Token | '(.' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' :)
  let $state := p:parse-NCName($input, $state)
  let $state := p:lookahead1W(35, $input, $state)           (: S^WS | '(.' | '=' :)
  let $state := p:shift(56, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(24, $input, $state)           (: StringLiteral | S^WS | '(.' :)
  let $state := p:parse-URILiteral($input, $state)
  return p:reduce($state, "NamespaceDecl", $count)
};

(:~
 : Parse InheritMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InheritMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(20, $input, $state)            (: 'inherit' | 'no-inherit' :)
  let $state :=
    if ($state[$p:l1] = 111) then                           (: 'inherit' :)
      let $state := p:shift(111, $input, $state)            (: 'inherit' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(125, $input, $state)            (: 'no-inherit' :)
      return $state
  return p:reduce($state, "InheritMode", $count)
};

(:~
 : Parse PreserveMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PreserveMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(21, $input, $state)            (: 'no-preserve' | 'preserve' :)
  let $state :=
    if ($state[$p:l1] = 137) then                           (: 'preserve' :)
      let $state := p:shift(137, $input, $state)            (: 'preserve' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(126, $input, $state)            (: 'no-preserve' :)
      return $state
  return p:reduce($state, "PreserveMode", $count)
};

(:~
 : Parse CopyNamespacesDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CopyNamespacesDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(83, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | '(.' | 'copy-namespaces' :)
  let $state := p:shift(82, $input, $state)                 (: 'copy-namespaces' :)
  let $state := p:lookahead1W(93, $input, $state)           (: S^WS | '(.' | 'no-preserve' | 'preserve' :)
  let $state := p:parse-PreserveMode($input, $state)
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | '(.' | ',' :)
  let $state := p:shift(38, $input, $state)                 (: ',' :)
  let $state := p:lookahead1W(91, $input, $state)           (: S^WS | '(.' | 'inherit' | 'no-inherit' :)
  let $state := p:parse-InheritMode($input, $state)
  return p:reduce($state, "CopyNamespacesDecl", $count)
};

(:~
 : Parse EmptyOrderDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EmptyOrderDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(83, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | '(.' | 'default' :)
  let $state := p:shift(84, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(54, $input, $state)           (: S^WS | '(.' | 'order' :)
  let $state := p:shift(131, $input, $state)                (: 'order' :)
  let $state := p:lookahead1W(47, $input, $state)           (: S^WS | '(.' | 'empty' :)
  let $state := p:shift(93, $input, $state)                 (: 'empty' :)
  let $state := p:lookahead1W(90, $input, $state)           (: S^WS | '(.' | 'greatest' | 'least' :)
  let $state :=
    if ($state[$p:l1] = 105) then                           (: 'greatest' :)
      let $state := p:shift(105, $input, $state)            (: 'greatest' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(118, $input, $state)            (: 'least' :)
      return $state
  return p:reduce($state, "EmptyOrderDecl", $count)
};

(:~
 : Parse OrderingModeDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderingModeDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(83, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(55, $input, $state)           (: S^WS | '(.' | 'ordering' :)
  let $state := p:shift(133, $input, $state)                (: 'ordering' :)
  let $state := p:lookahead1W(96, $input, $state)           (: S^WS | '(.' | 'ordered' | 'unordered' :)
  let $state :=
    if ($state[$p:l1] = 132) then                           (: 'ordered' :)
      let $state := p:shift(132, $input, $state)            (: 'ordered' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(155, $input, $state)            (: 'unordered' :)
      return $state
  return p:reduce($state, "OrderingModeDecl", $count)
};

(:~
 : Parse ConstructionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ConstructionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(83, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | '(.' | 'construction' :)
  let $state := p:shift(81, $input, $state)                 (: 'construction' :)
  let $state := p:lookahead1W(97, $input, $state)           (: S^WS | '(.' | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:l1] = 148) then                           (: 'strip' :)
      let $state := p:shift(148, $input, $state)            (: 'strip' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(137, $input, $state)            (: 'preserve' :)
      return $state
  return p:reduce($state, "ConstructionDecl", $count)
};

(:~
 : Parse BaseURIDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BaseURIDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(83, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(38, $input, $state)           (: S^WS | '(.' | 'base-uri' :)
  let $state := p:shift(72, $input, $state)                 (: 'base-uri' :)
  let $state := p:lookahead1W(24, $input, $state)           (: StringLiteral | S^WS | '(.' :)
  let $state := p:parse-URILiteral($input, $state)
  return p:reduce($state, "BaseURIDecl", $count)
};

(:~
 : Parse DefaultCollationDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DefaultCollationDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(83, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | '(.' | 'default' :)
  let $state := p:shift(84, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | '(.' | 'collation' :)
  let $state := p:shift(79, $input, $state)                 (: 'collation' :)
  let $state := p:lookahead1W(24, $input, $state)           (: StringLiteral | S^WS | '(.' :)
  let $state := p:parse-URILiteral($input, $state)
  return p:reduce($state, "DefaultCollationDecl", $count)
};

(:~
 : Parse BoundarySpaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BoundarySpaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(83, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '(.' | 'boundary-space' :)
  let $state := p:shift(73, $input, $state)                 (: 'boundary-space' :)
  let $state := p:lookahead1W(97, $input, $state)           (: S^WS | '(.' | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:l1] = 137) then                           (: 'preserve' :)
      let $state := p:shift(137, $input, $state)            (: 'preserve' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(148, $input, $state)            (: 'strip' :)
      return $state
  return p:reduce($state, "BoundarySpaceDecl", $count)
};

(:~
 : Parse Setter.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Setter($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 83) then                            (: 'declare' :)
      let $state := p:lookahead2W(118, $input, $state)      (: S^WS | '(.' | 'base-uri' | 'boundary-space' |
                                                               'construction' | 'copy-namespaces' | 'default' |
                                                               'ordering' :)
      let $state :=
        if ($state[$p:lk] = 21587) then                     (: 'declare' 'default' :)
          let $state := p:lookahead3W(87, $input, $state)   (: S^WS | '(.' | 'collation' | 'order' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 18771) then                         (: 'declare' 'boundary-space' :)
      let $state := p:parse-BoundarySpaceDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 5198931) then                  (: 'declare' 'default' 'collation' :)
      let $state := p:parse-DefaultCollationDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 18515) then                    (: 'declare' 'base-uri' :)
      let $state := p:parse-BaseURIDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 20819) then                    (: 'declare' 'construction' :)
      let $state := p:parse-ConstructionDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 34131) then                    (: 'declare' 'ordering' :)
      let $state := p:parse-OrderingModeDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 8606803) then                  (: 'declare' 'default' 'order' :)
      let $state := p:parse-EmptyOrderDecl($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CopyNamespacesDecl($input, $state)
      return $state
  return p:reduce($state, "Setter", $count)
};

(:~
 : Parse DefaultNamespaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DefaultNamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(83, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | '(.' | 'default' :)
  let $state := p:shift(84, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(88, $input, $state)           (: S^WS | '(.' | 'element' | 'function' :)
  let $state :=
    if ($state[$p:l1] = 91) then                            (: 'element' :)
      let $state := p:shift(91, $input, $state)             (: 'element' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(103, $input, $state)            (: 'function' :)
      return $state
  let $state := p:lookahead1W(51, $input, $state)           (: S^WS | '(.' | 'namespace' :)
  let $state := p:shift(123, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(24, $input, $state)           (: StringLiteral | S^WS | '(.' :)
  let $state := p:parse-URILiteral($input, $state)
  return p:reduce($state, "DefaultNamespaceDecl", $count)
};

(:~
 : Parse the 1st loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(170, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | EOF |
                                                               '$' | '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] = 83) then                          (: 'declare' :)
        let $state := p:lookahead2W(138, $input, $state)    (: S^WS | EOF | '!=' | '(' | '(.' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | 'and' | 'base-uri' | 'boundary-space' |
                                                               'cast' | 'castable' | 'construction' |
                                                               'copy-namespaces' | 'default' | 'div' | 'eq' | 'except' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'namespace' |
                                                               'ne' | 'option' | 'or' | 'ordering' | 'to' | 'treat' |
                                                               'union' | 'variable' | '|' :)
        return $state
      else if ($state[$p:l1] = 109) then                    (: 'import' :)
        let $state := p:lookahead2W(133, $input, $state)    (: S^WS | EOF | '!=' | '(' | '(.' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | 'and' | 'cast' | 'castable' | 'div' | 'eq' |
                                                               'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'or' | 'schema' | 'to' | 'treat' | 'union' | '|' :)
        return $state
      else
        ($state[$p:l1], $state[position() > $p:lk])
    return
      if ($state[$p:lk] != 18515                            (: 'declare' 'base-uri' :)
      and $state[$p:lk] != 18771                            (: 'declare' 'boundary-space' :)
      and $state[$p:lk] != 20819                            (: 'declare' 'construction' :)
      and $state[$p:lk] != 21075                            (: 'declare' 'copy-namespaces' :)
      and $state[$p:lk] != 21587                            (: 'declare' 'default' :)
      and $state[$p:lk] != 31341                            (: 'import' 'module' :)
      and $state[$p:lk] != 31571                            (: 'declare' 'namespace' :)
      and $state[$p:lk] != 34131                            (: 'declare' 'ordering' :)
      and $state[$p:lk] != 36205) then                      (: 'import' 'schema' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 83) then                      (: 'declare' :)
            let $state := p:lookahead2W(121, $input, $state) (: S^WS | '(.' | 'base-uri' | 'boundary-space' |
                                                                'construction' | 'copy-namespaces' | 'default' |
                                                                'namespace' | 'ordering' :)
            let $state :=
              if ($state[$p:lk] = 21587) then               (: 'declare' 'default' :)
                let $state := p:lookahead3W(112, $input, $state) (: S^WS | '(.' | 'collation' | 'element' | 'function' |
                                                                    'order' :)
                return $state
              else
                $state
            return $state
          else
            ($state[$p:l1], $state[position() > $p:lk])
        let $state :=
          if ($state[$p:lk] = 5985363                       (: 'declare' 'default' 'element' :)
           or $state[$p:lk] = 6771795) then                 (: 'declare' 'default' 'function' :)
            let $state := p:parse-DefaultNamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 31571) then              (: 'declare' 'namespace' :)
            let $state := p:parse-NamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 109) then                (: 'import' :)
            let $state := p:parse-Import($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-Setter($input, $state)
            return $state
        let $state := p:lookahead1W(34, $input, $state)     (: S^WS | '(.' | ';' :)
        let $state := p:parse-Separator($input, $state)
        return p:parse-Prolog-1($input, $state)
};

(:~
 : Parse the 2nd loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(170, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | EOF |
                                                               '$' | '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] = 83) then                          (: 'declare' :)
        let $state := p:lookahead2W(135, $input, $state)    (: S^WS | EOF | '!=' | '(' | '(.' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | 'and' | 'cast' | 'castable' | 'div' | 'eq' |
                                                               'except' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'ne' | 'option' | 'or' | 'to' | 'treat' | 'union' |
                                                               'variable' | '|' :)
        return $state
      else
        ($state[$p:l1], $state[position() > $p:lk])
    return
      if ($state[$p:lk] != 26451                            (: 'declare' 'function' :)
      and $state[$p:lk] != 33107                            (: 'declare' 'option' :)
      and $state[$p:lk] != 40275) then                      (: 'declare' 'variable' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 83) then                      (: 'declare' :)
            let $state := p:lookahead2W(107, $input, $state) (: S^WS | '(.' | 'function' | 'option' | 'variable' :)
            return $state
          else
            ($state[$p:l1], $state[position() > $p:lk])
        let $state :=
          if ($state[$p:lk] = 40275) then                   (: 'declare' 'variable' :)
            let $state := p:parse-VarDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 26451) then              (: 'declare' 'function' :)
            let $state := p:parse-FunctionDecl($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-OptionDecl($input, $state)
            return $state
        let $state := p:lookahead1W(34, $input, $state)     (: S^WS | '(.' | ';' :)
        let $state := p:parse-Separator($input, $state)
        return p:parse-Prolog-2($input, $state)
};

(:~
 : Parse Prolog.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Prolog-1($input, $state)
  let $state := p:parse-Prolog-2($input, $state)
  return p:reduce($state, "Prolog", $count)
};

(:~
 : Parse URILiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-URILiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(6, $input, $state)                  (: StringLiteral :)
  return p:reduce($state, "URILiteral", $count)
};

(:~
 : Parse NCName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NCName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(125, $input, $state)           (: NCName^Token | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'to' | 'treat' |
                                                               'union' | 'where' :)
  let $state :=
    if ($state[$p:l1] = 67) then                            (: 'and' :)
      let $state := p:shift(67, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 69) then                       (: 'ascending' :)
      let $state := p:shift(69, $input, $state)             (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'case' :)
      let $state := p:shift(75, $input, $state)             (: 'case' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'cast' :)
      let $state := p:shift(76, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'castable' :)
      let $state := p:shift(77, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'collation' :)
      let $state := p:shift(79, $input, $state)             (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'default' :)
      let $state := p:shift(84, $input, $state)             (: 'default' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'descending' :)
      let $state := p:shift(87, $input, $state)             (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'div' :)
      let $state := p:shift(88, $input, $state)             (: 'div' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'else' :)
      let $state := p:shift(92, $input, $state)             (: 'else' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'empty' :)
      let $state := p:shift(93, $input, $state)             (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'eq' :)
      let $state := p:shift(96, $input, $state)             (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'except' :)
      let $state := p:shift(98, $input, $state)             (: 'except' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'for' :)
      let $state := p:shift(102, $input, $state)            (: 'for' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'ge' :)
      let $state := p:shift(104, $input, $state)            (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'gt' :)
      let $state := p:shift(106, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'idiv' :)
      let $state := p:shift(107, $input, $state)            (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'instance' :)
      let $state := p:shift(112, $input, $state)            (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'intersect' :)
      let $state := p:shift(113, $input, $state)            (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 114) then                      (: 'is' :)
      let $state := p:shift(114, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'le' :)
      let $state := p:shift(117, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'let' :)
      let $state := p:shift(119, $input, $state)            (: 'let' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'lt' :)
      let $state := p:shift(120, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 121) then                      (: 'mod' :)
      let $state := p:shift(121, $input, $state)            (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'ne' :)
      let $state := p:shift(124, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'or' :)
      let $state := p:shift(130, $input, $state)            (: 'or' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'order' :)
      let $state := p:shift(131, $input, $state)            (: 'order' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'return' :)
      let $state := p:shift(139, $input, $state)            (: 'return' :)
      return $state
    else if ($state[$p:l1] = 140) then                      (: 'satisfies' :)
      let $state := p:shift(140, $input, $state)            (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 146) then                      (: 'stable' :)
      let $state := p:shift(146, $input, $state)            (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'to' :)
      let $state := p:shift(151, $input, $state)            (: 'to' :)
      return $state
    else if ($state[$p:l1] = 152) then                      (: 'treat' :)
      let $state := p:shift(152, $input, $state)            (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'union' :)
      let $state := p:shift(154, $input, $state)            (: 'union' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'where' :)
      let $state := p:shift(159, $input, $state)            (: 'where' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(16, $input, $state)             (: NCName^Token :)
      return $state
  return p:reduce($state, "NCName", $count)
};

(:~
 : Parse ModuleDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(12, $input, $state)            (: 'module' :)
  let $state := p:shift(122, $input, $state)                (: 'module' :)
  let $state := p:lookahead1W(51, $input, $state)           (: S^WS | '(.' | 'namespace' :)
  let $state := p:shift(123, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(126, $input, $state)          (: S^WS | NCName^Token | '(.' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' :)
  let $state := p:parse-NCName($input, $state)
  let $state := p:lookahead1W(35, $input, $state)           (: S^WS | '(.' | '=' :)
  let $state := p:shift(56, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(24, $input, $state)           (: StringLiteral | S^WS | '(.' :)
  let $state := p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(34, $input, $state)           (: S^WS | '(.' | ';' :)
  let $state := p:parse-Separator($input, $state)
  return p:reduce($state, "ModuleDecl", $count)
};

(:~
 : Parse LibraryModule.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LibraryModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ModuleDecl($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Prolog($input, $state)
  return p:reduce($state, "LibraryModule", $count)
};

(:~
 : Parse Separator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Separator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(49, $input, $state)                 (: ';' :)
  return p:reduce($state, "Separator", $count)
};

(:~
 : Parse VersionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VersionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(160, $input, $state)                (: 'xquery' :)
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | '(.' | 'version' :)
  let $state := p:shift(158, $input, $state)                (: 'version' :)
  let $state := p:lookahead1W(24, $input, $state)           (: StringLiteral | S^WS | '(.' :)
  let $state := p:shift(6, $input, $state)                  (: StringLiteral :)
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | '(.' | ';' | 'encoding' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 95) then                       (: 'encoding' :)
      let $state := p:shift(95, $input, $state)             (: 'encoding' :)
      let $state := p:lookahead1W(24, $input, $state)       (: StringLiteral | S^WS | '(.' :)
      let $state := p:shift(6, $input, $state)              (: StringLiteral :)
      return $state
    else
      $state
  let $state := p:lookahead1W(34, $input, $state)           (: S^WS | '(.' | ';' :)
  let $state := p:parse-Separator($input, $state)
  return p:reduce($state, "VersionDecl", $count)
};

(:~
 : Parse Module.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Module($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(169, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 160) then                           (: 'xquery' :)
      let $state := p:lookahead2W(132, $input, $state)      (: S^WS | EOF | '!=' | '(' | '(.' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | 'and' | 'cast' | 'castable' | 'div' | 'eq' |
                                                               'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'to' | 'treat' | 'union' | 'version' | '|' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 40608) then                    (: 'xquery' 'version' :)
      let $state := p:parse-VersionDecl($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(169, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 122) then                           (: 'module' :)
      let $state := p:lookahead2W(131, $input, $state)      (: S^WS | EOF | '!=' | '(' | '(.' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | 'and' | 'cast' | 'castable' | 'div' | 'eq' |
                                                               'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'namespace' |
                                                               'ne' | 'or' | 'to' | 'treat' | 'union' | '|' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 31610) then                         (: 'module' 'namespace' :)
      let $state := p:parse-LibraryModule($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-MainModule($input, $state)
      return $state
  return p:reduce($state, "Module", $count)
};

(:~
 : Parse XQuery.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-XQuery($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Module($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | EOF | '(.' :)
  let $state := p:shift(24, $input, $state)                 (: EOF :)
  return p:reduce($state, "XQuery", $count)
};

(:~
 : Parse start symbol XQuery from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-XQuery($s as xs:string) as item()*
{
  let $state := p:parse-XQuery($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, false()))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      $state[position() >= $p:result]
};

(:~
 : Parse start symbol KeyValuePairs from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-KeyValuePairs($s as xs:string) as item()*
{
  let $state := p:parse-KeyValuePairs($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, false()))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      $state[position() >= $p:result]
};

(: End :)
