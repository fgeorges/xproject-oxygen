xquery version "1.0" encoding "UTF-8";

(: This file was generated on Sat Dec  3, 2011 03:46 by REx v5.10 which is Copyright (c) 1979-2011 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: XQueryML30.ebnf -xquery -tree :)

(:~
 : The parser that was generated for the XQueryML30 grammar.
 :)
module namespace p="XQueryML30";

declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  68, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
  8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
  29, 26, 30, 30, 30, 30, 30, 31, 32, 33, 30, 30, 30, 30, 30, 34, 30, 30, 30, 35, 30, 30, 36, 37, 38, 37, 39, 37, 40,
  41, 42, 43, 44, 45, 46, 47, 48, 30, 30, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 37,
  37
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  108, 124, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 156, 181, 181, 181, 181, 181, 214,
  215, 213, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 247, 261, 277, 293, 309, 324, 370,
  386, 422, 422, 422, 414, 354, 346, 354, 346, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
  354, 354, 439, 439, 439, 439, 439, 439, 439, 339, 354, 354, 354, 354, 354, 354, 354, 354, 400, 422, 422, 423, 421,
  422, 422, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 422, 422, 422,
  422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422,
  422, 422, 422, 422, 422, 422, 353, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
  354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 422, 68, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
  0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
  17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 26, 30, 30, 30, 30, 30, 31, 32,
  33, 30, 30, 30, 30, 34, 30, 30, 30, 35, 30, 30, 36, 37, 38, 37, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
  39, 37, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 37, 40, 41, 42, 43, 44, 45, 46, 47, 48, 30,
  30, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
  37, 37, 39, 39, 37, 37, 37, 37, 37, 37, 37, 67, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 67,
  67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 63744, 64976, 65008, 65536, 983040, 63743, 64975, 65007, 65533, 983039, 1114111, 37, 39, 37, 39, 39, 37
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 8194, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  2074, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
  60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88,
  89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,
  115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
  138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160,
  161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183,
  184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206,
  207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229,
  230, 231, 232, 233, 234
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 8915, 19987, 8865, 8870, 8870, 8832, 8870, 8870, 8870,
  8852, 8886, 8870, 8889, 8836, 8905, 16012, 12681, 27267, 15861, 27267, 27267, 27267, 27267, 27267, 27267, 10800,
  27267, 27267, 26129, 9200, 8935, 27267, 27267, 22432, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  8915, 27267, 27267, 27267, 27267, 27266, 27267, 27267, 27267, 26295, 20418, 8959, 8973, 27267, 23857, 27267, 12681,
  27267, 15861, 27267, 27267, 8989, 27267, 27267, 27267, 10800, 27267, 27267, 26129, 9200, 9009, 27267, 27267, 22432,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 8915, 10762, 9033, 27267, 27267, 9053, 27267, 9314,
  10904, 9074, 10902, 27267, 24673, 9113, 9126, 27267, 16984, 27267, 15861, 27267, 17117, 27267, 27267, 27267, 27267,
  12560, 27267, 27267, 19686, 15193, 9157, 11216, 27267, 22432, 27267, 27267, 27267, 27267, 27267, 9181, 27267, 27267,
  15485, 27267, 27267, 11022, 9199, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 18413, 9867, 26309, 27267, 27267, 22602, 27267, 18643, 27267, 26295, 16536, 9216, 9242, 26308, 18403, 9273,
  12681, 27267, 11895, 27267, 15357, 27267, 27267, 27267, 27267, 10800, 27267, 27267, 26129, 9200, 8935, 13019, 27267,
  22432, 27267, 27267, 27267, 27267, 27267, 9292, 27267, 27267, 12012, 27267, 27267, 11704, 9311, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 9611, 27267, 9087, 27267, 27267, 14078, 27267,
  18039, 9093, 9330, 27267, 27267, 9097, 26407, 9379, 27267, 12681, 27267, 15861, 27267, 27267, 27267, 27267, 27267,
  27267, 10800, 27267, 27267, 26129, 9200, 8935, 27267, 27267, 22432, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 8915, 27267, 27267, 27267, 27267, 27266, 27267, 27267, 9464, 9415, 27267, 9456, 27267, 12652, 9471,
  27267, 12681, 27267, 15861, 27267, 27267, 27267, 27267, 27267, 27267, 10800, 27267, 27267, 26129, 9200, 8935, 27267,
  27267, 22432, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 8915, 27267, 27267, 27267, 27267, 27266,
  27267, 27267, 27267, 24621, 27267, 27267, 27267, 27267, 17123, 27267, 20854, 27267, 15861, 27267, 27267, 27267, 27267,
  27267, 27267, 12760, 27267, 27267, 24990, 11039, 9487, 27267, 27267, 22432, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 8915, 17785, 9511, 27267, 27267, 9531, 27267, 10104, 11060, 9552, 11058, 27267, 25284, 9588,
  9601, 27267, 16595, 27267, 15861, 27267, 22836, 27267, 27267, 27267, 27267, 11724, 27267, 27267, 17377, 9200, 9635,
  10107, 27267, 22432, 27267, 27267, 27267, 27267, 27267, 25296, 27267, 27267, 10883, 27267, 27267, 17690, 9659, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 9389, 15364, 9692, 9700, 9700,
  9679, 9700, 9702, 9700, 9718, 9786, 9776, 9733, 9802, 9816, 27267, 12681, 27267, 10679, 27267, 27267, 27267, 27267,
  27267, 27267, 10800, 27267, 27267, 26129, 9200, 8935, 27267, 27267, 9565, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 8915, 27267, 26654, 27267, 27267, 23408, 27267, 27267, 25432, 9854, 9889, 9918, 9923, 25424,
  9902, 9939, 12681, 27267, 12902, 27267, 27267, 27267, 27267, 27267, 27267, 10800, 27267, 27267, 26129, 9200, 8935,
  27267, 27267, 27260, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 8915, 27267, 26549, 27267, 27267,
  27266, 27267, 27267, 27267, 26295, 12542, 9957, 9971, 9987, 10000, 27267, 12681, 27267, 15861, 27267, 27267, 27267,
  27267, 27267, 27267, 10800, 27267, 27267, 26129, 9200, 8935, 27267, 27267, 22432, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 23949, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 8915, 27267, 27267, 27267, 27267, 27266, 27267, 27267, 27267, 26295, 19493, 10016, 10038,
  18808, 10022, 27267, 12681, 27267, 15861, 27267, 27267, 27267, 27267, 27267, 27267, 10800, 27267, 27267, 26129, 9200,
  8935, 27267, 27267, 23847, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 8915, 27267, 16063, 27267,
  27267, 9572, 27267, 27267, 10101, 10074, 10088, 10123, 10135, 27267, 12218, 27267, 12681, 27267, 15861, 27267, 27267,
  27267, 27267, 27267, 27267, 10800, 27267, 27267, 26129, 9200, 8935, 27267, 27267, 22432, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 10151, 27267, 27267, 27267, 27267, 27266, 27267, 27267, 27267, 26295, 20594, 10178,
  10200, 19121, 10184, 10240, 12681, 27267, 15861, 27267, 27267, 27267, 20614, 10338, 27267, 10800, 21057, 10504, 19147,
  10377, 10260, 27101, 27267, 23847, 27267, 25586, 12469, 22236, 12984, 10510, 21057, 25637, 17011, 13365, 13365, 24081,
  24200, 27267, 27267, 27267, 27071, 10285, 10334, 15107, 21057, 21057, 21057, 19894, 13365, 13365, 20910, 21971, 10307,
  27267, 27267, 10329, 10337, 21055, 21057, 21057, 13643, 13365, 13365, 16675, 27267, 27267, 22576, 10334, 21056, 10960,
  11136, 10354, 19899, 21971, 13127, 24137, 20332, 21057, 10375, 22357, 18594, 23055, 20329, 21057, 13365, 15853, 10393,
  10421, 10459, 21967, 10492, 20074, 15891, 10526, 10550, 16949, 13725, 16994, 10587, 19735, 19736, 13091, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 8915, 27267, 27267,
  27267, 27267, 10624, 27267, 27267, 10821, 26295, 27267, 27267, 27267, 19256, 10645, 12169, 12681, 27267, 12111, 27267,
  27267, 27267, 20614, 10338, 27267, 10800, 21057, 10504, 19147, 10377, 10661, 27267, 27267, 22432, 27267, 27267, 12469,
  22236, 12984, 10510, 21057, 25637, 17011, 13365, 13365, 19900, 24200, 27267, 27267, 27267, 27267, 20614, 10334, 15107,
  21057, 21057, 21057, 19894, 13365, 13365, 20910, 21971, 27267, 27267, 27267, 20615, 10337, 21055, 21057, 21057, 13643,
  13365, 13365, 16675, 27267, 27267, 27267, 10334, 21056, 21057, 11136, 13365, 19899, 21971, 27267, 24137, 20332, 21057,
  13729, 26870, 27267, 16287, 20329, 21057, 13365, 21967, 24138, 21057, 13728, 21967, 23067, 16496, 15821, 16499, 15825,
  16949, 13725, 10508, 23602, 19735, 19736, 13091, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 8915, 9058, 10696, 27267, 27267, 10695, 27267, 27267, 27267, 26295, 21440,
  10712, 10726, 19918, 10742, 27267, 12681, 27267, 15861, 27267, 27267, 10778, 27267, 24895, 27267, 10800, 27267, 27267,
  26129, 9200, 8935, 27267, 27267, 22432, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 8915, 27267,
  10798, 27267, 27267, 10816, 27267, 27267, 15070, 26295, 27267, 27267, 27267, 13421, 10837, 12169, 18383, 27267, 12736,
  27267, 27267, 27267, 20614, 10338, 27267, 10800, 21057, 10504, 19147, 10377, 10853, 27267, 27267, 25414, 11289, 27267,
  12469, 22236, 12984, 10510, 21057, 25637, 17011, 13365, 13365, 19900, 24964, 10878, 18093, 27267, 10899, 20614, 10334,
  11126, 21057, 21057, 21057, 10920, 13365, 13365, 13348, 16685, 27267, 27267, 10941, 20615, 21699, 10958, 21057, 21057,
  10976, 13365, 13365, 18737, 10997, 27267, 27267, 20024, 10959, 21057, 25838, 13365, 13648, 21971, 27267, 24137, 20332,
  21057, 13729, 26870, 27267, 16287, 20329, 21057, 13365, 21967, 24138, 21057, 13728, 21967, 23067, 16496, 15821, 16499,
  15825, 16949, 13725, 10508, 23602, 19735, 19736, 13091, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 11017, 27267, 9536, 27267, 27267, 11038, 11055, 27267, 20940, 26295,
  27267, 27267, 11076, 27267, 17385, 11112, 15346, 27267, 10862, 27267, 27267, 27267, 27267, 27267, 27267, 10800, 11453,
  11160, 11182, 11307, 11207, 27267, 27267, 23684, 27267, 27267, 27267, 27267, 27267, 11232, 11453, 11240, 11273, 11305,
  11305, 11191, 11284, 27267, 27267, 27267, 27267, 27267, 27267, 12147, 11453, 11453, 11453, 25169, 11305, 11305, 25178,
  11288, 27267, 27267, 27267, 27267, 27267, 11451, 11453, 11453, 11323, 11305, 11305, 11501, 27267, 27267, 27267, 27267,
  11452, 11453, 11347, 11305, 25174, 11288, 27267, 27267, 11165, 11453, 11257, 11371, 27267, 27267, 12148, 11453, 11305,
  11420, 27267, 11453, 11256, 11420, 11449, 11328, 11166, 11331, 11248, 11441, 11253, 11164, 11355, 11469, 11470, 11486,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 8915,
  27267, 24040, 27267, 27267, 11535, 11612, 27267, 27267, 11561, 11600, 11633, 11645, 27267, 11545, 27267, 12681, 27267,
  15861, 27267, 27267, 27267, 27267, 27267, 27267, 10800, 27267, 27267, 26129, 9200, 8935, 27267, 27267, 22432, 27267,
  11661, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27268, 11678, 27267, 27267, 11722, 27267,
  27267, 24682, 27267, 27267, 27267, 11700, 27267, 27267, 14753, 9495, 27267, 27267, 11720, 27267, 9183, 25299, 27267,
  27267, 11700, 27267, 27267, 14760, 11740, 27267, 27267, 9182, 25299, 27267, 26129, 27267, 25436, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 8915, 27267, 27267, 27267, 27267, 27266, 27267, 27267, 27267,
  20145, 26915, 11760, 11772, 20573, 11788, 27267, 12681, 27267, 15861, 27267, 27267, 27267, 27267, 18236, 27267, 10800,
  27267, 27267, 26129, 9200, 11835, 27267, 27267, 22432, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  9136, 9141, 21759, 27267, 27267, 27266, 27267, 27267, 27267, 26295, 26137, 11859, 11871, 27267, 12397, 27267, 14533,
  27267, 15861, 27267, 27267, 27267, 27267, 18393, 27267, 10800, 27267, 27267, 26129, 9200, 11887, 27267, 27267, 22432,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 23867, 23872, 11912, 27267, 27267, 11911, 27267, 27267,
  27267, 26295, 8943, 11928, 11940, 27267, 12423, 11956, 12681, 27267, 15861, 27267, 27267, 27267, 27267, 9017, 27267,
  10800, 27267, 27267, 26129, 9200, 11993, 27267, 27267, 22432, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 12062, 12067, 27267, 27267, 27267, 22439, 27267, 27267, 27267, 26295, 27267, 26480, 12028, 27267, 12052, 27267,
  12681, 27267, 15861, 27267, 27267, 12083, 27267, 27267, 27267, 10800, 27267, 27267, 26129, 9200, 12103, 27267, 27267,
  22432, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 8915, 27267, 27267, 27267, 27267, 27266, 27267,
  27267, 27267, 26295, 27267, 27267, 27267, 26589, 12127, 27267, 12681, 27267, 15861, 27267, 27267, 27267, 27267, 27267,
  27267, 10800, 27267, 27267, 26129, 9200, 8935, 27267, 27267, 22432, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 12164, 27267, 27267, 27267, 27267, 12186, 27267, 27267, 27267, 26295, 13223, 17688, 21556, 19725, 14666,
  12169, 12681, 27267, 15861, 27267, 11512, 27267, 20614, 10338, 27267, 10800, 21057, 10504, 19147, 10377, 12208, 12262,
  27267, 22432, 27267, 11518, 12469, 22236, 12984, 12234, 21057, 25637, 18706, 13365, 13365, 24117, 12255, 12278, 27267,
  27267, 10942, 20614, 10334, 21213, 21057, 21057, 21057, 12300, 13365, 13365, 19156, 24232, 27267, 27267, 10941, 20615,
  24933, 12321, 21057, 21057, 12339, 13365, 13365, 17816, 10997, 27267, 12141, 20024, 10959, 21057, 25838, 13365, 13648,
  21971, 27267, 24137, 20332, 21057, 13729, 26870, 27267, 13215, 20329, 21057, 13365, 21967, 24138, 21057, 13728, 21967,
  23067, 16496, 15821, 16499, 15825, 16949, 13725, 10508, 23602, 19735, 19736, 13091, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 12164, 27267, 27267, 27267, 27267, 12186,
  27267, 27267, 27267, 26295, 13223, 17688, 21556, 19725, 14666, 12169, 12681, 27267, 15861, 27267, 11512, 27267, 20614,
  10338, 27267, 10800, 21057, 10504, 19147, 10377, 12208, 12262, 27267, 22432, 27267, 11518, 12469, 22236, 12984, 12234,
  21057, 25637, 18706, 13365, 13365, 24117, 12255, 12278, 27267, 27267, 10942, 20614, 10334, 21213, 21057, 21057, 21057,
  12300, 13365, 13365, 19156, 24232, 27267, 27267, 10941, 20615, 24933, 12321, 21057, 21057, 12339, 13365, 13365, 17816,
  10997, 27267, 27267, 20024, 10959, 21057, 25838, 13365, 13648, 21971, 27267, 24137, 20332, 21057, 13729, 26870, 27267,
  16287, 20329, 21057, 13365, 21967, 24138, 21057, 13728, 21967, 23067, 16496, 15821, 16499, 15825, 16949, 13725, 10508,
  23602, 19735, 19736, 13091, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 12164, 27267, 27267, 27267, 27267, 12186, 27267, 27267, 27267, 26295, 13223, 17688, 21556, 19725,
  14666, 12169, 12681, 27267, 15861, 27267, 11512, 27267, 20614, 10338, 27267, 10800, 21057, 10504, 19147, 10377, 12208,
  12262, 27267, 22432, 27267, 11518, 12469, 22236, 12984, 12234, 21057, 25637, 18706, 13365, 13365, 24117, 12255, 12278,
  27267, 27267, 12360, 20614, 10334, 21213, 21057, 21057, 21057, 12300, 13365, 13365, 19156, 24232, 27267, 27267, 10941,
  20615, 24933, 12321, 21057, 21057, 12339, 13365, 13365, 17816, 10997, 27267, 27267, 20024, 10959, 21057, 25838, 13365,
  13648, 21971, 27267, 24137, 20332, 21057, 13729, 26870, 27267, 16287, 20329, 21057, 13365, 21967, 24138, 21057, 13728,
  21967, 23067, 16496, 15821, 16499, 15825, 16949, 13725, 10508, 23602, 19735, 19736, 13091, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 12164, 27267, 27267, 27267, 27267,
  12186, 27267, 27267, 27267, 26295, 13223, 17688, 21556, 19725, 14666, 12169, 12681, 27267, 15861, 27267, 11512, 27267,
  20614, 10338, 27267, 10800, 21057, 10504, 19147, 10377, 12208, 12262, 27267, 22432, 27267, 11518, 12469, 22236, 12984,
  12234, 21057, 25637, 18706, 13365, 13365, 24117, 12255, 12278, 27267, 27267, 10942, 20614, 10334, 21213, 21057, 21057,
  21057, 12300, 13365, 13365, 19156, 24232, 27267, 27267, 12387, 20615, 24933, 12321, 21057, 21057, 12339, 13365, 13365,
  17816, 10997, 27267, 27267, 20024, 10959, 21057, 25838, 13365, 13648, 21971, 27267, 24137, 20332, 21057, 13729, 26870,
  27267, 16287, 20329, 21057, 13365, 21967, 24138, 21057, 13728, 21967, 23067, 16496, 15821, 16499, 15825, 16949, 13725,
  10508, 23602, 19735, 19736, 13091, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 12164, 27267, 27267, 27267, 27267, 12186, 27267, 27267, 27267, 26295, 13223, 17688, 21556,
  19725, 14666, 12169, 12681, 27267, 12036, 27267, 11512, 27267, 20614, 10338, 27267, 10800, 21057, 10504, 19147, 10377,
  12208, 12262, 27267, 24383, 27267, 11518, 12469, 22236, 12984, 12234, 21057, 25637, 18706, 13365, 13365, 24117, 12255,
  12278, 27267, 27267, 10942, 20614, 10334, 21213, 21057, 21057, 21057, 12300, 13365, 13365, 19156, 24232, 27267, 27267,
  10941, 20615, 24933, 12321, 21057, 21057, 12339, 13365, 13365, 17816, 10997, 27267, 27267, 20024, 10959, 21057, 25838,
  13365, 13648, 21971, 27267, 24137, 20332, 21057, 13729, 26870, 27267, 16287, 20329, 21057, 13365, 21967, 24138, 21057,
  13728, 21967, 23067, 16496, 15821, 16499, 15825, 16949, 13725, 10508, 23602, 19735, 19736, 13091, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 12164, 27267, 27267, 27267,
  27267, 12186, 27267, 27267, 27267, 26295, 13223, 17688, 21556, 19725, 14666, 12169, 12681, 27267, 15861, 27267, 11512,
  27267, 20614, 10338, 27267, 10800, 21057, 10504, 19147, 10377, 12208, 12262, 27267, 22432, 27267, 11518, 12469, 22236,
  12984, 12234, 21057, 25637, 18706, 13365, 13365, 24117, 12255, 12278, 27267, 27267, 27267, 20614, 10334, 21213, 21057,
  21057, 21057, 12300, 13365, 13365, 19156, 21971, 27267, 27267, 27267, 20615, 10337, 21055, 21057, 21057, 13643, 13365,
  13365, 16675, 27267, 27267, 27267, 10334, 21056, 21057, 11136, 13365, 19899, 21971, 27267, 24137, 20332, 21057, 13729,
  26870, 27267, 16287, 20329, 21057, 13365, 21967, 24138, 21057, 13728, 21967, 23067, 16496, 15821, 16499, 15825, 16949,
  13725, 10508, 23602, 19735, 19736, 13091, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 12164, 27267, 27267, 27267, 27267, 12186, 27267, 27267, 27267, 26295, 13223, 17688,
  21556, 19725, 14666, 12169, 12681, 27267, 15861, 27267, 11512, 27267, 20614, 10338, 27267, 10800, 21057, 10504, 19147,
  10377, 12413, 12262, 27267, 22432, 27267, 11518, 12469, 22236, 12984, 12234, 21057, 25637, 18706, 13365, 13365, 24117,
  12255, 12278, 27267, 27267, 27267, 20614, 10334, 21213, 21057, 21057, 21057, 12300, 13365, 13365, 19156, 21971, 27267,
  27267, 27267, 20615, 10337, 21055, 21057, 21057, 13643, 13365, 13365, 16675, 27267, 27267, 27267, 10334, 21056, 21057,
  11136, 13365, 19899, 21971, 27267, 24137, 20332, 21057, 13729, 26870, 27267, 16287, 20329, 21057, 13365, 21967, 24138,
  21057, 13728, 21967, 23067, 16496, 15821, 16499, 15825, 16949, 13725, 10508, 23602, 19735, 19736, 13091, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 12164, 27267, 27267,
  27267, 27267, 12186, 27267, 27267, 27267, 26295, 13223, 17688, 21556, 19725, 16768, 12169, 12681, 27267, 15861, 27267,
  11512, 27267, 20614, 10338, 27267, 10800, 21057, 10504, 19147, 10377, 12208, 12262, 27267, 22432, 27267, 11518, 12469,
  22236, 12984, 12234, 21057, 25637, 18706, 13365, 13365, 24117, 12255, 12278, 27267, 27267, 27267, 20614, 10334, 21213,
  21057, 21057, 21057, 12300, 13365, 13365, 19156, 21971, 27267, 27267, 27267, 20615, 10337, 21055, 21057, 21057, 13643,
  13365, 13365, 16675, 27267, 27267, 27267, 10334, 21056, 21057, 11136, 13365, 19899, 21971, 27267, 24137, 20332, 21057,
  13729, 26870, 27267, 16287, 20329, 21057, 13365, 21967, 24138, 21057, 13728, 21967, 23067, 16496, 15821, 16499, 15825,
  16949, 13725, 10508, 23602, 19735, 19736, 13091, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 12164, 27267, 27267, 27267, 27267, 12186, 27267, 27267, 27267, 26295, 12439,
  17688, 21556, 19725, 14666, 12169, 12681, 27267, 15861, 27267, 11512, 27267, 20614, 10338, 27267, 10800, 21057, 10504,
  19147, 10377, 12208, 12262, 27267, 22432, 27267, 23533, 12469, 22236, 12984, 12234, 21057, 25637, 18706, 13365, 13365,
  24117, 12255, 12278, 27267, 27267, 27267, 20614, 10334, 21213, 21057, 21057, 21057, 12300, 13365, 13365, 19156, 21971,
  27267, 27267, 27267, 20615, 10337, 21055, 21057, 21057, 13643, 13365, 13365, 16675, 27267, 27267, 27267, 10334, 21056,
  21057, 11136, 13365, 19899, 21971, 27267, 24137, 20332, 21057, 13729, 26870, 27267, 16287, 20329, 21057, 13365, 21967,
  24138, 21057, 13728, 21967, 23067, 16496, 15821, 16499, 15825, 16949, 13725, 10508, 23602, 19735, 19736, 13091, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 12164, 27267,
  27267, 27267, 27267, 12186, 27267, 27267, 27267, 26295, 13223, 17688, 21556, 19725, 14666, 12169, 12681, 27267, 15861,
  27267, 11512, 27267, 20614, 10338, 27267, 10800, 21057, 10504, 19147, 10377, 12208, 12262, 27267, 22432, 27267, 11518,
  12469, 22236, 12984, 12234, 21057, 25637, 18706, 13365, 13365, 24117, 12255, 12278, 27267, 27267, 27267, 20614, 10334,
  21213, 21057, 21057, 21057, 12300, 13365, 13365, 19156, 21971, 27267, 27267, 27267, 20615, 10337, 21055, 21057, 21057,
  13643, 13365, 13365, 16675, 27267, 27267, 27267, 10334, 21056, 21057, 11136, 13365, 19899, 21971, 27267, 12468, 20332,
  21057, 13729, 26870, 27267, 16287, 20329, 21057, 13365, 21967, 24138, 21057, 13728, 21967, 23067, 16496, 15821, 16499,
  15825, 16949, 13725, 10508, 23602, 19735, 19736, 13091, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 12485, 27267, 27267, 27267, 27267, 12186, 27267, 27267, 27267, 26295,
  13223, 17688, 21556, 19725, 14666, 12169, 12681, 27267, 15861, 27267, 11512, 27267, 20614, 10338, 27267, 10800, 21057,
  10504, 19147, 10377, 12208, 12262, 27267, 22432, 27267, 11518, 12469, 22236, 12984, 12234, 21057, 25637, 18706, 13365,
  13365, 24117, 12255, 12278, 27267, 27267, 27267, 20614, 10334, 21213, 21057, 21057, 21057, 12300, 13365, 13365, 19156,
  21971, 27267, 27267, 27267, 20615, 10337, 21055, 21057, 21057, 13643, 13365, 13365, 16675, 27267, 27267, 27267, 10334,
  21056, 21057, 11136, 13365, 19899, 21971, 27267, 24137, 20332, 21057, 13729, 26870, 27267, 16287, 20329, 21057, 13365,
  21967, 24138, 21057, 13728, 21967, 23067, 16496, 15821, 16499, 15825, 16949, 13725, 10508, 23602, 19735, 19736, 13091,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 8915,
  27267, 27267, 27267, 27267, 27266, 27267, 27267, 27267, 26295, 12596, 12507, 12522, 27267, 13805, 27267, 12681, 27267,
  15861, 27267, 27267, 27267, 27267, 27267, 27267, 10800, 27267, 27267, 26129, 9200, 8935, 27267, 27267, 22432, 27267,
  21121, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 12558, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 8915, 27267, 27267, 27267, 27267, 27266, 27267, 27267, 27267,
  26295, 27267, 27267, 27267, 27267, 17123, 27267, 12681, 27267, 15861, 27267, 27267, 27267, 27267, 27267, 27267, 10800,
  27267, 27267, 26129, 9200, 8935, 27267, 27267, 22432, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  12576, 27267, 25775, 27267, 27267, 27266, 27267, 27267, 27267, 12612, 12668, 12707, 12712, 27267, 11584, 20174, 12681,
  27267, 15861, 27267, 27267, 27267, 27267, 27267, 27267, 10800, 27267, 27267, 26129, 9200, 12728, 27267, 27267, 22432,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 12164, 27267, 27267, 27267, 27267, 12186, 27267, 27267,
  27267, 26295, 13223, 17688, 21556, 19725, 14666, 12169, 12681, 27267, 15861, 27267, 27267, 27267, 20614, 10338, 27267,
  10800, 21057, 10504, 19147, 10377, 12208, 27267, 27267, 22432, 27267, 27267, 12469, 22236, 12984, 15112, 21057, 25637,
  11404, 13365, 13365, 19900, 24200, 27267, 27267, 27267, 27267, 20614, 10334, 15107, 21057, 21057, 21057, 19894, 13365,
  13365, 20910, 21971, 27267, 27267, 27267, 20615, 10337, 21055, 21057, 21057, 13643, 13365, 13365, 16675, 27267, 27267,
  27267, 10334, 21056, 21057, 11136, 13365, 19899, 21971, 27267, 24137, 20332, 21057, 13729, 26870, 27267, 16287, 20329,
  21057, 13365, 21967, 24138, 21057, 13728, 21967, 23067, 16496, 15821, 16499, 15825, 16949, 13725, 10508, 23602, 19735,
  19736, 13091, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 12164, 27267, 27267, 12758, 27267, 12186, 12752, 27267, 12776, 12791, 12820, 12836, 12849, 12865, 12878, 12894,
  12804, 16225, 11843, 27267, 12918, 13537, 12954, 12979, 13002, 13035, 13062, 13051, 13078, 20725, 13107, 12262, 27267,
  22432, 13123, 13143, 19094, 25336, 12984, 12234, 21057, 13176, 18706, 13365, 13365, 13201, 12255, 13239, 27267, 10053,
  10942, 24428, 16330, 13275, 13301, 12239, 13320, 13339, 13364, 13365, 13382, 24232, 13398, 17277, 13417, 19863, 23716,
  13437, 13463, 21057, 13483, 26068, 13365, 13499, 13526, 13553, 14545, 20024, 10959, 21298, 13569, 13365, 13593, 26698,
  13609, 24137, 20332, 13628, 13729, 13664, 27267, 16287, 24776, 12323, 24111, 13700, 24138, 21057, 13728, 21967, 23067,
  16496, 15821, 22921, 13720, 20995, 13725, 17872, 14491, 19735, 19736, 13091, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 12164, 27267, 27267, 13745, 27267, 12186, 9643,
  27267, 27267, 13766, 13223, 13795, 21947, 13821, 13834, 12169, 12681, 27267, 15861, 27267, 11512, 27267, 20614, 10338,
  27267, 10800, 21057, 10504, 19147, 10377, 12208, 12262, 27267, 22432, 27267, 11518, 12469, 22236, 12984, 12234, 21057,
  25637, 18706, 13365, 13365, 24117, 12255, 12278, 27267, 10058, 13850, 11090, 19675, 21213, 21057, 14967, 21057, 12300,
  13365, 19472, 19156, 24232, 27267, 27267, 10941, 20615, 24933, 12321, 21057, 21057, 12339, 13365, 13365, 17816, 10997,
  27267, 13883, 13902, 13918, 16743, 24449, 13365, 13648, 21971, 27267, 24137, 20332, 21057, 13729, 26870, 27267, 16287,
  20329, 21057, 13365, 21967, 24138, 21057, 13728, 21967, 23067, 16496, 15821, 16499, 15825, 16922, 15784, 10508, 23602,
  19735, 19736, 13091, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 13938, 13960, 27267, 11574, 27267, 12186, 13944, 27267, 24392, 13977, 13993, 14009, 14023, 14039, 14052,
  12169, 12681, 27267, 14068, 12170, 14094, 27267, 20614, 10338, 27267, 10800, 21057, 10504, 16430, 18682, 12208, 12262,
  26097, 23027, 27267, 22632, 9748, 14116, 22128, 14136, 14172, 20772, 15754, 23321, 13365, 24117, 14190, 12278, 27267,
  14206, 10942, 14223, 10334, 24750, 14251, 21866, 19395, 14271, 14298, 20529, 19156, 24232, 27267, 27267, 14324, 20615,
  24933, 12321, 21057, 21058, 12339, 13365, 18846, 17816, 10997, 27267, 27267, 20024, 10959, 21057, 25838, 13365, 13648,
  21971, 27267, 24137, 14345, 21057, 13729, 14361, 15477, 16287, 24498, 14397, 23120, 21967, 24138, 21057, 14434, 14453,
  23067, 16496, 15821, 16499, 15825, 15814, 14474, 10508, 23602, 19735, 19736, 25365, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 12164, 27267, 27267, 27107, 27267, 12186,
  18601, 13401, 13011, 14507, 14568, 14584, 14596, 14612, 14625, 12169, 12681, 27267, 15861, 27267, 11512, 27267, 14718,
  10338, 25113, 14641, 17003, 10504, 14657, 14682, 14698, 12262, 23894, 22432, 27164, 11518, 19694, 14734, 16339, 14776,
  17723, 25637, 14792, 16476, 20519, 24117, 12255, 12278, 11617, 12491, 10942, 20614, 10334, 21213, 21057, 21057, 21057,
  12300, 13365, 13365, 19156, 24232, 14826, 24979, 10941, 20615, 24933, 14844, 21057, 14867, 14886, 13365, 24821, 17816,
  10997, 27267, 22855, 14924, 14940, 14961, 23575, 18298, 13648, 21971, 15309, 27170, 9440, 14983, 15005, 15032, 27267,
  16287, 20329, 21057, 13365, 26032, 24138, 17231, 13728, 15065, 23067, 16496, 15821, 16499, 15086, 16949, 15133, 10508,
  23602, 19735, 19736, 13091, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 12164, 27267, 27267, 9037, 27267, 12186, 15170, 15192, 15186, 15209, 15225, 15241, 15254, 15270,
  15283, 12169, 15299, 22092, 15333, 15380, 11512, 15612, 15413, 15462, 15501, 15535, 20457, 20446, 15551, 15587, 12208,
  22672, 10571, 15603, 15628, 15670, 12469, 22237, 15695, 12234, 15720, 15770, 15800, 25943, 15841, 15877, 15920, 15936,
  15952, 15154, 16007, 16028, 16079, 16095, 26850, 16132, 16158, 16174, 16207, 16241, 16270, 17826, 10215, 16286, 16303,
  16319, 14235, 16355, 14851, 16404, 16455, 16492, 16515, 17857, 10997, 15446, 16531, 11096, 16552, 16621, 25838, 16651,
  20646, 16222, 18790, 24137, 16701, 16737, 16759, 16784, 16800, 16816, 16837, 16896, 16938, 16970, 9428, 19943, 15654,
  15016, 17027, 25388, 17075, 17103, 16116, 17139, 17160, 17185, 17214, 17259, 17247, 13091, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 12164, 8919, 27267, 27267, 27267,
  12186, 9663, 17275, 17293, 17337, 17352, 17401, 17413, 17429, 17442, 12169, 12681, 24467, 15861, 27267, 11512, 27267,
  20614, 10338, 27267, 10800, 21057, 10504, 17458, 17491, 12208, 12262, 20411, 22799, 27267, 14100, 10224, 22236, 12984,
  17507, 21057, 25637, 18706, 19827, 13365, 24117, 12255, 12278, 27267, 27267, 10942, 20614, 10334, 21213, 21057, 22961,
  21057, 12300, 13365, 25982, 19156, 24232, 27267, 27267, 10941, 20615, 24933, 12321, 21057, 21057, 12339, 13365, 13365,
  17816, 10997, 12537, 27267, 20748, 10959, 19791, 25838, 13365, 17542, 21971, 27267, 24137, 20332, 21057, 13729, 26870,
  27267, 16287, 20329, 21057, 13365, 23629, 24138, 21057, 13728, 21967, 23067, 16496, 15821, 16499, 15825, 16949, 13725,
  10508, 23602, 17570, 17558, 25465, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 12164, 27267, 27267, 27267, 27267, 12186, 27267, 13157, 13151, 17586, 17601, 17617, 17629,
  17645, 17658, 12169, 12681, 27267, 15861, 27267, 11512, 27267, 20614, 10338, 27267, 10800, 21057, 10504, 19147, 10377,
  12208, 12262, 27267, 22432, 27267, 19021, 12469, 22236, 12984, 12234, 21057, 25637, 18706, 13365, 13365, 24117, 12255,
  12278, 27267, 27267, 27267, 20614, 10334, 21213, 21057, 21057, 21057, 12300, 13365, 13365, 19156, 21971, 27267, 27267,
  27267, 20615, 10337, 21055, 21057, 21057, 13643, 13365, 13365, 16675, 27267, 27267, 27267, 10334, 21056, 21057, 11136,
  13365, 19899, 21971, 9619, 24137, 20332, 21057, 13729, 26870, 10269, 17674, 20329, 21057, 13365, 21967, 15967, 17706,
  21600, 21967, 17739, 17768, 15821, 16499, 15825, 16949, 13725, 10508, 23602, 19735, 17801, 17842, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 12164, 27267, 27267, 27267,
  27267, 12186, 27267, 27267, 27267, 26295, 13223, 17688, 21556, 19725, 14666, 12169, 12681, 27267, 23398, 27267, 11512,
  17895, 20614, 14746, 27267, 10800, 17925, 17914, 23162, 10925, 12208, 17947, 27267, 17996, 11425, 11518, 12469, 22236,
  12984, 12234, 21057, 25637, 17198, 13365, 22293, 24117, 12255, 12278, 27267, 27267, 27267, 20614, 10334, 21213, 21057,
  21057, 21057, 12300, 13365, 13365, 19156, 18020, 27267, 27267, 27267, 20615, 10337, 17225, 21057, 21057, 16911, 13365,
  13365, 23214, 27267, 27267, 27267, 10334, 21056, 21057, 18838, 13365, 16665, 21971, 18038, 24137, 20332, 21057, 13729,
  26870, 27267, 16287, 20329, 21057, 13365, 21967, 24138, 21057, 13728, 21967, 18055, 26570, 15821, 16499, 15825, 16949,
  13725, 10508, 23602, 19735, 19736, 13091, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 12164, 9276, 27267, 27267, 18071, 12186, 19086, 18089, 19077, 26295, 18109, 18125,
  18138, 18154, 18167, 12169, 12681, 27267, 15519, 27267, 11512, 15679, 20319, 10338, 18183, 18202, 23746, 19211, 23188,
  10377, 12208, 12262, 27267, 22432, 18004, 11518, 12469, 17973, 18218, 18252, 14149, 14410, 19183, 18277, 18297, 18314,
  18354, 18370, 18444, 24537, 18490, 20614, 22661, 21213, 21057, 18261, 21057, 12300, 13365, 20537, 18548, 21971, 27267,
  25802, 18564, 20615, 10337, 21055, 21057, 11396, 18674, 13365, 13365, 16582, 11519, 26823, 18582, 10334, 21056, 21057,
  18617, 25935, 19899, 20085, 18641, 23973, 18659, 18698, 18722, 18772, 18806, 26951, 18824, 13323, 24851, 15565, 18756,
  21057, 13728, 10562, 23067, 16496, 15821, 16499, 18862, 18878, 13725, 10508, 22275, 18901, 19736, 20825, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 12164, 8993, 27267,
  27267, 27267, 12186, 27267, 13864, 13858, 18927, 18942, 18958, 18970, 18986, 18999, 12169, 12681, 15510, 15861, 10782,
  19015, 27267, 19037, 12963, 27267, 26232, 15746, 25218, 19282, 10377, 12413, 12262, 19119, 22432, 19064, 19110, 15571,
  10291, 12984, 19137, 19172, 19199, 18706, 23307, 23786, 17169, 12255, 19227, 20093, 19252, 27267, 26768, 10334, 24575,
  19272, 21057, 21057, 19298, 17059, 13365, 19156, 14807, 27267, 18186, 22708, 20615, 19314, 21055, 26009, 21057, 13643,
  23805, 23778, 16675, 14329, 27267, 27267, 19336, 25629, 21057, 11136, 19356, 19899, 10534, 13961, 19373, 19386, 21057,
  19411, 26870, 24253, 14458, 20329, 21057, 13365, 21967, 19433, 21057, 19469, 19488, 23067, 16496, 15821, 16499, 15825,
  16949, 13725, 12691, 19509, 19549, 19575, 13091, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 12164, 18428, 27267, 27267, 18427, 12186, 27267, 27267, 18420, 26295, 19591,
  19607, 19619, 19635, 19648, 12169, 12681, 20366, 15861, 27267, 11512, 27267, 19664, 26777, 27267, 20371, 26194, 15991,
  19710, 19752, 12208, 12262, 11001, 22432, 13684, 11518, 12469, 22236, 12984, 12234, 17879, 19768, 19813, 26063, 10469,
  19849, 12255, 19879, 19916, 27267, 27267, 20614, 10334, 21213, 21057, 21057, 19934, 19959, 20003, 13365, 19156, 21971,
  24878, 25300, 26103, 20019, 10337, 14908, 21057, 17526, 13643, 20040, 23595, 16675, 27267, 27267, 27267, 10334, 21056,
  21057, 11136, 13365, 19899, 21971, 27267, 24137, 20332, 21057, 13729, 26870, 12932, 16287, 20329, 21057, 13365, 21967,
  24138, 21057, 13728, 21967, 23067, 16496, 20059, 22985, 15825, 16949, 13725, 10508, 23602, 19735, 19736, 13091, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 12164, 9295,
  27267, 27267, 20141, 20109, 27267, 20131, 12192, 20161, 9399, 20196, 20208, 20224, 20237, 12169, 20253, 12284, 15861,
  20400, 11512, 23674, 20279, 20348, 20387, 26510, 20434, 20473, 20489, 20553, 12208, 12262, 20569, 27025, 27267, 20589,
  20610, 22236, 19320, 12234, 21057, 20796, 18706, 20631, 13365, 24117, 12255, 20662, 24998, 27267, 10756, 25493, 10334,
  21213, 20686, 21057, 21057, 20710, 13365, 13365, 19156, 17779, 27267, 27267, 13867, 20741, 20293, 20764, 21916, 20788,
  22268, 13365, 20812, 16675, 9363, 20841, 12087, 16043, 21006, 16635, 13285, 20880, 20906, 13704, 20926, 20961, 10405,
  19797, 20983, 26870, 26796, 23353, 18338, 21022, 21074, 15145, 14381, 21137, 23276, 21186, 21153, 21179, 18885, 21202,
  21570, 14898, 21239, 10508, 23602, 17087, 21255, 23334, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 12164, 27267, 27267, 27267, 21644, 12186, 12986, 12635, 15389, 21314,
  21330, 21346, 21358, 21374, 21387, 21403, 21419, 21435, 15861, 27267, 12371, 26728, 26740, 21456, 15704, 21477, 21493,
  23099, 21509, 21525, 12208, 12262, 27267, 22432, 20359, 21541, 12469, 24925, 12984, 12234, 21586, 16108, 21616, 13366,
  12344, 14308, 21668, 12278, 11662, 14828, 27267, 21691, 17980, 21715, 23071, 13467, 21057, 12300, 10981, 13365, 21741,
  21971, 13750, 21757, 27267, 20615, 10337, 21055, 21775, 21057, 13643, 17051, 13365, 16675, 27267, 15397, 21799, 10334,
  21056, 21057, 11136, 13365, 19899, 21971, 12591, 24137, 19445, 13304, 21817, 26870, 21833, 16287, 21853, 21057, 21887,
  21967, 24138, 21057, 13728, 24564, 21908, 21932, 22024, 21963, 21988, 22017, 13725, 10508, 23602, 21267, 22040, 16254,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 12164,
  9941, 27267, 27267, 27267, 12186, 27267, 12625, 22152, 22079, 22115, 22144, 22485, 22168, 22181, 12169, 12681, 21972,
  15861, 27267, 11512, 27267, 20614, 10338, 27267, 22197, 21057, 10504, 19147, 10377, 12208, 12262, 27250, 22432, 27267,
  22213, 12469, 22234, 21461, 22253, 17518, 26202, 24507, 25846, 22291, 19973, 22309, 12278, 27267, 27267, 27267, 20614,
  10334, 21213, 21057, 21290, 15117, 12300, 13365, 17467, 19156, 21971, 27267, 25084, 9343, 17307, 9838, 18911, 22325,
  21057, 13643, 23585, 13365, 16675, 14810, 27267, 27267, 10334, 13259, 21057, 22349, 12305, 19899, 21971, 27267, 24137,
  20332, 21057, 13729, 26870, 27267, 16287, 20329, 21057, 13365, 21967, 24138, 21057, 13728, 21967, 23067, 18281, 22373,
  10476, 15825, 16949, 13725, 10508, 23602, 19735, 19736, 13091, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 12164, 27267, 27267, 27267, 27267, 12186, 27267, 27267, 27267,
  26295, 13223, 17688, 21556, 19725, 14666, 12169, 12681, 27267, 15861, 27267, 11512, 27267, 24728, 18467, 18474, 22406,
  25544, 25533, 25037, 14437, 12208, 12262, 27267, 22432, 27267, 11518, 12469, 22236, 12984, 12234, 21057, 25637, 18706,
  13365, 13365, 24117, 12255, 12278, 27267, 27267, 27267, 20614, 10334, 21213, 21057, 21057, 21057, 12300, 13365, 13365,
  19156, 21971, 27267, 27267, 27267, 20615, 10337, 21055, 21057, 21057, 13643, 13365, 13365, 16675, 27267, 27267, 27267,
  10334, 21056, 21057, 11136, 13365, 19899, 21971, 27267, 24137, 20332, 21057, 13729, 26870, 27267, 16287, 20329, 21057,
  13365, 21967, 24138, 14870, 22052, 21967, 23067, 16496, 15821, 16499, 15825, 16949, 13725, 10508, 23602, 19735, 19736,
  13091, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  12164, 27267, 27267, 27267, 24208, 22422, 24206, 10313, 27267, 22455, 22470, 22501, 22513, 22529, 22542, 22558, 25732,
  27267, 22592, 10162, 22626, 22699, 22648, 22688, 22610, 22732, 23930, 21279, 22748, 22773, 22789, 22815, 27267, 25742,
  19236, 22852, 22871, 25331, 12984, 12234, 22891, 19453, 18706, 10359, 19833, 24117, 22937, 12278, 27267, 22716, 20670,
  9830, 24739, 21213, 17715, 14989, 22953, 22977, 14484, 20043, 23001, 13677, 21837, 23017, 27267, 20967, 23043, 21055,
  23087, 25027, 17042, 19417, 23115, 23136, 11811, 27267, 25119, 10334, 23152, 23178, 21223, 13365, 23204, 25579, 11819,
  24137, 20332, 25828, 13729, 26892, 27267, 16287, 24439, 21057, 23230, 21114, 24138, 21057, 13728, 21967, 23067, 16496,
  23248, 26690, 15825, 25910, 22382, 13253, 23602, 19735, 23264, 23292, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 12164, 23350, 27267, 27267, 14552, 23369, 27267, 22099,
  23385, 23424, 23439, 23470, 23482, 23498, 23511, 12169, 14520, 27267, 15861, 27267, 23527, 13160, 24299, 19340, 16057,
  23549, 23565, 21034, 23618, 23645, 23661, 21675, 15317, 22432, 27267, 11518, 27199, 23708, 17321, 23732, 23920, 20694,
  18706, 23769, 23802, 24117, 23821, 23837, 27267, 23888, 27267, 20614, 10334, 23910, 21057, 21057, 21057, 12300, 13365,
  13365, 19156, 21971, 20180, 23946, 18022, 20615, 23965, 23989, 16880, 13922, 24015, 25961, 21102, 16675, 27267, 24037,
  27267, 9760, 25645, 21057, 24056, 24021, 24080, 15045, 12005, 14713, 20332, 14255, 24097, 21630, 27267, 24133, 20329,
  21057, 13365, 14282, 24154, 23753, 13728, 24185, 23067, 16496, 15642, 24224, 15825, 22063, 22914, 17144, 25063, 19523,
  19736, 13091, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 12164, 24248, 27267, 27267, 10629, 12186, 27267, 24270, 24269, 24286, 20864, 24315, 24328, 24344, 24357, 24373,
  13779, 10244, 26619, 20945, 24416, 24465, 24483, 24523, 24530, 22218, 16388, 25206, 24553, 24591, 24607, 24659, 17898,
  24716, 27267, 11518, 24766, 19048, 12452, 24792, 23999, 21783, 18706, 24818, 24837, 24117, 12255, 24867, 24894, 9356,
  27267, 24911, 24949, 25014, 10608, 21057, 25254, 25053, 21088, 23232, 19156, 18785, 25079, 11802, 20307, 18458, 25100,
  10598, 14174, 21871, 16567, 17475, 24064, 16675, 15439, 18073, 25135, 25156, 25194, 25234, 16142, 20504, 21892, 25270,
  27267, 25316, 15979, 15734, 25352, 20890, 21801, 16287, 25503, 25552, 25381, 25404, 20115, 16870, 25452, 25481, 25519,
  25568, 15821, 16499, 15825, 16949, 13725, 25602, 22390, 25618, 19736, 22001, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 12164, 27267, 27267, 27267, 27267, 12186, 27267,
  24400, 27267, 26295, 16605, 25661, 25673, 25689, 25702, 12169, 12681, 27267, 15861, 25718, 11512, 27267, 20614, 10338,
  27267, 10800, 21057, 21046, 25758, 10377, 12208, 12262, 25774, 22432, 27267, 25791, 12938, 22236, 12984, 25818, 21057,
  13185, 18706, 25862, 13365, 13577, 25883, 12278, 22569, 27267, 26630, 22875, 15428, 21213, 17752, 25244, 22904, 12300,
  25899, 25926, 19156, 21971, 12644, 27267, 27267, 18328, 10337, 19533, 21057, 21057, 13643, 25959, 13365, 16675, 11971,
  27267, 27267, 10334, 21056, 21057, 11136, 13365, 19899, 18747, 18566, 24137, 20332, 22333, 25977, 26870, 27267, 16287,
  20329, 21057, 13365, 21967, 24138, 21057, 13728, 21967, 25998, 26025, 15821, 16499, 15825, 16949, 13725, 16954, 16721,
  19735, 15904, 26048, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 12164, 27267, 27267, 27267, 27267, 12186, 13612, 27267, 13886, 26084, 9226, 26119, 23454, 26153, 26166,
  12169, 12681, 27267, 15861, 27267, 11512, 27267, 20614, 10338, 27267, 10800, 16378, 16367, 21163, 10377, 12208, 12262,
  27267, 22432, 27267, 11518, 16821, 22236, 26944, 26182, 21057, 25637, 18706, 16469, 13365, 24117, 12255, 12278, 27267,
  11744, 27267, 20614, 26218, 21213, 14945, 21057, 21057, 12300, 25867, 13365, 22757, 26248, 27267, 27267, 27267, 20615,
  10337, 21055, 21057, 21057, 13643, 13365, 13365, 16675, 27267, 27267, 27267, 10334, 21056, 21057, 11136, 13365, 19899,
  14374, 27267, 24137, 20332, 21057, 13729, 26870, 27267, 16287, 20329, 21057, 13365, 21967, 24138, 21057, 13728, 15100,
  23067, 16496, 15821, 16499, 15825, 16949, 13725, 10508, 23602, 19735, 19736, 13091, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 12164, 27267, 27267, 27267, 9515, 12186,
  27267, 22829, 11684, 26265, 26280, 26325, 26337, 26353, 26366, 12169, 12681, 27267, 15861, 27267, 11512, 27267, 20614,
  10338, 27267, 10800, 21057, 10504, 10434, 18625, 12208, 12262, 27267, 22432, 27267, 11518, 12469, 22236, 12984, 12234,
  21057, 25637, 18706, 13365, 13365, 24117, 12255, 12278, 27267, 27267, 27267, 20614, 10334, 21213, 21057, 21057, 21057,
  12300, 13365, 13365, 19156, 21971, 27267, 27267, 26382, 20615, 10337, 21055, 21057, 21057, 13643, 13365, 13365, 16675,
  27267, 26400, 27267, 10334, 14418, 21057, 26681, 16184, 10443, 21971, 27267, 24137, 20332, 21057, 13729, 26870, 27267,
  16287, 20329, 21057, 13365, 21967, 24138, 21057, 13728, 21967, 23067, 16496, 15821, 16499, 15825, 16949, 13725, 10508,
  23602, 19735, 19736, 13091, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 12485, 27267, 27267, 27267, 27267, 12186, 27267, 27267, 27267, 26295, 13223, 17688, 24169, 26423,
  26436, 12169, 12681, 27267, 23692, 27267, 11512, 27267, 24700, 10338, 26452, 26461, 16860, 16849, 21725, 10377, 12208,
  12262, 27267, 22432, 9257, 26477, 12469, 22236, 12984, 12234, 21057, 25637, 24802, 13365, 13365, 26496, 26526, 26542,
  27267, 27267, 27267, 20614, 10334, 11385, 21057, 21057, 21057, 26565, 13365, 13365, 16439, 21971, 27267, 27267, 27267,
  20615, 10337, 21055, 21057, 21057, 13643, 13365, 13365, 16675, 21652, 27267, 27267, 10334, 21056, 21057, 11136, 13365,
  19899, 21971, 27267, 24137, 20332, 21057, 13729, 26870, 27267, 16287, 20329, 21057, 13365, 21967, 24138, 21057, 13728,
  21967, 23067, 16496, 15821, 16499, 15825, 16949, 13725, 10508, 23602, 19735, 19736, 13091, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 12164, 27267, 27267, 27267, 27267,
  12186, 27267, 27267, 27267, 26295, 13223, 17688, 21556, 19725, 14666, 12169, 12681, 26586, 15861, 27267, 13510, 27267,
  20614, 10338, 27267, 10800, 21057, 19780, 16712, 11144, 12208, 26605, 27267, 26646, 27267, 11518, 12469, 14120, 12984,
  12234, 21057, 26670, 18706, 13365, 13365, 26714, 12255, 26756, 27267, 26793, 27267, 20614, 26812, 21213, 21057, 26839,
  21057, 12300, 13365, 26866, 19156, 21971, 9165, 27267, 27267, 17961, 10337, 19559, 21057, 17931, 13643, 26886, 13365,
  16675, 27267, 27267, 27267, 10334, 21056, 14156, 13447, 13365, 16191, 21971, 27267, 24137, 20332, 21057, 13729, 26870,
  26908, 24691, 20329, 16418, 19357, 21967, 24138, 21057, 13728, 21967, 23067, 16496, 15821, 16499, 15825, 16949, 13725,
  10508, 23602, 19735, 19736, 13091, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 12164, 27267, 27267, 27267, 27267, 12186, 27267, 27267, 27267, 26295, 26931, 17688, 21556,
  19725, 14666, 12169, 12681, 27267, 15861, 27267, 11512, 27267, 20614, 10338, 27267, 10800, 21057, 10504, 19147, 10377,
  12208, 12262, 27267, 22432, 27267, 11518, 12469, 22236, 12984, 12234, 21057, 25637, 18706, 13365, 13365, 24117, 12255,
  12278, 27267, 27267, 27267, 20614, 10334, 21213, 21057, 21057, 21057, 12300, 13365, 13365, 19156, 21971, 27267, 27267,
  27267, 20615, 10337, 21055, 21057, 21057, 13643, 13365, 13365, 16675, 27267, 27267, 27267, 10334, 21056, 21057, 11136,
  13365, 19899, 21971, 27267, 24137, 20332, 21057, 13729, 26870, 27267, 16287, 20329, 21057, 13365, 21967, 24138, 21057,
  13728, 21967, 23067, 16496, 15821, 16499, 15825, 16949, 13725, 10508, 23602, 19735, 19736, 13091, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 8915, 26967, 27267, 27267,
  26384, 26986, 24634, 26996, 24643, 27012, 27041, 26970, 27048, 27064, 27087, 27267, 12681, 27267, 15861, 27267, 18228,
  27267, 27267, 27267, 27267, 10800, 27267, 27267, 26129, 9200, 8935, 27267, 27267, 22432, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 8915, 27267, 27267, 27267, 27267, 27266, 27267, 11977, 27267, 26295, 25140, 27123,
  27135, 27267, 20263, 27267, 12681, 27267, 15861, 27267, 27267, 27267, 27267, 27267, 15049, 10800, 27267, 27267, 26129,
  9200, 8935, 27267, 27267, 22432, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 8915, 27267, 27267,
  27267, 26249, 27266, 27267, 27267, 27267, 27151, 27186, 27215, 27220, 27267, 27236, 27267, 12681, 27267, 15861, 27267,
  10670, 27267, 27267, 27267, 27267, 10800, 27267, 27267, 26129, 9200, 8935, 27267, 27267, 22432, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 8915, 27267, 27267, 27267, 27267, 27266, 27267, 27267, 27267, 26295, 27267,
  27267, 27267, 27267, 9873, 12169, 12681, 27267, 15861, 27267, 27267, 27267, 20614, 10338, 27267, 10800, 21057, 10504,
  19147, 10377, 10260, 27267, 27267, 22432, 27267, 27267, 12469, 22236, 12984, 10510, 21057, 25637, 17011, 13365, 13365,
  19900, 24200, 27267, 27267, 27267, 27267, 20614, 10334, 15107, 21057, 21057, 21057, 19894, 13365, 13365, 20910, 21971,
  27267, 27267, 27267, 20615, 10337, 21055, 21057, 21057, 13643, 13365, 13365, 16675, 27267, 27267, 27267, 10334, 21056,
  21057, 11136, 13365, 19899, 21971, 27267, 24137, 20332, 21057, 13729, 26870, 27267, 16287, 20329, 21057, 13365, 21967,
  24138, 21057, 13728, 21967, 23067, 16496, 15821, 16499, 15825, 16949, 13725, 10508, 23602, 19735, 19736, 13091, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 14207,
  27267, 27267, 27267, 27286, 27267, 27267, 27267, 27284, 18505, 18520, 18532, 14207, 17367, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267, 27267,
  27267, 27267, 27267, 27267, 27267, 27267, 27267, 297, 51453, 51453, 51453, 0, 49404, 51453, 51453, 51453, 51453,
  51453, 51453, 51453, 51453, 51453, 51453, 0, 51453, 51453, 51453, 51453, 51453, 51453, 51453, 36864, 38912, 51453,
  51453, 51453, 51453, 51453, 51453, 34816, 51453, 51453, 51453, 49404, 49404, 51453, 51453, 51453, 51453, 51453, 51453,
  51453, 51453, 51453, 51453, 51453, 51453, 51453, 51453, 51453, 51453, 51453, 51453, 51453, 51453, 51453, 51453, 51453,
  0, 51453, 51453, 51453, 51453, 51453, 51453, 51453, 51453, 51453, 51453, 0, 51453, 51453, 51453, 51453, 51453, 51453,
  51453, 51453, 51453, 51453, 1, 8194, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 256, 0, 0, 0, 481, 0, 483, 484, 0, 0,
  0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127354, 0, 127354, 127354, 0, 0, 127354, 376, 0, 55672, 376, 55672, 376, 376, 376,
  376, 55672, 376, 376, 376, 376, 55672, 55672, 55672, 376, 0, 55672, 55672, 376, 55672, 55672, 55672, 55672, 55672,
  55672, 55672, 0, 0, 0, 0, 570, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 257, 0, 0, 0, 481, 736, 483, 484, 0, 0, 736, 4, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 131072, 0, 0, 0, 0, 0, 0, 262, 0, 265, 59392, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 280, 281,
  282, 283, 297, 0, 262, 262, 265, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 59718, 38912, 0, 0, 0,
  0, 0, 0, 34816, 0, 0, 0, 0, 0, 0, 65536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65536, 0, 0, 0, 65536, 0, 0, 0, 455, 415,
  415, 455, 415, 455, 415, 415, 415, 415, 415, 415, 480, 483, 483, 483, 483, 483, 483, 483, 415, 415, 483, 1, 8194, 3,
  4, 0, 0, 0, 0, 0, 0, 0, 124928, 0, 0, 0, 0, 0, 0, 0, 0, 0, 481, 0, 27361, 484, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  221184, 0, 0, 0, 0, 0, 0, 415, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 415, 0, 483, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 480, 0, 61440, 61440, 0, 61440, 0, 0, 0, 0, 61440, 0, 0, 0, 0, 0, 0, 0, 45415, 45415, 0, 45415, 0, 0,
  45415, 45415, 308, 61440, 0, 0, 0, 0, 61440, 0, 0, 61440, 61440, 61440, 61440, 61440, 61440, 61440, 0, 0, 0, 0, 791,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 803, 0, 0, 73728, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 258, 0, 0, 0, 854, 856, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 259, 260, 0, 0, 973, 975, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 262, 0, 0, 65536, 0,
  0, 0, 36864, 38912, 65536, 0, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 0, 0, 251904, 0, 0, 0, 0, 0, 1224, 0, 0, 0, 0, 0, 0,
  301056, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1339, 0, 0, 1342, 0, 313344, 0, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 0,
  0, 65536, 1, 8194, 3, 4, 0, 0, 0, 0, 71680, 243, 0, 0, 0, 0, 0, 0, 0, 45425, 45425, 383, 45425, 393, 383, 45425,
  45425, 383, 0, 67584, 0, 0, 36864, 38912, 0, 67584, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 0, 0, 327680, 0, 0, 0, 45415,
  45415, 45415, 45415, 45415, 0, 0, 0, 16801, 16801, 16801, 16801, 16801, 16801, 17870, 16801, 16801, 16801, 0, 0, 0, 0,
  67584, 0, 0, 0, 0, 67584, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67584, 0, 0, 0, 1, 8194, 3, 4, 0, 0, 734, 0, 738, 739, 0,
  0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 262, 0, 263, 0, 265, 0, 266, 0, 263, 0, 266, 69632, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 295, 296, 0, 0, 297, 0, 263, 263, 266, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 267, 268, 0, 0, 0, 0, 0, 0, 0, 36864,
  69962, 0, 0, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 0, 0, 578071, 297, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86016, 0, 86016,
  86016, 456, 416, 416, 456, 416, 456, 416, 416, 416, 416, 416, 416, 481, 484, 484, 484, 484, 484, 484, 484, 416, 416,
  484, 1, 8194, 3, 4, 0, 0, 0, 65536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 358400, 0, 0, 0, 0, 0, 0, 27359, 0, 483, 27364, 0, 0,
  0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 273, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 484, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 307, 0, 0,
  0, 298, 254, 254, 254, 0, 0, 71934, 254, 254, 254, 254, 302, 254, 254, 254, 254, 0, 0, 254, 254, 71934, 254, 254, 254,
  254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 71934, 254, 254, 71934, 254, 254, 36864, 38912, 254,
  254, 254, 254, 254, 254, 34816, 254, 254, 254, 71934, 254, 254, 0, 71934, 71934, 71934, 71934, 71934, 71934, 71934,
  71934, 71934, 71934, 0, 0, 0, 0, 820, 0, 0, 0, 0, 0, 45415, 45879, 45415, 45415, 45415, 45415, 45415, 45415, 45415,
  46434, 45415, 45415, 45415, 0, 0, 0, 1382, 0, 254, 71934, 71934, 254, 71934, 254, 254, 254, 254, 71934, 254, 254, 254,
  254, 254, 254, 254, 0, 254, 254, 254, 71934, 254, 254, 254, 71934, 0, 0, 254, 254, 254, 71934, 254, 254, 71934, 71934,
  71934, 71934, 71680, 71934, 71982, 71982, 71982, 71982, 71982, 71982, 71982, 71934, 71934, 71934, 1, 8194, 3, 4, 0, 0,
  0, 0, 0, 980, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 0, 1245, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 77824, 36864, 38912, 0, 0, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 0, 242, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 8194, 3, 4,
  41199, 41199, 0, 0, 0, 0, 77824, 77824, 77824, 0, 0, 77824, 0, 0, 77824, 77824, 0, 0, 0, 0, 77824, 0, 77824, 77824,
  77824, 0, 8194, 3, 4, 0, 0, 77824, 0, 0, 77824, 0, 77824, 77824, 77824, 77824, 0, 77824, 77824, 77824, 77824, 77824,
  77824, 77824, 77824, 77824, 77824, 0, 0, 63488, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 261, 0, 0, 0, 79872, 0,
  79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 81920, 79872, 79872, 79872, 81920, 0, 79872, 79872,
  81920, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 0, 14793, 0, 0, 14793, 0, 14793, 0, 79872, 0, 0, 0, 79872, 0,
  14793, 14793, 14793, 14793, 14793, 14793, 14793, 79872, 79872, 14793, 1, 8194, 3, 4, 0, 0, 0, 0, 83968, 83968, 83968,
  83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 1, 8194, 3, 4, 0, 0, 83968, 83968, 83968,
  83968, 0, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 0, 0, 0, 0, 1016, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1022, 0, 0, 0, 0, 0, 0, 0, 86016, 36864, 38912, 0, 0, 0, 0, 0, 0, 34816, 86016, 86016, 0, 86016, 86016,
  86016, 86016, 86016, 0, 0, 86016, 0, 86016, 86016, 0, 0, 86016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 263, 0, 0, 0,
  266, 0, 86016, 0, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 0,
  86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 0, 1, 236, 3, 4, 0, 0, 0, 0, 0, 0, 244, 0, 0, 0,
  0, 0, 0, 547, 0, 0, 550, 0, 0, 0, 0, 555, 0, 0, 0, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 88064,
  88064, 88064, 88064, 88064, 88064, 1, 0, 3, 4, 41199, 41199, 88064, 88064, 88064, 88064, 0, 88064, 88064, 88064,
  88064, 88064, 88064, 88064, 88064, 88064, 88064, 0, 0, 0, 0, 1193, 0, 0, 0, 1197, 0, 0, 0, 0, 0, 0, 0, 766, 0, 0,
  45415, 45415, 45415, 45415, 45883, 45415, 47345, 0, 0, 491, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 524, 0, 0, 0, 481, 0,
  483, 484, 0, 16842, 0, 4, 41199, 0, 0, 0, 0, 0, 0, 0, 0, 321536, 0, 0, 0, 225280, 0, 0, 0, 0, 1041, 0, 0, 0, 0, 45415,
  45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45892, 45415, 45415, 45415, 45415, 45415, 1189, 0, 0,
  0, 0, 1194, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 291, 0, 0, 0, 0, 291, 0, 0, 1230, 0, 0, 45415, 45415, 45415, 45415, 45415,
  45415, 45415, 45415, 45415, 45415, 45415, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16842, 16842, 16842, 16842, 17806, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 242122, 16842, 16842, 17887, 16801,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16801, 480, 0, 0, 0,
  1599, 0, 0, 0, 0, 0, 0, 45415, 45415, 45415, 45415, 45415, 0, 0, 0, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  17871, 16801, 16801, 17989, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17994, 16801,
  16801, 16801, 16801, 17062, 16801, 455, 456, 0, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17818, 16842, 16842,
  16842, 16801, 0, 0, 0, 0, 16801, 16801, 16801, 18001, 16842, 16842, 16842, 16842, 16842, 18004, 16842, 16842, 16842,
  16842, 16842, 16842, 17330, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 0, 0, 0, 0, 0, 0, 1691, 0,
  0, 0, 45415, 16801, 16801, 16801, 18024, 18025, 16801, 16801, 18028, 16801, 16801, 16801, 16801, 0, 0, 0, 0, 0, 0, 0,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 18061, 16842, 16842, 16842, 16842, 16842,
  18067, 16842, 16842, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1447, 0, 0, 0, 0, 0, 18077, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 18087, 16842, 16842, 16842, 16842, 16842, 0, 0, 0, 1631, 0, 0, 0, 0, 0, 0, 0, 767, 0, 0,
  0, 770, 0, 0, 0, 0, 16842, 18133, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 0, 0, 0, 0, 16801, 16801, 16801,
  16801, 16801, 16801, 192929, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17470, 16801, 16801, 16801, 16801,
  16801, 16801, 17476, 16801, 16801, 297, 0, 0, 0, 300, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 294, 0, 0, 0, 0, 92645, 92645,
  92645, 92645, 92645, 92645, 92645, 0, 0, 92645, 1, 8194, 3, 4, 41199, 41199, 481, 0, 483, 484, 94208, 16842, 0, 4,
  41199, 0, 0, 0, 0, 0, 0, 0, 0, 421888, 0, 0, 0, 0, 0, 0, 0, 0, 578071, 578071, 297, 0, 0, 0, 0, 0, 297, 0, 0, 0, 0,
  255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96640, 0, 96640, 0, 0, 0, 0, 96640, 0, 0, 0, 0, 96640, 96640, 96640, 0, 0,
  96640, 96640, 0, 96640, 96640, 96640, 96640, 96640, 96640, 96640, 0, 96640, 96640, 96640, 96640, 96640, 96640, 96640,
  96640, 96640, 0, 1, 8194, 3, 4, 0, 0, 0, 0, 0, 1030, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59392, 0, 0, 0, 0, 0, 0, 0, 0,
  116736, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 553, 0, 0, 0, 0, 20744, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 415,
  416, 297, 0, 0, 0, 20781, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 300, 0, 0, 0, 0, 20781, 20781, 20781, 20781, 20781, 20781,
  20781, 0, 0, 20781, 1, 8194, 3, 4, 41199, 41199, 481, 0, 483, 484, 23065, 16842, 0, 4, 41199, 0, 0, 0, 0, 0, 0, 0, 0,
  578072, 75776, 578072, 0, 0, 75776, 0, 0, 987, 0, 989, 0, 991, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 456, 0, 0, 0, 0, 0,
  802, 1028, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 265, 0, 0, 0, 0, 1122, 0, 1124, 0, 15253, 16842, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17113, 16842, 16801, 480, 0, 0, 0, 1028, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1073, 1249, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 17789, 16801, 1122, 1287, 1124, 1288, 16842, 16842, 16842, 16842, 16842, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 17531, 16842, 16842, 16842, 1185, 1186, 1187, 1188, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 771, 0, 0, 0, 1, 8194, 3, 4, 41199, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 480, 0, 0, 0, 0, 299, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 733, 268, 268, 268, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 266, 0, 0, 0, 0, 0, 0, 267, 268, 0,
  0, 267, 268, 0, 267, 0, 0, 0, 267, 0, 0, 0, 0, 0, 1032, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415,
  45415, 362855, 0, 0, 0, 0, 1248, 490, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75776, 0, 0, 0, 0, 0, 1071, 0, 1073, 0,
  17242, 16801, 16801, 16801, 16801, 16801, 16801, 0, 0, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842,
  17110, 16842, 16842, 16842, 16842, 16801, 480, 629, 629, 629, 629, 0, 0, 0, 0, 0, 0, 0, 629, 629, 629, 629, 629, 629,
  629, 629, 629, 629, 686, 629, 629, 629, 629, 629, 629, 455, 456, 685, 686, 686, 686, 686, 686, 686, 686, 686, 686,
  686, 629, 629, 0, 0, 629, 0, 481, 0, 483, 484, 0, 686, 0, 4, 41199, 0, 0, 0, 0, 0, 0, 0, 262, 0, 0, 0, 265, 0, 0, 0,
  0, 629, 0, 0, 629, 0, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 0, 629, 629, 629, 629, 629, 629, 629,
  629, 629, 629, 686, 686, 686, 686, 686, 686, 686, 686, 686, 686, 686, 686, 686, 686, 629, 629, 629, 629, 629, 629,
  629, 629, 686, 0, 0, 686, 0, 0, 686, 686, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 802, 686, 686, 686, 686, 686,
  686, 686, 686, 686, 686, 686, 686, 686, 686, 686, 686, 629, 480, 629, 0, 0, 0, 0, 686, 686, 686, 686, 686, 686, 686,
  686, 686, 686, 686, 686, 0, 0, 0, 0, 0, 0, 0, 629, 629, 629, 629, 629, 629, 0, 0, 686, 686, 686, 686, 686, 686, 686,
  686, 686, 0, 0, 0, 0, 629, 629, 629, 686, 686, 686, 686, 686, 686, 686, 686, 686, 686, 686, 686, 629, 686, 0, 0, 0, 0,
  0, 1072, 855, 1074, 857, 17242, 16801, 16801, 16801, 16801, 16801, 16801, 17659, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 0, 0, 0, 0, 15253, 17242, 16842, 16842, 686, 686, 686, 686, 686, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 798, 0, 0, 0, 0, 686, 686, 686, 686, 686, 0, 0, 0, 0, 0, 0, 0, 629, 629, 629, 629, 629, 629, 629, 629,
  629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 629, 686, 686, 686, 686, 686, 686, 0, 0, 0, 629, 629, 629, 629, 686,
  686, 686, 686, 0, 629, 629, 686, 686, 629, 686, 629, 686, 629, 686, 629, 686, 629, 0, 0, 0, 0, 0, 0, 0, 0, 686, 0, 0,
  0, 0, 0, 0, 561, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1344, 297, 108544, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  108544, 0, 0, 108544, 108544, 108544, 1, 8194, 3, 4, 0, 0, 0, 0, 0, 108544, 36864, 38912, 0, 0, 0, 0, 0, 0, 34816, 0,
  0, 0, 0, 0, 247, 274, 275, 276, 277, 0, 0, 0, 0, 0, 0, 0, 143360, 143360, 143360, 1, 8194, 3, 1061352, 0, 0, 0,
  108544, 0, 0, 108544, 108544, 108544, 0, 0, 108544, 0, 108544, 108544, 0, 0, 108544, 108544, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1010, 0, 0, 0, 0, 108544, 0, 108544, 108544, 108544, 108544, 108544, 108544, 108544, 108544, 108544, 108544,
  108544, 108544, 108544, 108544, 0, 108544, 108544, 108544, 108544, 108544, 108544, 108544, 108544, 108544, 108544, 0,
  28672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1013, 0, 263, 0, 265, 0, 266, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 295,
  0, 0, 0, 0, 295, 0, 455, 0, 456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 969, 971, 0, 0, 0, 0, 0, 43008, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 415, 628, 262, 263, 265, 266, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1023, 0, 0, 1026, 110969, 0,
  110969, 110969, 110969, 110969, 110969, 110969, 110969, 110969, 110969, 110969, 110969, 110969, 110969, 110969, 0,
  110969, 110969, 110969, 110969, 110969, 110969, 110969, 110969, 110969, 110969, 0, 111074, 111074, 111074, 111074,
  111074, 111074, 111074, 110969, 110969, 111079, 1, 8194, 3, 4, 0, 0, 0, 0, 0, 1208, 0, 1210, 282624, 0, 0, 0, 0, 0, 0,
  0, 1337, 0, 0, 0, 0, 0, 0, 0, 0, 1456, 0, 0, 0, 0, 0, 0, 0, 481, 0, 483, 484, 0, 0, 118784, 4, 0, 0, 0, 0, 0, 0, 0, 0,
  297, 297, 297, 0, 0, 0, 539, 0, 124928, 0, 124928, 124928, 124928, 124928, 124928, 124928, 124928, 124928, 124928,
  124928, 124928, 124928, 124928, 124928, 0, 124928, 124928, 124928, 124928, 124928, 124928, 124928, 124928, 124928,
  124928, 0, 481, 0, 483, 484, 0, 0, 120832, 4, 0, 0, 0, 0, 0, 0, 0, 0, 297, 297, 297, 0, 0, 73728, 0, 0, 297, 0, 0, 0,
  0, 126976, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127354, 0, 127354, 127354, 127354, 127354, 127354, 127354, 127354, 127354,
  127354, 127354, 127354, 127354, 127354, 127354, 0, 127354, 127354, 127354, 127354, 127354, 127354, 127354, 127354,
  127354, 127354, 0, 0, 0, 0, 0, 135168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100352, 0, 0, 0, 0, 1334, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 415744, 0, 415744, 0, 0, 0, 481, 0, 483, 484, 0, 0, 0, 0, 0, 0, 90112, 145408, 0, 0, 0, 0, 0, 0, 1455, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 913, 915, 0, 0, 0, 0, 0, 0, 0, 0, 133120, 0, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 0, 0, 297, 297, 297, 0,
  538, 0, 0, 0, 0, 133120, 0, 0, 0, 133120, 0, 0, 0, 0, 1, 8194, 534765, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 245, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 122880, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1368, 0, 0, 1371, 481, 122880, 483, 484, 0, 0, 122880,
  4, 0, 0, 0, 0, 0, 0, 0, 0, 297, 297, 297, 0, 23065, 0, 0, 0, 137216, 137216, 137216, 137216, 137216, 137216, 137216,
  0, 0, 137216, 1, 8194, 3, 4, 0, 0, 0, 0, 0, 1361, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 629, 629, 629, 629, 629, 629, 629, 1,
  8194, 3, 4, 41199, 47345, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 556, 297, 0, 0, 0, 0, 47345, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 313, 0, 0, 0, 0, 313, 481, 0, 483, 484, 0, 16842, 0, 4, 41199, 47846, 0, 0, 0, 0, 0, 0, 0, 86016, 86016,
  86016, 1, 8194, 3, 4, 0, 0, 0, 855, 857, 0, 17242, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 17488, 16801, 16801, 16801, 16801, 0, 974, 976, 0, 16842, 47846, 0, 0, 0, 0, 0, 0, 0, 0, 0, 752, 754, 0,
  0, 756, 758, 0, 0, 0, 754, 0, 756, 0, 758, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 523, 264192, 0, 0, 0, 0, 0, 914, 0, 916,
  15253, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17811, 16842, 16842, 16842,
  0, 1249, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17953,
  16801, 16801, 0, 1287, 0, 1288, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17336,
  16842, 16842, 16842, 16842, 0, 0, 1028, 0, 0, 0, 0, 0, 0, 0, 1034, 0, 0, 0, 0, 0, 0, 561, 0, 0, 0, 0, 0, 0, 513, 565,
  566, 0, 0, 0, 1028, 0, 0, 0, 0, 0, 1222, 0, 0, 0, 0, 0, 0, 0, 124928, 124928, 124928, 1, 8194, 3, 4, 0, 0, 481, 0,
  483, 484, 0, 16842, 0, 4, 239, 47846, 0, 0, 0, 0, 0, 0, 0, 127354, 127354, 127354, 1, 8194, 0, 4, 0, 0, 0, 343, 0, 0,
  0, 0, 0, 45415, 45415, 0, 45415, 0, 0, 45415, 45415, 0, 0, 0, 0, 848, 0, 0, 0, 0, 848, 0, 0, 0, 783, 1462, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 45415, 45415, 45415, 45415, 45415, 45415, 1, 8194, 3, 4, 41200, 47345, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1021, 0, 0, 0, 0, 0, 0, 0, 141312, 0, 141312, 0, 0, 0, 0, 141312, 0, 0, 0, 0, 0, 141312, 141312, 141312, 0, 0, 141312,
  141312, 0, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 0, 0, 0, 0, 1346, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  79872, 0, 0, 0, 79872, 0, 114688, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 625, 416, 1, 8194, 3, 238, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 246, 0, 0, 0, 0, 1454, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141312, 0, 0, 0, 141312, 0, 0, 0, 143360,
  36864, 38912, 0, 0, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 0, 261, 0, 0, 0, 261, 0, 0, 0, 0, 0, 0, 287, 289, 314, 0, 0, 0, 0,
  0, 0, 0, 1196, 0, 0, 0, 0, 0, 0, 0, 0, 67584, 67584, 67584, 67584, 0, 0, 0, 0, 0, 0, 0, 0, 143360, 143360, 143360, 0,
  0, 143360, 0, 0, 143360, 0, 0, 0, 0, 0, 262, 263, 0, 265, 266, 0, 0, 0, 0, 0, 0, 0, 16801, 16801, 18128, 18129, 16801,
  16801, 16801, 16801, 16801, 143360, 0, 0, 143360, 0, 143360, 143360, 143360, 143360, 0, 143360, 143360, 143360,
  143360, 143360, 143360, 143360, 143360, 143360, 143360, 0, 481, 0, 483, 484, 0, 0, 0, 1061352, 0, 0, 0, 0, 0, 0, 0, 0,
  297, 297, 297, 23065, 20781, 0, 0, 0, 0, 269, 0, 270, 0, 269, 269, 270, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 626,
  627, 0, 0, 269, 0, 269, 321, 269, 0, 0, 0, 0, 0, 0, 0, 325, 270, 0, 0, 0, 36864, 38912, 270, 0, 269, 0, 0, 0, 34816,
  0, 0, 0, 0, 0, 262, 263, 0, 265, 266, 0, 0, 0, 0, 512, 0, 0, 0, 0, 350, 350, 350, 358, 45416, 45416, 358, 45416, 385,
  358, 45416, 45416, 385, 358, 45416, 385, 358, 385, 358, 358, 358, 358, 385, 358, 358, 358, 358, 358, 358, 412, 16802,
  358, 358, 412, 358, 358, 358, 45416, 358, 45416, 439, 16828, 16843, 16828, 16828, 16843, 16828, 16843, 16828, 16828,
  16828, 16828, 16828, 16828, 16828, 16843, 16843, 16843, 16843, 16843, 16843, 16843, 16828, 16828, 16843, 1, 8194, 3,
  4, 41199, 41199, 47345, 0, 0, 0, 0, 0, 493, 494, 0, 0, 0, 0, 0, 0, 0, 0, 297, 297, 102400, 0, 0, 0, 0, 0, 0, 0, 0,
  559, 0, 0, 561, 0, 0, 0, 562, 0, 0, 512, 0, 0, 0, 0, 0, 1531, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45415, 45415, 45415,
  45882, 45415, 45415, 0, 0, 539, 493, 0, 0, 45415, 45415, 45645, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 0, 0,
  0, 521, 0, 0, 0, 0, 0, 45415, 45415, 45415, 45662, 45415, 45415, 45415, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 309,
  0, 0, 611, 0, 0, 0, 0, 0, 0, 525, 0, 0, 0, 0, 0, 0, 0, 278, 0, 0, 0, 0, 0, 0, 0, 0, 751, 753, 0, 0, 755, 757, 0, 0,
  611, 0, 0, 0, 0, 0, 611, 0, 0, 622, 623, 0, 0, 0, 415, 416, 16801, 17046, 16801, 16801, 539, 0, 0, 0, 562, 539, 0,
  16801, 16801, 17016, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17034, 16801, 17037, 16801, 17040, 16801, 16801,
  16801, 17058, 17037, 17040, 16801, 455, 456, 0, 16842, 16842, 16842, 17075, 16842, 16842, 16842, 0, 16801, 16801,
  16842, 16842, 16801, 16842, 16801, 16842, 16801, 16842, 16801, 16842, 481, 0, 483, 484, 0, 17099, 0, 4, 41199, 47846,
  0, 0, 0, 0, 0, 746, 0, 0, 0, 790, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1458, 0, 0, 0, 561, 0, 0, 0, 0, 0, 0, 808, 0, 0,
  0, 0, 0, 0, 0, 0, 311, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 581, 0, 0, 16801, 16801, 17275, 16801, 16801, 16801,
  16801, 16801, 822, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17281, 0, 16801, 16801, 17249, 16801, 16801,
  16801, 16801, 16842, 17342, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16801, 0, 970, 972, 0, 0, 0, 0, 0,
  1538, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45415, 45415, 0, 45415, 0, 0, 45415, 45415, 0, 0, 754, 0, 756, 0, 758, 0, 0, 0, 0, 0,
  0, 0, 1000, 0, 0, 0, 0, 0, 1740, 0, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 17778, 1069, 0, 0, 0, 0, 0, 855, 0, 857, 17242, 16801, 16801, 16801, 16801, 16801, 16801, 0, 0,
  16842, 16842, 16842, 16842, 16842, 16842, 17800, 16842, 16801, 16801, 17467, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 17884, 16801, 16801, 16801, 16801, 17495, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17952, 16801, 16801, 0, 914, 0, 916, 15253, 16842,
  16842, 16842, 17513, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16801, 1171, 0, 1173, 0, 1175, 0, 1177, 0,
  17521, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842,
  17323, 17547, 16842, 16842, 16842, 16842, 16842, 16842, 16801, 0, 970, 0, 972, 0, 974, 0, 976, 0, 0, 1191, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 279, 0, 0, 0, 0, 1219, 1028, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20781, 20781, 20781,
  20781, 0, 1249, 16801, 16801, 17636, 16801, 16801, 17637, 16801, 17638, 16801, 16801, 16801, 16801, 16801, 16801, 0,
  0, 16842, 16842, 16842, 166346, 16842, 16842, 16842, 16842, 16801, 16801, 16801, 17645, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17489, 16801, 16801, 16801, 16801, 0, 1287, 0, 1288, 16842,
  16842, 16842, 16842, 17677, 16842, 16842, 17678, 16842, 16842, 17680, 16842, 17708, 0, 1325, 0, 1326, 0, 1327, 0,
  1328, 17713, 0, 0, 0, 0, 0, 0, 561, 0, 0, 0, 0, 0, 564, 0, 0, 0, 1185, 1186, 1187, 1188, 0, 1335, 0, 0, 0, 0, 1340, 0,
  0, 0, 0, 0, 0, 572, 0, 0, 0, 0, 578, 0, 0, 0, 583, 0, 350208, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1357, 16801,
  16801, 16801, 17793, 16801, 16801, 1287, 1288, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17351,
  16801, 0, 970, 972, 0, 0, 16842, 16842, 16842, 16842, 17817, 16842, 16842, 16842, 16842, 17820, 16842, 16801, 1325,
  1326, 1327, 1328, 0, 0, 1452, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 308, 0, 0, 16801, 17875, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17885, 16801, 0, 0, 0, 0, 16842, 16842, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 16801, 1325, 1326, 1327, 1328, 16842, 16842, 17901, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 16801, 16842, 0, 0, 0, 1181, 0, 1183, 0, 0, 0, 0, 0, 0, 0, 0, 0, 796,
  0, 0, 0, 0, 0, 0, 16842, 17970, 16842, 16842, 16842, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1449, 1692, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 0, 0, 271, 272, 273, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1199, 0, 0, 0, 0, 0,
  0, 0, 0, 36864, 38912, 0, 0, 0, 334, 334, 0, 34816, 0, 0, 0, 0, 0, 262, 263, 0, 265, 266, 0, 0, 0, 159744, 0, 0, 0,
  45415, 0, 0, 0, 0, 0, 0, 0, 334, 0, 0, 0, 0, 0, 0, 0, 141312, 141312, 0, 1, 8194, 3, 4, 0, 0, 16844, 16829, 16829,
  16844, 16829, 16844, 16829, 16829, 16829, 16829, 16829, 16829, 16829, 16844, 16844, 16844, 16844, 16844, 16844, 16844,
  16829, 16829, 16844, 1, 8194, 3, 4, 41199, 41199, 0, 0, 1028, 0, 0, 0, 0, 1032, 0, 0, 0, 0, 0, 0, 0, 0, 312, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1225, 0, 0, 0, 0, 1360, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 324, 0, 0, 45415, 46429,
  45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 1380, 0, 0, 0, 1248, 1249, 16801, 16801, 17769, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17666, 16801, 16801, 16801, 1, 8194, 3,
  4, 41199, 47345, 0, 0, 0, 0, 0, 0, 0, 0, 0, 247, 247, 0, 0, 0, 0, 0, 248, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1461, 0, 0, 274, 0, 36864, 38912, 0, 276, 0, 335, 335, 336, 34816, 336, 341, 336, 341, 0, 341, 341, 352, 356, 356,
  45417, 45417, 356, 45417, 386, 356, 45417, 45417, 386, 356, 45417, 386, 356, 401, 356, 356, 356, 356, 407, 356, 410,
  411, 410, 411, 411, 411, 356, 16803, 411, 411, 356, 411, 411, 411, 45417, 411, 45417, 411, 16830, 16845, 16830, 16830,
  16845, 16830, 16845, 16830, 16830, 16830, 16830, 16830, 16830, 16830, 16845, 16845, 16845, 16845, 16845, 16845, 16845,
  16830, 16830, 16845, 1, 8194, 3, 4, 41199, 41199, 0, 0, 0, 530, 0, 0, 0, 0, 297, 297, 297, 0, 0, 0, 0, 0, 0, 0, 65536,
  65536, 65536, 0, 0, 0, 0, 0, 0, 530, 0, 0, 0, 0, 561, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 815, 45415, 45415,
  45415, 45887, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415,
  383335, 0, 855, 857, 0, 17242, 17243, 17244, 16801, 16801, 16801, 17250, 16801, 17253, 16801, 16801, 16801, 16801,
  17260, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 407969, 16801, 166305, 16801,
  16801, 16801, 16801, 16801, 17257, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 364961, 381345, 0, 974, 976, 0, 16842, 47846, 0, 978, 0, 0, 0, 0, 0, 0, 0, 752, 1014, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 4096, 0, 1042, 0, 0, 1045, 0, 45415, 45415, 45415, 45415, 45415, 46107, 45415, 45415,
  45415, 45415, 45415, 45415, 45415, 403815, 0, 0, 0, 0, 0, 0, 0, 1248, 16801, 16801, 16801, 17468, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17883, 16801, 16801, 17886, 0, 914, 0, 916, 15253,
  16842, 16842, 16842, 16842, 16842, 17515, 16842, 16842, 16842, 16842, 16842, 0, 0, 0, 0, 0, 0, 0, 0, 0, 348160, 0,
  16842, 17522, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17529, 16842, 16842, 16842, 16842, 16842, 16842, 17348,
  16842, 16842, 16842, 17292, 0, 970, 972, 0, 0, 0, 0, 0, 1028, 1220, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1341, 0, 0, 0, 0,
  46532, 45415, 45415, 0, 1480, 0, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17873, 17899, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16801, 16842, 0, 0, 0, 1441, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1603, 45415, 182631, 46660, 45415, 45415, 0, 16801, 17943, 17944, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 17951, 16801, 16801, 16801, 16801, 17277, 16801, 16801, 16801, 0, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 17775, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 18000, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17114, 16801, 480, 16842, 16842, 16842,
  18012, 16842, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1543, 0, 0, 0, 45415, 16801, 18108, 16801, 16801, 16801, 16801, 16842,
  16842, 16842, 18115, 16842, 16842, 16842, 16842, 16842, 16842, 17526, 16842, 16842, 16842, 16842, 16842, 16842, 16842,
  16842, 16842, 0, 0, 1755, 0, 16801, 16801, 16801, 0, 0, 278, 0, 36864, 38912, 0, 0, 0, 306, 306, 0, 34816, 0, 0, 0, 0,
  0, 262, 263, 0, 265, 266, 0, 0, 155648, 0, 0, 0, 0, 0, 262, 263, 0, 265, 266, 0, 106496, 0, 0, 0, 0, 0, 0, 1362, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 292, 293, 0, 0, 0, 0, 0, 0, 344, 0, 351, 353, 353, 353, 45418, 45418, 353, 45418, 387, 353,
  45418, 45418, 387, 353, 45418, 387, 353, 387, 403, 403, 403, 403, 408, 403, 403, 403, 403, 403, 403, 16804, 403, 403,
  403, 403, 403, 403, 45418, 403, 45418, 403, 16831, 16846, 16831, 16831, 16846, 16831, 16846, 16831, 16831, 16831,
  16831, 16831, 16831, 16831, 16846, 16846, 16846, 16846, 16846, 16846, 16846, 16831, 16831, 16846, 1, 8194, 3, 4,
  41199, 41199, 0, 0, 0, 614, 0, 614, 0, 0, 0, 0, 0, 0, 0, 614, 415, 416, 16801, 17029, 16801, 16801, 16801, 16801, 455,
  456, 0, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16801, 16801, 16842, 1, 8194, 3, 4, 41199, 41199, 16842,
  17089, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16801, 480, 481, 0, 483,
  484, 0, 16842, 0, 4, 41199, 47846, 0, 0, 0, 0, 745, 0, 0, 0, 0, 1466, 0, 0, 0, 0, 0, 0, 45415, 45415, 45415, 45415,
  45415, 45415, 45415, 45655, 45415, 45415, 45415, 45415, 227687, 45415, 45415, 45415, 45415, 45415, 45415, 291175,
  45415, 45893, 45415, 45415, 45415, 45415, 45415, 45415, 45666, 0, 0, 0, 0, 0, 0, 0, 0, 0, 480, 0, 481, 0, 483, 0, 484,
  0, 0, 0, 0, 0, 0, 0, 0, 855, 857, 0, 17242, 154017, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  227745, 16801, 16801, 17291, 16801, 16801, 16801, 16801, 16801, 0, 914, 916, 0, 15253, 17242, 154058, 16842, 0, 1180,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1343, 0, 0, 0, 1190, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1025, 0, 0,
  1249, 16801, 16801, 16801, 16801, 180641, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17651, 17652,
  16801, 16801, 16801, 16801, 16801, 16801, 17656, 17657, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 17995, 16801, 16801, 16801, 0, 1287, 0, 1288, 16842, 16842, 16842, 16842, 16842, 16842,
  180682, 16842, 16842, 16842, 16842, 16842, 0, 0, 0, 1716, 0, 0, 0, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 17641, 16801, 16801, 16801, 46428, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415,
  45415, 0, 0, 0, 0, 1248, 1249, 16801, 17768, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 258465, 16801, 16801, 16801, 16801, 16801, 16801, 17780, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17486, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  319905, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17487, 16801,
  16801, 17490, 16801, 17492, 16801, 16801, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17894, 16842, 16842,
  16842, 16842, 16842, 0, 0, 0, 0, 0, 0, 0, 1634, 1635, 0, 0, 16842, 16842, 16842, 319946, 16842, 16842, 16842, 16842,
  16842, 16842, 16842, 16842, 16801, 16842, 0, 0, 1440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 417792, 0, 0, 0, 16842,
  16842, 16842, 16842, 393674, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20781, 0, 0, 0, 0, 0, 16801, 16801, 16801, 16801, 18081,
  16801, 16801, 16801, 16801, 16801, 16842, 16842, 18089, 16842, 16842, 16842, 16842, 16842, 0, 1629, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 17242, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17483, 16801, 16801,
  16801, 16801, 16801, 16801, 18109, 16801, 16801, 16801, 16842, 16842, 16842, 16842, 16842, 18117, 16842, 16842, 16842,
  16842, 16842, 0, 0, 0, 182272, 0, 0, 0, 0, 0, 0, 0, 1018, 0, 0, 0, 0, 0, 1024, 0, 0, 0, 0, 304, 0, 305, 0, 0, 0, 0, 0,
  0, 0, 280, 305, 283, 283, 0, 0, 0, 280, 304, 0, 304, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27356, 0, 0, 280, 0,
  36864, 38912, 0, 0, 0, 0, 0, 0, 34816, 0, 0, 283, 282, 0, 282, 282, 354, 354, 354, 45419, 45419, 379, 45419, 388, 379,
  45419, 45419, 398, 379, 45419, 388, 379, 388, 379, 379, 405, 405, 388, 405, 405, 405, 405, 405, 405, 413, 16805, 405,
  405, 413, 405, 405, 405, 45419, 405, 45419, 405, 16832, 16847, 16832, 16832, 16847, 16832, 16847, 16832, 16832, 16832,
  16832, 16832, 16832, 16832, 16847, 16847, 16847, 16847, 16847, 16847, 16847, 16832, 16832, 16847, 1, 8194, 3, 4,
  41199, 41199, 499, 0, 0, 0, 0, 262, 263, 0, 265, 266, 0, 0, 0, 0, 0, 0, 0, 319488, 0, 0, 0, 0, 0, 0, 0, 0, 768, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 529, 0, 0, 0, 0, 0, 297, 297, 297, 0, 538, 0, 0, 0, 0, 0, 262, 263, 0, 265, 266, 104448, 0, 0, 0,
  0, 0, 0, 560, 0, 0, 0, 0, 0, 0, 0, 0, 0, 254, 0, 0, 0, 0, 0, 254, 0, 542, 0, 544, 0, 0, 0, 548, 549, 0, 0, 0, 0, 0, 0,
  0, 289, 0, 0, 0, 0, 0, 0, 0, 0, 1350, 0, 0, 0, 0, 0, 0, 0, 584, 0, 0, 0, 0, 0, 45415, 45415, 45415, 45647, 45415,
  45415, 248167, 45415, 281177, 45415, 45415, 45415, 45415, 45415, 46114, 45415, 45415, 45415, 45415, 45415, 0, 0, 0, 0,
  0, 0, 1336, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1351, 1352, 1353, 0, 0, 0, 0, 299367, 45415, 45661, 45415, 45415, 45415, 45415,
  0, 0, 0, 0, 247808, 0, 281075, 299008, 0, 0, 0, 0, 1530, 0, 0, 1533, 0, 0, 0, 0, 0, 0, 0, 0, 455, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 247808, 0, 280576, 0, 299008, 0, 0, 0, 0, 0, 0, 0, 520, 521, 0, 0, 0, 0, 0, 0, 0, 534, 297, 297, 297, 0,
  0, 0, 0, 0, 0, 0, 584, 0, 0, 0, 0, 542, 0, 0, 0, 0, 0, 0, 415, 416, 16801, 16801, 299425, 16801, 17041, 17063, 455,
  456, 0, 16842, 16842, 16842, 16842, 17078, 16842, 16842, 16842, 16842, 16842, 1590, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  45415, 45415, 45415, 45881, 45415, 45415, 248266, 16842, 281285, 16842, 299466, 16842, 16842, 17101, 17104, 17108,
  16842, 16842, 16842, 16842, 16801, 480, 0, 0, 0, 778, 779, 0, 297, 297, 538, 0, 0, 0, 0, 0, 0, 0, 573, 0, 0, 0, 579,
  580, 0, 582, 0, 0, 0, 789, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 800, 0, 0, 0, 0, 0, 16801, 16801, 18052, 18053, 16801, 16801,
  16801, 16801, 16801, 16801, 16842, 16842, 162250, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 296535, 16842,
  16842, 561, 0, 0, 0, 0, 0, 0, 0, 809, 0, 0, 0, 0, 0, 0, 0, 574, 0, 0, 577, 0, 0, 0, 0, 0, 45415, 45899, 0, 0, 0, 0, 0,
  0, 849, 0, 0, 0, 0, 0, 0, 0, 616, 0, 0, 378880, 0, 0, 0, 378880, 619, 17256, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 17269, 16801, 16801, 16801, 16801, 17877, 16801, 16801, 17880, 16801,
  184737, 16801, 217505, 16801, 16801, 16801, 16801, 17022, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 0, 914, 916, 0, 15253, 17242, 17302, 17303, 16801, 16801, 16801, 17276, 16801, 16801, 17280,
  16801, 0, 16801, 16801, 16801, 16801, 17286, 16801, 16801, 16801, 16801, 18111, 16801, 16842, 16842, 16842, 16842,
  18116, 16842, 18118, 16842, 18120, 16842, 17289, 16801, 16801, 17269, 16801, 16801, 16801, 16801, 0, 914, 916, 0,
  15253, 17242, 16842, 16842, 16842, 16842, 16842, 1713, 1714, 0, 0, 0, 0, 0, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17328, 16842, 16842, 16842, 16842,
  16842, 16842, 16842, 17335, 16842, 16842, 16842, 16842, 16842, 0, 0, 1592, 0, 0, 0, 0, 0, 0, 0, 0, 297, 297, 297, 0,
  0, 0, 0, 0, 16842, 16842, 16842, 16842, 17345, 16842, 16842, 16842, 17350, 16842, 17269, 0, 970, 972, 0, 0, 0, 0, 0,
  16801, 18051, 16801, 16801, 16801, 16801, 16801, 18057, 16801, 16801, 16842, 16842, 16842, 16842, 16842, 16842, 0, 0,
  0, 16801, 16801, 16801, 18166, 16842, 0, 974, 976, 0, 17335, 47846, 172032, 0, 0, 0, 981, 0, 0, 0, 0, 752, 0, 754, 0,
  756, 0, 758, 993, 0, 0, 0, 0, 0, 0, 0, 0, 219136, 0, 0, 1003, 0, 1005, 1006, 0, 1008, 0, 0, 0, 0, 0, 0, 1012, 0, 0, 0,
  0, 1600, 0, 0, 0, 157696, 0, 158055, 45415, 45415, 45415, 45415, 0, 0, 0, 16801, 16801, 16801, 16801, 16801, 201121,
  16801, 16801, 16801, 16801, 0, 0, 0, 0, 0, 0, 0, 16801, 16801, 16801, 16801, 17055, 0, 0, 1028, 0, 387072, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 49404, 51453, 0, 0, 0, 0, 0, 0, 1044, 0, 0, 46102, 172391, 45415, 45415, 45415, 45415, 219495,
  45415, 46109, 45415, 45415, 45415, 45415, 46432, 45415, 46433, 45415, 346471, 45415, 45415, 0, 0, 1381, 0, 0, 0, 0, 0,
  274432, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86016, 0, 0, 0, 0, 0, 45415, 45415, 46112, 45415, 46113, 45415, 45415, 45415,
  45415, 45415, 45415, 0, 1066, 0, 0, 1068, 0, 0, 0, 172032, 172032, 0, 855, 0, 857, 17242, 17459, 17460, 172449, 16801,
  16801, 16801, 16801, 17278, 16801, 16801, 16801, 0, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  18086, 16842, 16842, 16842, 16842, 16842, 17479, 16801, 17480, 17481, 16801, 16801, 16801, 16801, 16801, 360865,
  16801, 16801, 16801, 16801, 16801, 16801, 0, 0, 17795, 16842, 16842, 16842, 16842, 17799, 16842, 16842, 17493, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 17501, 307617, 16801, 17503, 16801, 16801, 17505, 0, 914, 0, 916,
  15253, 17510, 17511, 16842, 16842, 172490, 16842, 16842, 16842, 16842, 16842, 16842, 17807, 16842, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 408010, 16801, 0, 0, 0, 0, 16842, 16842, 16842, 16842, 219594, 16842,
  16842, 17527, 16842, 16842, 16842, 16842, 16842, 16842, 17533, 16842, 0, 1439, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  525, 0, 0, 16842, 17535, 307658, 16842, 17536, 17537, 16842, 16842, 16842, 16842, 17543, 16842, 360906, 16842, 16842,
  16842, 0, 16801, 16801, 16842, 16842, 16801, 16842, 16801, 16842, 18175, 18176, 16801, 16842, 16842, 17548, 16842,
  16842, 16842, 16842, 17553, 16801, 0, 970, 0, 972, 0, 974, 0, 976, 1203, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  45415, 0, 0, 0, 1028, 0, 0, 0, 0, 403456, 0, 0, 0, 0, 0, 0, 1227, 0, 1229, 0, 0, 1232, 45415, 45415, 45415, 45415,
  45415, 46293, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 46118, 45415, 45415, 0, 0, 0, 0, 0, 290816, 0,
  0, 291561, 0, 0, 0, 0, 0, 0, 1249, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17640, 16801, 16801,
  16801, 16801, 0, 0, 0, 0, 0, 0, 0, 16801, 16801, 16801, 16801, 17025, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 256417, 16801, 287137, 16801, 16801, 16801, 16801, 16801, 17043, 16801, 16801, 16801,
  16801, 403873, 16801, 16801, 16801, 17661, 16801, 17663, 16801, 16801, 16801, 17667, 16801, 16801, 16801, 16801,
  344481, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17061, 16801, 455, 456, 0, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 16801, 1172, 970, 1174, 972, 1176, 974, 1178, 976, 16801, 0, 1287, 0, 1288,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17679, 16842, 16842, 16842, 16842, 16842, 16842, 211402,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 227786, 16842, 16842, 16842, 16842, 16842,
  16842, 17682, 16842, 17684, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 0, 0,
  0, 0, 0, 0, 0, 16842, 17696, 17697, 17698, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842,
  16842, 403914, 0, 0, 0, 0, 362496, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 61440, 0, 0, 61440, 61440, 1249, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 17774, 16801, 16801, 16801, 16801, 16801, 293281, 16801, 0, 0, 0, 0, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 192970, 16842, 16801, 0, 0, 0, 0, 0, 0, 0, 0, 16842, 0, 1330, 0, 0,
  0, 0, 0, 262, 18939, 0, 265, 27135, 0, 0, 0, 0, 0, 0, 0, 45430, 45430, 0, 45430, 396, 0, 45430, 45430, 396, 17779,
  16801, 16801, 16801, 16801, 16801, 362913, 17783, 16801, 16801, 16801, 16801, 16801, 17787, 16801, 16801, 16801,
  16801, 346529, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17786, 16801, 17788, 16801, 16842, 16842, 17804,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 293322, 16842, 17812, 16842, 16842, 16842, 16842, 16842,
  16842, 373194, 16842, 16842, 16842, 16842, 16801, 0, 0, 0, 0, 0, 0, 0, 0, 16842, 0, 0, 0, 0, 0, 0, 0, 985, 1185, 987,
  1186, 989, 1187, 991, 1188, 45415, 46533, 45415, 0, 0, 1481, 16801, 16801, 16801, 16801, 199073, 16801, 16801, 16801,
  16801, 16801, 17064, 455, 456, 0, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 18137, 16842, 0, 0, 0, 0, 16801,
  16801, 16801, 17874, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 17785, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16842, 16842, 16842, 16842, 16842, 16842, 199114,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 16801, 16801, 16842, 1, 8194, 3, 4, 41199, 41449, 16842, 17900,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 340385, 340426, 0, 1527, 335872, 0, 0, 0, 0, 0,
  0, 0, 0, 1534, 1535, 0, 0, 0, 0, 1536, 0, 1537, 0, 0, 397312, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45415, 45415, 45415,
  45415, 45415, 211303, 176487, 45415, 45415, 270695, 45415, 46607, 176128, 270336, 0, 16801, 16801, 176545, 16801,
  16801, 16801, 16801, 0, 0, 0, 0, 0, 0, 0, 16801, 16801, 16801, 16801, 17026, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 272801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17648,
  16801, 16801, 16801, 16801, 16801, 17654, 16801, 16801, 16801, 270753, 16801, 16801, 16801, 16801, 17946, 17947,
  395681, 16801, 16801, 17950, 16801, 16801, 16801, 17954, 16801, 0, 0, 0, 0, 16842, 16842, 16842, 16842, 16842, 178634,
  16842, 16842, 16842, 16842, 16842, 0, 0, 0, 0, 0, 0, 0, 16801, 16801, 18106, 18107, 16842, 16842, 16842, 176586,
  16842, 16842, 16842, 17963, 16842, 16842, 270794, 16842, 16842, 16842, 16842, 16842, 0, 0, 0, 0, 0, 0, 0, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 18131, 16801, 17969, 17971, 16842, 17973, 395722, 0, 0, 0, 0, 0, 1594, 0,
  294912, 1596, 0, 0, 0, 0, 0, 18936, 263, 0, 27132, 266, 0, 0, 0, 0, 0, 0, 0, 16801, 18127, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 17029, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 0, 0, 0, 0, 0, 0, 16842, 16842,
  1637, 0, 0, 45415, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 18031, 16801, 0, 0, 0, 0,
  16842, 16842, 16842, 17676, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17687, 16842, 16842, 16842, 16842, 16842,
  16842, 16842, 16842, 17528, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 0, 0, 0, 1664, 0, 16801, 16801, 16801,
  16801, 16801, 18055, 16801, 16801, 16801, 16801, 16842, 16842, 16842, 16842, 16842, 16842, 0, 0, 0, 16801, 16801,
  18157, 18158, 16842, 16842, 18063, 16842, 16842, 16842, 16842, 16842, 16842, 0, 0, 0, 0, 1689, 0, 0, 0, 0, 0, 30720,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 8194, 3, 4, 0, 0, 16842, 16842, 16842, 16842, 18096, 0, 0, 0, 0, 0, 0, 0, 16801,
  16801, 16801, 16801, 16801, 16801, 18130, 16801, 16801, 215457, 16801, 16801, 16801, 16801, 16801, 16842, 16842,
  215498, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17349, 16842, 16842, 16801, 0, 970, 972, 0, 0, 167936, 1738,
  0, 0, 0, 0, 0, 18126, 16801, 16801, 16801, 223649, 297377, 16801, 16801, 16801, 16801, 17293, 16801, 16801, 16801, 0,
  914, 916, 0, 15253, 17242, 16842, 16842, 18132, 16842, 223690, 16842, 297418, 16842, 16842, 16842, 16842, 0, 0, 0, 0,
  16801, 16801, 16801, 178593, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 393633, 16801,
  16801, 16801, 16801, 16801, 16801, 352673, 16842, 18160, 16842, 16842, 16842, 352714, 0, 0, 0, 16801, 16801, 16801,
  16801, 16842, 16842, 16842, 16842, 16842, 16842, 0, 0, 0, 16801, 18156, 16801, 16801, 0, 310, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1215, 0, 0, 307, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 307, 0, 0, 0, 0, 0, 45415, 45415, 45415, 45415,
  45415, 45415, 45415, 46294, 252263, 45415, 45415, 844, 0, 0, 0, 847, 0, 0, 0, 0, 0, 0, 852, 853, 0, 0, 307, 307, 0,
  36864, 38912, 0, 307, 310, 0, 0, 256, 34816, 256, 256, 256, 0, 256, 256, 256, 256, 256, 45420, 45420, 256, 45420, 0,
  256, 45420, 45420, 0, 0, 0, 0, 4096, 0, 0, 4096, 4096, 4096, 0, 0, 0, 0, 0, 0, 455, 684, 0, 0, 0, 0, 0, 0, 0, 0, 267,
  0, 1, 8194, 3, 4, 41199, 41199, 256, 45420, 0, 256, 307, 256, 256, 256, 256, 307, 256, 256, 256, 256, 256, 256, 16806,
  256, 256, 256, 256, 256, 256, 45420, 256, 45420, 440, 16833, 16848, 16833, 16833, 16848, 16833, 16848, 16833, 16833,
  16833, 16833, 16833, 16833, 16833, 16848, 16848, 16848, 16848, 16848, 16848, 16848, 16833, 16833, 16848, 1, 8194, 3,
  4, 41199, 41199, 16801, 260513, 16801, 16801, 16801, 16801, 455, 456, 0, 16842, 16842, 16842, 16842, 16842, 16842,
  16842, 17540, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17688, 16842, 16842, 16842, 16842, 16842, 16842,
  16842, 16842, 260554, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16801, 480,
  0, 855, 857, 0, 17242, 16801, 16801, 16801, 16801, 16801, 17251, 16801, 16801, 16801, 16801, 16801, 17261, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17662, 16801, 16801, 16801, 16801, 16801, 17668, 16801,
  16842, 16842, 16842, 17816, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16801, 1325, 1326, 1327, 1328, 16801,
  16801, 152010, 16842, 16842, 16842, 16842, 16842, 0, 0, 0, 16801, 16801, 16801, 16801, 16842, 16842, 16842, 16842,
  16842, 16842, 0, 0, 0, 151969, 16801, 16801, 16801, 0, 0, 0, 0, 36864, 38912, 0, 0, 0, 0, 0, 337, 34816, 337, 337,
  337, 345, 337, 337, 337, 337, 337, 45421, 45421, 380, 45421, 389, 380, 45421, 45421, 389, 380, 45421, 389, 380, 389,
  380, 380, 380, 380, 389, 380, 380, 380, 380, 380, 380, 16807, 380, 380, 380, 380, 380, 380, 45421, 380, 45421, 380,
  16807, 16849, 16807, 16807, 16849, 16807, 16849, 16807, 16807, 16807, 16807, 16807, 16807, 16807, 16849, 16849, 16849,
  16849, 16849, 16849, 16849, 16807, 16807, 16849, 1, 8194, 3, 4, 41199, 41199, 385024, 0, 147456, 0, 0, 0, 0, 1540, 0,
  0, 0, 0, 1544, 0, 0, 45415, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 481, 0, 16801, 158113, 16801, 16801, 16801,
  239176, 16801, 16801, 333385, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17471, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 291696, 16801, 16801, 17267, 16801, 16801, 16801, 16801, 0, 0, 206848, 207207, 16801,
  16801, 207265, 16801, 16801, 16801, 16801, 16801, 18029, 16801, 16801, 16801, 16801, 17469, 16801, 16801, 16801,
  16801, 16801, 17474, 16801, 16801, 16801, 16801, 17478, 16842, 16842, 207306, 16842, 16842, 16842, 16842, 16842,
  18039, 16842, 16842, 16842, 0, 0, 0, 0, 1182, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 69632, 0, 0, 0, 0, 0, 16801, 16801, 16842,
  16842, 16842, 16842, 16842, 16842, 0, 0, 0, 16801, 240033, 334241, 16801, 16842, 16801, 0, 1325, 0, 1326, 0, 1327, 0,
  1328, 16842, 0, 0, 0, 0, 0, 0, 1184, 0, 1185, 0, 1186, 0, 1187, 0, 1188, 240074, 334282, 16842, 0, 16801, 16801,
  16842, 16842, 16801, 16842, 16801, 16842, 16801, 16842, 16801, 16842, 16801, 0, 1325, 0, 1326, 0, 1327, 0, 1328,
  16842, 292864, 0, 0, 1332, 0, 0, 0, 0, 1739, 0, 1741, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  17265, 16801, 16801, 16801, 16801, 16801, 16801, 0, 0, 569, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 772, 0, 0, 16801,
  16801, 17047, 16801, 0, 0, 0, 0, 0, 0, 0, 16801, 16801, 17017, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 222464, 16801, 16801, 16801, 16801, 16801, 0, 0, 0, 747, 0, 0, 0, 0, 752, 754, 0,
  0, 756, 758, 0, 0, 0, 0, 0, 45415, 45415, 45415, 45415, 45415, 45415, 221543, 45415, 45415, 45415, 45415, 45415,
  45415, 45889, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 46119, 45415, 0, 0, 0, 0, 0, 0, 776, 0,
  0, 0, 0, 297, 297, 0, 0, 0, 0, 0, 0, 0, 0, 795, 0, 797, 0, 0, 0, 0, 0, 16842, 178176, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1226, 0, 1450, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65536, 0, 0, 0, 45415, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 389537, 284, 285, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1356, 0, 0, 0, 0, 258, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25357, 0, 0, 0, 0, 346, 0, 0, 0, 0, 0, 45422, 45422, 381,
  45422, 390, 381, 45422, 45422, 390, 381, 45422, 390, 381, 390, 404, 404, 406, 390, 390, 390, 390, 390, 390, 390, 390,
  414, 16808, 390, 390, 414, 390, 390, 390, 45422, 390, 45422, 390, 16834, 16850, 16834, 16834, 16850, 16834, 16850,
  16834, 16834, 16834, 16834, 16834, 16834, 16834, 16850, 16850, 16850, 16850, 16850, 16850, 16850, 16834, 16834, 16850,
  1, 8194, 3, 4, 41199, 41199, 0, 0, 612, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1214, 0, 0, 0, 0, 612, 0, 0, 0, 0, 612,
  0, 0, 0, 0, 0, 0, 415, 416, 45898, 45415, 0, 0, 0, 846, 0, 0, 0, 850, 0, 0, 0, 0, 0, 0, 0, 413696, 0, 0, 0, 0, 0, 0,
  0, 0, 118784, 0, 0, 0, 0, 0, 0, 0, 0, 855, 857, 0, 17242, 16801, 16801, 16801, 17247, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 17485, 16801, 16801, 16801, 16801, 16801, 16801, 17491, 16801, 16842, 16842, 16842, 17308, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 0, 1658, 0, 1660, 17324, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17813, 16842, 16842, 17343,
  16842, 16842, 16842, 17347, 16842, 16842, 16842, 17352, 0, 970, 972, 0, 0, 0, 0, 0, 45415, 45415, 45415, 45415, 46292,
  45415, 45415, 45415, 45415, 45415, 45415, 0, 0, 0, 16801, 17938, 16801, 16801, 16801, 16801, 17942, 0, 974, 976, 0,
  17361, 47846, 0, 0, 0, 0, 0, 982, 0, 0, 0, 752, 0, 754, 0, 756, 0, 758, 0, 0, 0, 0, 0, 0, 999, 0, 0, 0, 0, 0, 262,
  263, 20744, 265, 266, 0, 0, 0, 0, 0, 0, 0, 57344, 120832, 129024, 0, 0, 0, 0, 0, 0, 0, 61440, 61440, 0, 530667, 8194,
  3, 4, 0, 0, 242, 0, 0, 0, 0, 0, 0, 0, 0, 0, 249, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1004, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1011, 0, 0, 0, 0, 0, 45415, 45415, 45415, 192871, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 0,
  0, 0, 229376, 0, 0, 0, 0, 0, 0, 0, 0, 0, 229376, 0, 0, 1027, 0, 0, 1029, 0, 0, 0, 0, 0, 0, 0, 1035, 1036, 0, 1038, 0,
  0, 0, 0, 4096, 4096, 4096, 0, 0, 4096, 0, 4096, 4096, 0, 0, 4096, 0, 4096, 4096, 4096, 4096, 4096, 4096, 4096, 4096,
  4096, 4096, 4096, 4096, 4096, 4096, 0, 4096, 4096, 4096, 4096, 4096, 4096, 4096, 4096, 4096, 4096, 0, 16842, 16842,
  16842, 16842, 17551, 16842, 16842, 16801, 0, 970, 0, 972, 0, 974, 0, 976, 0, 1218, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1460, 0, 1358, 0, 0, 0, 0, 0, 0, 1363, 1364, 0, 0, 1367, 0, 0, 0, 0, 0, 0, 1532, 0, 0, 0, 0, 0, 0, 0, 0, 0, 279,
  0, 306, 0, 0, 0, 0, 17790, 16801, 16801, 16801, 16801, 16801, 0, 0, 16842, 16842, 16842, 16842, 16842, 16842, 16842,
  16842, 17107, 16842, 16842, 16842, 16842, 16842, 16801, 480, 0, 1451, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 61440,
  0, 45415, 45415, 46534, 0, 0, 0, 16801, 17867, 16801, 17869, 16801, 16801, 16801, 16801, 17872, 16801, 0, 0, 0, 0,
  16842, 16842, 17675, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17103, 16842, 16842, 16842, 16842, 16842,
  16801, 480, 16801, 16801, 16801, 17876, 16801, 17878, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 0, 914, 916, 0, 15253, 17242, 16842, 16842, 16801, 17888, 16842, 17890, 16842, 16842, 17893, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 17897, 16842, 16801, 1171, 1325, 1173, 1326, 1175, 1327, 1177, 1328, 16842, 0, 0,
  0, 0, 0, 0, 0, 1445, 0, 0, 0, 0, 0, 0, 0, 1602, 0, 0, 45415, 45415, 45415, 45415, 45415, 0, 16842, 16842, 16842,
  16842, 17902, 16842, 16842, 17905, 16842, 17907, 16842, 16842, 16801, 16842, 0, 0, 364544, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 339968, 0, 0, 0, 0, 0, 163840, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83968, 83968, 45415, 45415, 46605,
  45415, 45415, 45415, 0, 0, 0, 16801, 16801, 16801, 16801, 17941, 16801, 16801, 16801, 16801, 373153, 16801, 0, 0,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17703, 16842, 16842, 16842, 16842, 16842, 16842, 0,
  16801, 16801, 18079, 18080, 16801, 16801, 16801, 18084, 18085, 16801, 16842, 16842, 16842, 16842, 18091, 16842, 18093,
  18094, 18095, 16842, 0, 0, 0, 0, 0, 0, 0, 16801, 16801, 16801, 16801, 16801, 16801, 18056, 16801, 16801, 16801, 16842,
  18144, 16801, 16801, 16842, 16842, 18149, 18150, 16842, 16842, 0, 0, 0, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 17642, 0, 0, 0, 0, 36864, 38912, 0, 0, 331, 0, 0, 257, 34816, 257,
  257, 257, 0, 257, 257, 257, 257, 257, 45423, 45423, 382, 45423, 391, 382, 45423, 45423, 391, 382, 45423, 391, 382,
  391, 382, 382, 382, 382, 391, 382, 382, 382, 382, 382, 382, 16809, 382, 382, 382, 382, 382, 382, 45423, 382, 45423,
  441, 16809, 16851, 16809, 16809, 16851, 16809, 16851, 16809, 16809, 16809, 16809, 16809, 16809, 16809, 16851, 16851,
  16851, 16851, 16851, 16851, 16851, 16809, 16809, 16851, 1, 8194, 3, 4, 41199, 41199, 557, 0, 0, 0, 557, 0, 561, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 813, 0, 0, 0, 521, 0, 0, 0, 0, 45415, 45415, 45415, 45415, 45649, 45415, 45415, 45415,
  45415, 45415, 45415, 45415, 45891, 285031, 45415, 45415, 45415, 45894, 45895, 45415, 45415, 787, 788, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 799, 0, 0, 0, 0, 0, 284, 0, 0, 0, 0, 0, 0, 0, 0, 284, 0, 284, 0, 0, 0, 0, 0, 0, 0, 0, 822, 0, 45415,
  45415, 45415, 45415, 45415, 45415, 561, 0, 0, 0, 0, 0, 0, 0, 0, 0, 761, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  88064, 88064, 0, 855, 857, 0, 17242, 16801, 16801, 16801, 16801, 17248, 16801, 16801, 16801, 16801, 16801, 16801, 455,
  456, 0, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16801, 0, 970, 0, 972, 0, 974, 0, 976, 16801, 16801, 17258,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 17266, 16801, 16801, 16801, 16801, 16801, 17294, 16801, 16801, 0,
  914, 916, 0, 15253, 17242, 16842, 16842, 17273, 16801, 16801, 16801, 16801, 17279, 16801, 16801, 0, 16801, 16801,
  17248, 16801, 16801, 16801, 16801, 0, 0, 0, 0, 0, 0, 0, 16801, 17051, 16801, 17020, 16801, 0, 754, 0, 756, 0, 758, 0,
  0, 995, 0, 0, 0, 0, 0, 0, 0, 794, 0, 0, 0, 0, 0, 0, 801, 0, 0, 0, 0, 243712, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  92460, 92645, 92645, 92645, 16801, 17466, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17473, 16801, 16801, 16801,
  16801, 16801, 16801, 455, 456, 0, 16842, 16842, 16842, 16842, 16842, 17081, 16842, 0, 914, 0, 916, 15253, 16842,
  16842, 16842, 16842, 16842, 16842, 17516, 17517, 16842, 16842, 17520, 45415, 45415, 45415, 46299, 45415, 45415, 45415,
  45415, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 851, 0, 0, 0, 45415, 45415, 45415, 46431, 45415, 45415, 45415, 45415, 45415,
  45415, 45415, 0, 0, 0, 0, 0, 274432, 0, 0, 0, 17802, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 344522, 0, 1463, 0, 0, 0, 0, 1468, 0, 0, 0, 0, 45415, 46529, 45415, 45415,
  45415, 1479, 0, 0, 16801, 16801, 17868, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17500, 16801, 16801, 16801,
  17502, 16801, 16801, 16801, 16801, 16801, 16801, 16842, 16842, 16842, 17892, 16842, 16842, 16842, 16842, 16842, 16842,
  16842, 16842, 16842, 16842, 17689, 16842, 17691, 16842, 16842, 318750, 1597, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45415, 45415,
  45415, 45415, 45415, 0, 0, 0, 17866, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 804, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 17999, 16801, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842,
  16842, 16842, 16842, 16842, 17544, 16842, 16842, 16842, 16842, 18011, 16842, 16842, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  83968, 0, 0, 0, 83968, 16842, 16842, 16842, 18134, 16842, 18135, 16842, 16842, 16842, 0, 0, 0, 0, 18141, 16801, 16801,
  16801, 16842, 18148, 16842, 16842, 16842, 16842, 0, 0, 0, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  17639, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 18147, 16842, 16842, 16842, 16842, 16842, 0, 0, 0,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 221601, 231841, 16801, 16801, 16801,
  16842, 16842, 16842, 16842, 16842, 16842, 0, 0, 0, 18165, 16801, 16801, 16801, 18167, 0, 347, 0, 0, 0, 0, 0, 45424,
  45424, 0, 45424, 392, 0, 45424, 45424, 392, 0, 45424, 400, 0, 392, 392, 392, 392, 392, 392, 392, 392, 392, 392, 392,
  392, 16810, 392, 392, 392, 392, 392, 392, 45424, 392, 45424, 392, 16810, 16852, 16810, 16810, 16852, 16810, 16852,
  16810, 16810, 16810, 16810, 16810, 16810, 16810, 16852, 16852, 16852, 16852, 16852, 16852, 16852, 16810, 16810, 16852,
  1, 8194, 3, 4, 41199, 41449, 0, 522, 0, 0, 0, 0, 45415, 45415, 45415, 45415, 45650, 45415, 45415, 45415, 45415, 45415,
  45415, 45415, 46116, 45415, 45415, 45415, 0, 0, 0, 0, 0, 0, 681, 456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 153600, 153959,
  45415, 45415, 45415, 45415, 45415, 16801, 17030, 16801, 16801, 16801, 16801, 455, 456, 0, 16842, 16842, 16842, 16842,
  16842, 17082, 16842, 16801, 16801, 16842, 16801, 16842, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16842, 16842,
  16842, 16842, 16842, 16842, 0, 0, 0, 16801, 16801, 16801, 16801, 16842, 16842, 17090, 16842, 16842, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16801, 480, 16801, 17274, 16801, 16801, 16801, 16801, 16801,
  16801, 0, 16801, 16801, 17284, 16801, 16801, 16801, 16801, 0, 0, 0, 0, 0, 0, 564, 16801, 16801, 16801, 16801, 16801,
  17782, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17882, 16801, 16801, 16801, 16801, 16801,
  16801, 17290, 16801, 16801, 16801, 16801, 16801, 16801, 0, 914, 916, 0, 15253, 17242, 16842, 16842, 16842, 16842,
  16842, 17313, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17334, 16842, 16842, 16842, 16842,
  16842, 17341, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16801, 0, 970, 972, 0, 0, 0, 0, 0, 45415,
  46290, 46291, 45415, 45415, 45415, 45415, 45415, 45415, 46295, 45415, 0, 754, 0, 756, 0, 758, 0, 0, 0, 0, 0, 0, 0, 0,
  1001, 0, 0, 0, 0, 15253, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16801, 0, 0, 0,
  0, 0, 0, 276480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96640, 96640, 16801, 16801, 16801, 17496, 16801, 17498,
  16801, 16801, 276897, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 295329, 16801, 16801, 16801, 162209, 16801,
  16801, 296524, 16801, 0, 914, 0, 916, 15253, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17518, 16842,
  16842, 16842, 16842, 16842, 17346, 16842, 16842, 16842, 16842, 16801, 0, 970, 972, 0, 0, 0, 0, 0, 49404, 49404, 49404,
  49404, 51453, 0, 0, 0, 0, 0, 51453, 16842, 16842, 16842, 17524, 16842, 16842, 16842, 16842, 16842, 16842, 16842,
  16842, 16842, 16842, 16842, 276938, 1228, 0, 0, 0, 0, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415,
  45415, 45415, 0, 0, 0, 0, 1248, 16842, 16842, 17683, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842,
  16842, 16842, 16842, 16842, 17545, 16842, 16842, 0, 1662, 0, 0, 0, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 18059, 16842, 16842, 16842, 16842, 16842, 18036, 18037, 18038, 16842, 16842, 16842, 16842, 0, 0, 0, 0,
  0, 0, 1444, 0, 0, 0, 0, 0, 0, 0, 0, 1009, 0, 0, 0, 0, 0, 0, 0, 297, 0, 286, 0, 0, 47345, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  45415, 45415, 45415, 272743, 45415, 272384, 0, 0, 0, 259, 313, 260, 0, 0, 0, 0, 0, 0, 0, 286, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 110932, 0, 0, 0, 313, 0, 0, 0, 36864, 38912, 313, 0, 0, 0, 286, 0, 34816, 0, 0, 0, 0, 0, 492, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1198, 0, 0, 0, 0, 0, 383, 45425, 383, 383, 383, 383, 383, 383, 383, 393, 383, 383, 383, 383, 383,
  383, 16811, 383, 383, 383, 383, 383, 383, 45425, 383, 45425, 383, 16835, 16853, 16835, 16835, 16853, 16835, 16853,
  16835, 16835, 16835, 16835, 16835, 16835, 16835, 16853, 16853, 16853, 16853, 16853, 16853, 16853, 16835, 16835, 16853,
  1, 8194, 3, 4, 41199, 41199, 0, 500, 0, 0, 0, 262, 263, 0, 265, 266, 0, 0, 0, 0, 0, 0, 0, 416141, 416141, 416141, 1,
  8194, 3, 4, 0, 0, 0, 523, 0, 0, 545, 586, 45415, 45643, 45415, 45415, 45651, 45415, 45415, 45656, 45415, 45415, 45415,
  45415, 45415, 45415, 391527, 45415, 0, 0, 0, 0, 0, 391168, 0, 0, 0, 0, 0, 192512, 0, 0, 0, 0, 0, 208896, 0, 0, 0, 0,
  0, 0, 45415, 45415, 45415, 45648, 45415, 45415, 45415, 45415, 45415, 45415, 0, 0, 0, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 45415, 45659, 45415, 45415, 45415, 45665, 45415, 0, 0, 0, 523, 0, 0, 0, 0,
  0, 0, 793, 0, 0, 0, 0, 0, 0, 0, 0, 0, 522, 0, 0, 0, 0, 0, 0, 0, 522, 0, 415, 416, 586, 0, 0, 0, 0, 615, 0, 0, 0, 0, 0,
  618, 0, 541, 0, 0, 0, 545, 0, 0, 0, 0, 0, 551, 0, 0, 0, 0, 0, 0, 766, 0, 0, 0, 0, 0, 0, 0, 0, 0, 376, 0, 55672, 376,
  0, 0, 55672, 16801, 17014, 16801, 16801, 17024, 16801, 16801, 17031, 16801, 16801, 16801, 17035, 16801, 16801, 16801,
  16801, 0, 0, 0, 0, 281075, 0, 0, 16801, 16801, 16801, 17019, 16801, 16801, 248225, 16801, 281224, 16801, 299425,
  16801, 16801, 17039, 17041, 16801, 17045, 16801, 16801, 16801, 0, 0, 586, 0, 0, 0, 0, 17014, 16801, 16801, 16801,
  17024, 16801, 17031, 16801, 16801, 16801, 16801, 455, 456, 0, 16842, 17071, 16842, 16842, 16842, 17083, 16842, 16842,
  16842, 16842, 16842, 233930, 16842, 16842, 262602, 16842, 16842, 16842, 16842, 16842, 324042, 16842, 16842, 16842,
  16842, 16842, 291761, 16842, 17331, 16842, 17333, 16842, 16842, 16842, 16842, 16842, 16842, 17538, 17539, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17542, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17091,
  16842, 16842, 16842, 17097, 16842, 16842, 16842, 16842, 17111, 16842, 16842, 16842, 16801, 480, 0, 0, 762, 763, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111074, 111074, 111074, 111074, 561, 0, 0, 0, 762, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  88064, 0, 0, 0, 88064, 816, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415,
  45415, 45415, 16842, 17305, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17322,
  16842, 16842, 16842, 16842, 16842, 362954, 16842, 16842, 17819, 16842, 16842, 16801, 1325, 1326, 1327, 1328, 0, 754,
  0, 756, 0, 758, 0, 994, 0, 0, 0, 0, 0, 0, 0, 0, 1033, 0, 0, 0, 0, 0, 0, 0, 17465, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 0, 16801, 16801, 16801, 16801, 17254, 16801,
  16801, 0, 914, 0, 916, 15253, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17519, 16842, 16842,
  16842, 16842, 17095, 16842, 17099, 16842, 17102, 16842, 16842, 17112, 16842, 16842, 17037, 480, 0, 0, 0, 1231, 0,
  46289, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 46435, 45415, 0, 0, 0, 0, 1248, 0, 0,
  16801, 17635, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 0, 16801, 16801,
  16801, 17285, 16801, 16801, 16801, 391585, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 0, 16801, 17283, 16801, 16801, 16801, 16801, 17288, 17695, 16842, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 391626, 16842, 16842, 16842, 0, 16801, 16801, 16842, 16842,
  16801, 16842, 18173, 18174, 16801, 16842, 16801, 16842, 346112, 0, 0, 0, 0, 1347, 0, 0, 0, 0, 0, 0, 1354, 0, 0, 0, 0,
  0, 505, 506, 0, 509, 510, 0, 0, 0, 0, 0, 0, 0, 45429, 45429, 0, 45429, 395, 0, 45429, 45429, 395, 16842, 17803, 16842,
  17805, 16842, 16842, 16842, 16842, 16842, 17809, 16842, 16842, 16842, 16842, 16842, 16842, 17904, 16842, 16842, 16842,
  16842, 17909, 16801, 16842, 0, 0, 16842, 16842, 346570, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16801,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1453, 0, 399360, 0, 0, 0, 0, 1457, 0, 0, 1459, 0, 0, 0, 0, 268, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 552, 0, 0, 0, 0, 0, 0, 1464, 0, 0, 1467, 0, 0, 0, 0, 0, 45415, 45415, 45415, 45415, 45415, 45415, 45415,
  45415, 45415, 45415, 46296, 16801, 16801, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17895, 16842,
  16842, 16842, 16842, 16842, 0, 0, 1715, 0, 0, 1718, 0, 16801, 16801, 16801, 16801, 16801, 16801, 17773, 16801, 16801,
  16801, 16801, 17776, 16801, 16801, 16801, 16801, 16801, 16801, 17945, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  246177, 16801, 16801, 16801, 16801, 0, 0, 156229, 0, 0, 0, 0, 17015, 16801, 16801, 16801, 16801, 0, 554, 0, 546, 0, 0,
  0, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  17669, 16842, 17957, 16842, 16842, 16842, 16842, 16842, 16842, 17964, 246218, 16842, 16842, 16842, 17967, 16842,
  16842, 16842, 16842, 16842, 17525, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17532, 16842, 16842, 16842, 16842,
  16842, 17700, 16842, 16842, 16842, 16842, 16842, 17704, 16842, 16842, 16842, 16842, 16842, 0, 1591, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 811, 0, 0, 0, 0, 0, 0, 16801, 16801, 182689, 17990, 17991, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 17997, 0, 0, 0, 45415, 16801, 16801, 16801, 16801, 16801, 18026, 16801, 16801, 16801, 16801,
  16801, 16801, 455, 456, 0, 16842, 16842, 16842, 16842, 16842, 17084, 16842, 16842, 16842, 16842, 18034, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 288768, 16842, 16842, 16842, 16842, 18065,
  16842, 16842, 16842, 16842, 0, 186368, 0, 0, 0, 0, 0, 0, 855, 0, 857, 17242, 16801, 16801, 16801, 16801, 16801, 16801,
  0, 0, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17801, 16801, 16801, 16801, 18110, 16801, 18112, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 18119, 16842, 18121, 16801, 16801, 16842, 16842, 18161, 18162, 16842, 16842, 0, 0,
  0, 16801, 16801, 16801, 16801, 16842, 16842, 16842, 16842, 16842, 16842, 1769, 0, 1771, 16801, 16801, 16801, 16801, 0,
  617, 0, 0, 0, 0, 617, 16801, 16801, 16801, 16801, 16801, 17483, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 17784, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 0, 0, 289, 0, 36864, 38912, 0, 288, 0,
  290, 290, 289, 34816, 289, 289, 342, 289, 0, 289, 289, 342, 357, 357, 45426, 45426, 357, 45426, 394, 357, 45426,
  45426, 394, 357, 45426, 394, 357, 402, 357, 357, 357, 357, 409, 357, 357, 357, 357, 357, 357, 16812, 357, 357, 357,
  357, 357, 357, 45426, 357, 45426, 357, 16812, 16854, 16812, 16812, 16854, 16812, 16854, 16812, 16812, 16812, 16812,
  16812, 16812, 16812, 16854, 16854, 16854, 16854, 16854, 16854, 16854, 16812, 16812, 16854, 1, 8194, 3, 4, 41199,
  41199, 47345, 0, 0, 0, 0, 0, 0, 0, 495, 0, 0, 0, 0, 0, 0, 498, 0, 0, 501, 502, 0, 262, 263, 0, 265, 266, 0, 0, 0, 0,
  0, 513, 0, 514, 515, 516, 517, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96640, 0, 0, 0, 96640, 45415, 45415, 45415, 45415,
  379239, 45415, 45415, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 764, 0, 0, 0, 516, 0, 0, 0, 0, 0, 621, 0, 0, 571, 571, 0, 0, 0,
  415, 416, 16801, 16801, 17018, 17021, 16801, 17027, 16801, 16801, 16801, 17033, 16801, 16801, 16801, 16801, 17042,
  379297, 17027, 16801, 17059, 16801, 17042, 379297, 455, 456, 0, 16842, 16842, 16842, 17077, 17080, 16842, 17086,
  16842, 16842, 16842, 17094, 17096, 16842, 16842, 16842, 17105, 379338, 16842, 16842, 16842, 16842, 16801, 480, 561, 0,
  0, 0, 0, 0, 807, 0, 0, 0, 0, 0, 0, 0, 814, 0, 0, 0, 0, 16801, 0, 0, 0, 0, 0, 0, 45415, 0, 45415, 0, 16801, 16801,
  16801, 16801, 16801, 18082, 16801, 16801, 16801, 16801, 16842, 16842, 16842, 18090, 16842, 16801, 16801, 16801, 17259,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17270, 16801, 16801, 16801, 16842, 158154, 16842,
  16842, 16842, 16842, 16842, 16842, 239190, 16842, 16842, 333400, 16842, 16801, 16801, 16801, 17292, 16801, 16801,
  16801, 16801, 0, 914, 916, 0, 15253, 17242, 16842, 16842, 16842, 16842, 16842, 17903, 16842, 16842, 16842, 16842,
  16842, 16842, 16801, 16842, 0, 0, 0, 0, 287, 288, 289, 290, 0, 0, 0, 0, 0, 0, 0, 0, 1338, 0, 0, 0, 0, 0, 0, 0, 0, 974,
  976, 0, 17336, 47846, 0, 0, 0, 0, 0, 0, 0, 0, 0, 752, 754, 0, 0, 756, 758, 0, 759, 0, 0, 1043, 0, 0, 0, 45415, 45415,
  45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 0, 0, 0, 0, 0, 0, 1071, 1248, 0, 1070, 0, 0, 0, 0, 855, 0,
  857, 17242, 16801, 16801, 16801, 16801, 16801, 16801, 455, 456, 0, 16842, 16842, 16842, 16842, 16842, 17085, 16842,
  16842, 16842, 17549, 16842, 16842, 16842, 16842, 16801, 0, 970, 0, 972, 0, 974, 0, 976, 0, 1204, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 124928, 0, 17643, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 0, 17282, 16801, 16801, 16801, 16801, 16801, 16801, 0, 1359, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 249856, 0, 16801, 16801, 17889, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842,
  16842, 16842, 17898, 0, 0, 0, 1529, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 317440, 1200, 1201, 0, 45415, 46604, 45415,
  45415, 45415, 45415, 0, 0, 0, 16801, 16801, 16801, 17939, 16801, 16801, 16801, 16801, 17482, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17665, 16801, 16801, 16801, 16801, 16842, 16842, 16842, 16842,
  17959, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17821, 0, 0, 0, 0, 0, 0, 0, 45415,
  18022, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17650, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 18032, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 0, 0, 1659,
  0, 0, 0, 0, 16801, 0, 0, 0, 0, 0, 0, 45415, 0, 45415, 0, 16829, 16842, 18062, 16842, 16842, 16842, 16842, 16842,
  16842, 16842, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 526, 0, 16801, 18078, 16801, 16801, 16801, 16801, 18083,
  16801, 16801, 16801, 16842, 18088, 16842, 16842, 16842, 0, 16801, 16801, 16842, 16842, 18171, 18172, 16801, 16842,
  16801, 16842, 16801, 16842, 18092, 16842, 16842, 16842, 16842, 0, 0, 0, 0, 0, 0, 0, 16801, 16801, 16801, 16801, 18054,
  16801, 16801, 16801, 16801, 16801, 16842, 16801, 16801, 16842, 16842, 16842, 16842, 16842, 16842, 0, 1780, 0, 16801,
  16801, 16801, 16801, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 18005, 16842, 16842, 16842, 16842, 16842, 0, 0,
  0, 0, 0, 0, 0, 18104, 16801, 16801, 16801, 323, 319, 0, 0, 36864, 38912, 323, 319, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 0,
  518, 519, 0, 0, 0, 0, 0, 0, 0, 0, 0, 316, 0, 317, 0, 0, 0, 0, 0, 348, 0, 0, 0, 0, 0, 45415, 45415, 0, 45415, 0, 0,
  45415, 45415, 0, 0, 845, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 845, 0, 45415, 0, 0, 319, 0, 0, 0, 0, 319, 0, 0, 0, 0, 0, 0, 0,
  0, 323, 0, 0, 319, 0, 323, 16855, 16836, 16836, 16855, 16836, 16855, 16836, 16836, 16863, 16863, 16863, 16863, 16836,
  16855, 16855, 16855, 16855, 16855, 16855, 16870, 16836, 16836, 16855, 1, 8194, 3, 4, 41199, 41199, 0, 526, 0, 0, 0, 0,
  0, 0, 526, 0, 0, 0, 0, 0, 415, 416, 561, 0, 0, 805, 764, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159744, 0, 0, 415, 416,
  45415, 45886, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415,
  45415, 45897, 0, 855, 857, 0, 17242, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17255, 16801, 0,
  0, 0, 0, 16842, 17674, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 0, 0, 0, 0, 16801, 16801, 18143,
  16842, 17325, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17339,
  16842, 0, 974, 976, 0, 16842, 47846, 0, 0, 0, 0, 0, 0, 983, 0, 0, 752, 16801, 252321, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17881, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 17791, 16801, 16801, 16801, 16801, 0, 0, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17906,
  16842, 16842, 16842, 16801, 16842, 0, 0, 0, 0, 1663, 0, 1665, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16842, 18114, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 354762, 0, 1754, 0, 1756, 16801,
  16801, 16801, 0, 0, 0, 0, 229376, 0, 0, 0, 0, 0, 0, 0, 229376, 0, 415, 416, 297, 0, 0, 0, 0, 47345, 0, 0, 0, 291, 0,
  0, 0, 0, 0, 0, 297, 297, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 36864, 38912, 0, 0, 0, 0, 0,
  291, 34816, 291, 291, 291, 0, 291, 291, 291, 291, 291, 45427, 45427, 291, 45427, 0, 291, 45427, 45427, 0, 0, 0, 0,
  16813, 0, 0, 0, 0, 0, 0, 45415, 0, 45415, 0, 16836, 291, 45427, 0, 291, 0, 291, 291, 291, 291, 0, 291, 291, 291, 291,
  291, 291, 16814, 291, 291, 291, 291, 291, 291, 45427, 291, 45427, 291, 16814, 16856, 16814, 16814, 16856, 16814,
  16856, 16814, 16814, 16814, 16814, 16814, 16814, 16814, 16856, 16856, 16856, 16856, 16856, 16856, 16856, 16814, 16814,
  16856, 1, 8194, 3, 4, 41199, 41199, 47345, 0, 0, 0, 0, 0, 0, 0, 0, 0, 497, 0, 0, 0, 0, 0, 0, 1007, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1365, 0, 0, 0, 0, 0, 0, 527, 528, 0, 0, 0, 0, 0, 0, 297, 297, 297, 0, 0, 0, 0, 0, 61440, 61440, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 315392, 617, 0, 0, 0, 0, 0, 0, 0, 558, 0, 0, 0, 561, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 812, 0, 0, 0, 0,
  0, 0, 0, 315919, 0, 45415, 45415, 45415, 45415, 45415, 45415, 45654, 45415, 45415, 45415, 45415, 45415, 45415, 46115,
  45415, 45415, 45415, 45415, 0, 0, 0, 0, 0, 0, 750, 0, 752, 754, 0, 0, 756, 758, 0, 0, 45415, 315996, 45415, 45415,
  45664, 45415, 45415, 0, 0, 0, 0, 567, 0, 0, 0, 0, 527, 0, 0, 575, 0, 0, 0, 0, 0, 0, 0, 1221, 0, 0, 0, 0, 0, 0, 0, 0,
  1019, 0, 0, 0, 0, 0, 0, 0, 0, 315392, 0, 0, 0, 0, 0, 0, 315920, 0, 0, 0, 0, 0, 415, 416, 16801, 16801, 16801, 17060,
  16801, 17044, 455, 456, 0, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17554, 0, 970, 0, 972, 0, 974, 0, 976,
  17088, 16842, 16842, 16842, 16842, 316106, 17100, 16842, 16842, 17109, 16842, 16842, 16842, 16842, 17115, 480, 481, 0,
  483, 484, 0, 17125, 0, 4, 41199, 47846, 0, 0, 0, 0, 0, 0, 297, 297, 0, 0, 0, 0, 0, 766, 0, 0, 0, 241664, 0, 0, 0, 0,
  0, 0, 752, 754, 0, 0, 756, 758, 0, 0, 0, 0, 295, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32768, 0, 0, 0, 0, 0, 0, 561, 0,
  804, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1369, 1370, 0, 0, 0, 818, 819, 0, 0, 0, 0, 0, 0, 45415, 45415, 45415,
  45415, 45415, 45415, 45415, 45415, 45415, 46110, 16801, 16801, 242081, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 17268, 16801, 16801, 16801, 16801, 17497, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 18113, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 1686, 0, 1687, 0, 0, 1690,
  0, 0, 974, 976, 0, 16842, 47846, 0, 0, 0, 980, 0, 0, 0, 0, 0, 752, 16801, 17494, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 356769, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 0, 914, 0, 916, 15253, 16842, 16842, 17512, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 18069, 0,
  0, 0, 1688, 0, 0, 0, 16842, 16842, 16842, 17550, 16842, 17552, 16842, 16801, 0, 970, 0, 972, 0, 974, 0, 976, 0, 0, 0,
  1206, 0, 0, 0, 0, 0, 1211, 0, 0, 0, 0, 0, 0, 297, 297, 0, 0, 0, 0, 784, 765, 0, 0, 317799, 46297, 45415, 45415, 45415,
  45415, 45415, 45415, 0, 0, 0, 1247, 0, 0, 0, 0, 0, 0, 1539, 0, 0, 0, 1542, 0, 0, 0, 0, 45415, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17475, 16801, 16801, 16801, 16801, 16801, 17644, 16801,
  17646, 16801, 16801, 318705, 16801, 16801, 16801, 17653, 16801, 16801, 16801, 16801, 0, 378880, 0, 498, 0, 0, 378880,
  16801, 16801, 17052, 17053, 16801, 16842, 16842, 16842, 16842, 17699, 16842, 16842, 16842, 16842, 16842, 16842, 16842,
  16842, 16842, 16842, 16842, 17965, 17966, 16842, 16842, 16842, 17707, 16801, 0, 0, 0, 0, 0, 0, 0, 0, 16842, 0, 0, 0,
  0, 1333, 0, 16801, 16801, 16801, 16801, 17771, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  455, 456, 0, 16842, 16842, 16842, 17076, 16842, 16842, 16842, 16801, 16801, 16801, 17781, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 455, 456, 0, 16842, 16842, 17074, 16842, 17079, 16842, 16842,
  16842, 17815, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16801, 0, 0, 0, 0, 0, 0, 0, 0, 16842, 0,
  0, 1331, 0, 0, 151076, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842,
  16842, 16842, 17546, 375242, 1661, 0, 0, 0, 0, 18050, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 18058, 16801,
  18060, 18159, 16801, 16842, 16842, 16842, 16842, 18163, 16842, 196608, 0, 325632, 16801, 16801, 16801, 16801, 16842,
  16842, 16842, 182730, 18002, 18003, 16842, 16842, 16842, 16842, 16842, 16842, 18009, 16842, 16842, 16842, 253952,
  16801, 16801, 16842, 16842, 16801, 16842, 16801, 16842, 16801, 16842, 16801, 16842, 16842, 16842, 16842, 17309, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 17321, 16842, 16842, 16842, 16842, 16842, 17312, 16842, 17315, 16842,
  16842, 16842, 16842, 17320, 16842, 16842, 16842, 0, 16801, 16801, 16842, 16842, 16801, 16842, 16801, 16842, 16801,
  16842, 342433, 342474, 0, 0, 250, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1545, 0, 46603, 297, 0, 0, 0, 0, 47345, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 303, 317, 0, 0, 320, 0, 0, 0, 0, 0, 322, 0, 0, 317, 0, 0, 0, 0, 0, 532, 533, 0, 297, 297, 297, 0,
  0, 0, 0, 0, 0, 0, 77824, 0, 0, 0, 77824, 77824, 0, 0, 0, 0, 0, 0, 36864, 38912, 0, 0, 332, 0, 0, 338, 34816, 338, 338,
  338, 0, 338, 338, 355, 355, 355, 45428, 45428, 355, 45428, 0, 355, 45428, 45428, 0, 0, 0, 0, 16818, 0, 0, 0, 0, 0, 0,
  45415, 0, 45415, 0, 16818, 355, 45428, 322, 355, 0, 355, 355, 355, 355, 0, 355, 355, 355, 355, 355, 355, 16815, 355,
  355, 355, 355, 355, 355, 45428, 437, 45428, 442, 16837, 16857, 16837, 16837, 16857, 16837, 16857, 16837, 16837, 16837,
  16837, 16837, 16837, 16837, 16857, 16857, 16857, 16857, 16857, 16857, 16857, 16837, 16837, 16857, 1, 8194, 3, 4,
  41199, 41199, 0, 0, 0, 0, 155648, 0, 561, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 139264, 0, 0, 0, 0, 0, 0, 0, 274432, 0,
  274432, 0, 0, 0, 0, 0, 581, 0, 274432, 415, 416, 16801, 17015, 16801, 16801, 16801, 16801, 16801, 274849, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 1287, 1288, 16842, 17796, 16842, 16842, 16842, 16842, 16842, 16842,
  17686, 16842, 16842, 252362, 16842, 16842, 16842, 16842, 16842, 16842, 17701, 16842, 16842, 16842, 16842, 16842,
  16842, 16842, 16842, 16842, 0, 0, 0, 0, 16801, 16801, 16801, 16801, 274849, 16801, 16801, 16801, 16801, 455, 456, 0,
  16842, 17072, 16842, 16842, 16842, 16842, 16842, 0, 0, 0, 0, 0, 0, 1595, 0, 0, 0, 0, 16842, 274890, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16801, 480, 481, 0, 483, 484, 0, 16842, 0, 4,
  41199, 47846, 0, 0, 743, 0, 0, 0, 0, 0, 545, 0, 0, 0, 576, 0, 0, 0, 0, 0, 0, 0, 578072, 0, 0, 0, 0, 0, 0, 0, 0, 297,
  297, 297, 0, 0, 0, 0, 540, 45885, 45415, 45415, 45415, 45415, 45415, 45415, 45890, 45415, 45415, 45415, 45415, 45415,
  45415, 45415, 45415, 1244, 0, 1246, 0, 0, 0, 0, 1248, 0, 855, 857, 0, 17242, 16801, 16801, 17245, 16801, 16801, 17252,
  16801, 16801, 17254, 16801, 16801, 16801, 17020, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 348577, 16801, 16801, 16801, 16801, 16801, 16801, 16842, 16842, 17306, 16842, 16842, 17314, 16842,
  16842, 17317, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17702, 16842, 16842, 16842, 16842, 16842, 16842, 16842,
  16842, 17332, 16842, 16842, 16842, 16842, 16842, 16842, 17340, 16842, 16842, 17326, 16842, 16842, 16842, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17692, 16842, 16842, 0, 974, 976, 0, 16842, 47846, 0, 0, 0, 0,
  0, 0, 0, 984, 0, 752, 0, 754, 0, 756, 0, 758, 0, 0, 0, 996, 0, 0, 0, 0, 0, 0, 297, 297, 0, 781, 0, 0, 0, 0, 0, 0, 0,
  55672, 55672, 376, 1, 8194, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 126976, 0, 0, 0, 126976, 0, 0, 0, 0, 0, 1015, 0, 0, 0, 1017,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 227328, 0, 0, 0, 773, 774, 0, 0, 996, 0, 0, 0, 855, 0, 857, 17242, 16801, 16801, 16801,
  16801, 16801, 16801, 17262, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17028, 16801, 16801, 16801,
  16801, 316044, 17038, 16801, 16801, 17044, 0, 0, 1205, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14336, 0, 0, 45415,
  45415, 46298, 45415, 45415, 45415, 45415, 45415, 0, 0, 0, 0, 0, 0, 0, 0, 1469, 1470, 0, 46528, 45415, 46530, 45415,
  45415, 0, 0, 17634, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17263,
  285089, 16801, 16801, 16801, 16801, 16801, 16801, 17271, 17272, 17670, 0, 0, 0, 0, 17673, 16842, 16842, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 17810, 16842, 16842, 16842, 16842, 16842, 0, 0, 1345, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 108544, 0, 0, 16801, 16801, 17792, 16801, 16801, 16801, 0, 0, 16842, 16842, 16842, 16842, 16842,
  16842, 16842, 16842, 365002, 16842, 381386, 16842, 16842, 16842, 16842, 16842, 17814, 16842, 16842, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 16801, 0, 0, 0, 0, 810, 16801, 16801, 16842, 16842, 16842, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 17896, 16842, 16842, 16842, 16842, 16842, 17960, 16842, 16842, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 16801, 0, 970, 972, 0, 0, 0, 0, 0, 337920, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  45415, 45415, 45415, 45415, 45415, 0, 0, 0, 1598, 0, 0, 1601, 0, 0, 0, 0, 45415, 45415, 45415, 45415, 348519, 0, 0, 0,
  0, 16820, 0, 0, 0, 0, 0, 0, 45415, 0, 45415, 0, 16820, 348618, 16842, 16842, 16842, 16842, 0, 0, 1630, 0, 1632, 0, 0,
  0, 0, 1636, 0, 0, 0, 0, 16842, 47846, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 291, 0, 0, 0, 0, 0, 0, 0, 16842, 16842, 16842,
  18064, 16842, 18066, 16842, 16842, 16842, 0, 0, 0, 0, 0, 0, 0, 0, 1185, 0, 1186, 0, 1187, 0, 1188, 0, 0, 0, 251, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 235520, 0, 0, 0, 0, 318, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 318, 0, 0, 0, 0, 0, 0, 0, 0,
  36864, 38912, 0, 0, 333, 0, 0, 0, 34816, 0, 0, 0, 0, 0, 581, 45415, 45644, 45415, 45415, 45415, 45415, 45415, 274791,
  45415, 45415, 399, 45429, 395, 399, 395, 399, 399, 399, 399, 395, 395, 395, 395, 395, 395, 395, 399, 16816, 395, 395,
  399, 395, 395, 395, 45429, 438, 45429, 443, 16838, 16858, 16838, 16838, 16858, 16838, 16858, 16838, 16838, 16838,
  16838, 16838, 16838, 16838, 16858, 16858, 16858, 16858, 16858, 16858, 16858, 16838, 16838, 16858, 1, 8194, 3, 4,
  41199, 41199, 47345, 0, 0, 0, 0, 0, 0, 0, 0, 496, 0, 0, 0, 0, 0, 0, 297, 297, 538, 0, 0, 0, 0, 0, 0, 0, 274, 0, 0, 0,
  0, 0, 0, 0, 0, 315, 0, 0, 0, 0, 0, 0, 0, 159744, 531, 0, 0, 159744, 0, 561, 0, 0, 0, 0, 563, 0, 0, 0, 0, 0, 0, 45415,
  45415, 45415, 45415, 46106, 45415, 45415, 45415, 45415, 45415, 45415, 0, 0, 0, 151057, 16801, 16801, 16801, 16801,
  16801, 16801, 1287, 1288, 16842, 16842, 17797, 16842, 17798, 16842, 16842, 16842, 0, 568, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 309248, 0, 0, 0, 585, 0, 0, 0, 45415, 45415, 45415, 45415, 45415, 45415, 256359, 45415, 287079, 45415,
  45415, 45415, 45415, 46606, 45415, 0, 0, 1552, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17296, 0, 914, 916, 0,
  15253, 17242, 16842, 16842, 45415, 45415, 45415, 45663, 45415, 45415, 45415, 0, 0, 0, 0, 256000, 0, 286720, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1020, 0, 0, 0, 0, 0, 0, 16801, 17057, 16801, 16801, 17043, 16801, 455, 456, 0, 16842, 17073, 16842,
  16842, 16842, 16842, 16842, 0, 0, 0, 0, 0, 1633, 0, 0, 0, 0, 0, 0, 855, 0, 857, 17242, 16801, 16801, 16801, 16801,
  17463, 17464, 256458, 17092, 287178, 16842, 16842, 16842, 16842, 16842, 17106, 16842, 16842, 16842, 16842, 16842,
  16801, 480, 481, 0, 483, 484, 0, 16842, 0, 4, 41199, 47846, 0, 0, 0, 744, 0, 0, 0, 0, 327, 327, 0, 0, 0, 0, 0, 0, 327,
  0, 0, 0, 0, 0, 0, 411648, 0, 411648, 0, 0, 0, 0, 0, 0, 411648, 0, 411648, 0, 0, 0, 411648, 0, 0, 0, 0, 0, 284672, 0,
  0, 0, 0, 0, 752, 754, 0, 0, 756, 758, 0, 0, 0, 0, 415, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 415, 0, 416, 0, 0, 0, 0, 0, 0, 0,
  0, 266240, 0, 0, 0, 0, 0, 0, 45415, 45415, 45415, 45415, 45652, 45415, 45415, 45415, 45415, 45415, 775, 0, 0, 0, 0, 0,
  297, 297, 0, 0, 782, 783, 0, 0, 0, 0, 0, 0, 45415, 45415, 45415, 45415, 229735, 45415, 45415, 45415, 45415, 45415,
  45415, 45415, 46117, 45415, 45415, 46120, 0, 0, 0, 0, 0, 0, 855, 0, 857, 17242, 16801, 16801, 16801, 17462, 16801,
  16801, 0, 817, 0, 0, 0, 0, 744, 0, 0, 0, 45415, 45415, 45415, 45415, 45415, 45415, 0, 0, 0, 16801, 16801, 16801,
  16801, 17940, 16801, 16801, 0, 855, 857, 0, 17242, 16801, 16801, 17246, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 17295, 16801, 0, 914, 916, 0, 15253, 17242, 16842, 16842, 17304, 16842, 17307, 16842, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17705, 17706, 16842, 16842, 16842, 17327, 16842,
  285130, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17337, 17338, 16842, 16842, 16842, 16842, 16842, 17961,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17968, 16842, 0, 754, 0, 756, 0, 758, 0, 0, 0, 0, 997, 0, 0,
  0, 0, 0, 0, 1195, 0, 0, 0, 0, 0, 0, 0, 0, 1202, 1002, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 98304, 1040, 0, 0,
  0, 0, 0, 45415, 175127, 45415, 45415, 45415, 45415, 45415, 46108, 45415, 45415, 45415, 45415, 45415, 45888, 45415,
  45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 0, 0, 0, 0, 0, 0, 0, 1248, 45415, 46111, 45415, 45415,
  45415, 45415, 45415, 45415, 45415, 45415, 45415, 175145, 0, 0, 1067, 0, 0, 0, 0, 16842, 47846, 0, 0, 0, 0, 0, 0, 0, 0,
  985, 0, 0, 0, 0, 1207, 0, 0, 0, 0, 0, 1212, 0, 0, 0, 0, 0, 0, 682, 683, 0, 0, 0, 0, 0, 0, 0, 0, 0, 376832, 401408, 0,
  0, 0, 0, 0, 0, 0, 997, 1065, 175145, 0, 855, 0, 857, 17242, 16801, 16801, 175157, 16801, 16801, 16801, 16801, 17658,
  16801, 17660, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 455, 456, 0, 16842, 16842, 16842, 16842,
  16842, 229834, 16842, 0, 914, 0, 916, 15253, 16842, 16842, 16842, 16842, 175210, 16842, 16842, 16842, 16842, 16842,
  16842, 18136, 16842, 16842, 190464, 0, 0, 0, 16801, 18142, 16801, 0, 0, 0, 1192, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  368640, 0, 0, 0, 0, 45415, 45415, 45415, 45415, 364903, 381287, 45415, 45415, 0, 0, 0, 0, 380928, 0, 0, 0, 0, 0, 614,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1366, 0, 0, 0, 0, 0, 0, 0, 0, 366592, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 416141, 397,
  0, 0, 416141, 45415, 45415, 46430, 45415, 45415, 233831, 45415, 45415, 45415, 45415, 45415, 0, 233472, 0, 0, 0, 0, 0,
  686, 686, 686, 686, 686, 686, 686, 686, 686, 686, 686, 629, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17767, 16801, 16801, 17770,
  16801, 16801, 16801, 16801, 233889, 16801, 262561, 16801, 16801, 16801, 16801, 585, 0, 0, 0, 286720, 665, 0, 17050,
  16801, 16801, 16801, 16801, 553, 0, 0, 0, 0, 0, 0, 16801, 16801, 16801, 16801, 17054, 16801, 324001, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17484, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 17499, 16801, 16801, 16801, 16801, 16801, 16801, 17504, 375201, 16801, 17822,
  268288, 0, 0, 0, 0, 0, 0, 0, 188416, 0, 0, 200704, 217088, 0, 0, 0, 0, 416, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 416, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1216, 0, 0, 0, 1465, 0, 0, 0, 329728, 0, 0, 0, 45415, 45415, 45415, 201063,
  45415, 45415, 45415, 45415, 242023, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415,
  45415, 45415, 45415, 45896, 45415, 16801, 16801, 16842, 16842, 16842, 16842, 16842, 184778, 16842, 201162, 16842,
  16842, 217546, 16842, 16842, 16842, 0, 16801, 18169, 16842, 18170, 16801, 16842, 16801, 16842, 16801, 16842, 16801,
  16842, 16842, 16842, 17958, 16842, 16842, 16842, 214570, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842,
  16842, 16842, 18041, 16842, 305152, 0, 0, 0, 16842, 16842, 17972, 16842, 16842, 0, 0, 0, 0, 1593, 0, 0, 0, 0, 0, 0,
  297, 297, 23065, 25357, 0, 0, 0, 0, 0, 0, 0, 77824, 0, 0, 77824, 77824, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 480, 481,
  483, 484, 17998, 16801, 16801, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 272842, 16842, 16842,
  16842, 0, 205217, 16801, 205258, 16842, 16801, 16842, 16801, 16842, 16801, 16842, 16801, 16842, 16842, 18010, 16842,
  16842, 16842, 303104, 0, 0, 0, 0, 0, 370688, 0, 0, 0, 0, 0, 0, 45415, 45415, 45415, 46105, 45415, 45415, 45415, 45415,
  45415, 45415, 0, 0, 0, 16801, 16801, 16801, 16801, 16801, 213409, 16801, 0, 409600, 0, 45415, 16801, 204391, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 18030, 16801, 16801, 16801, 17048, 0, 0, 0, 0, 0, 0, 0, 16801, 16801, 16801,
  16801, 229793, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17948, 214557, 16801,
  16801, 16801, 16801, 16801, 17955, 16842, 204401, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 18040, 16842,
  16842, 0, 0, 0, 0, 1442, 1443, 0, 0, 0, 0, 0, 0, 0, 0, 0, 810, 0, 0, 0, 0, 0, 0, 0, 0, 194560, 354304, 0, 0, 0, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 354721, 16801, 18145, 18146, 16842, 16842, 16842, 16842, 18151,
  18152, 0, 1770, 0, 16801, 16801, 16801, 16801, 16801, 17772, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 0, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17777, 16801, 16801, 0,
  45430, 396, 0, 396, 0, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 16817, 396, 396, 396, 396, 396, 396, 45430,
  396, 45430, 396, 16817, 16859, 16817, 16817, 16859, 16817, 16859, 16817, 16817, 16817, 16817, 16817, 16817, 16817,
  16859, 16859, 16859, 16859, 16859, 16859, 16859, 16817, 16817, 16859, 1, 8194, 3, 4, 41199, 41199, 0, 0, 543, 0, 0,
  546, 0, 0, 0, 0, 0, 0, 0, 554, 0, 0, 0, 0, 503, 262, 263, 0, 265, 266, 0, 0, 0, 0, 0, 0, 297, 297, 0, 0, 0, 0, 0, 0,
  0, 786, 17056, 16801, 16801, 16801, 16801, 16801, 455, 456, 0, 16842, 16842, 16842, 16842, 16842, 16842, 17087, 760,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143360, 561, 0, 0, 0, 0, 806, 0, 0, 0, 0, 806, 0, 0, 0, 0, 0, 0, 1209, 0,
  0, 0, 0, 0, 1213, 0, 0, 0, 0, 855, 857, 0, 17242, 16801, 16801, 16801, 16801, 17249, 16801, 16801, 16801, 16801,
  16801, 16801, 17879, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 1287, 1288, 16842, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 17318, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842,
  17311, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 258506, 16842, 16842, 16842,
  16842, 0, 974, 976, 0, 16842, 47846, 0, 0, 979, 0, 0, 0, 0, 0, 0, 752, 16842, 16842, 17523, 16842, 16842, 16842,
  16842, 16842, 16842, 16842, 17530, 16842, 16842, 16842, 16842, 16842, 0, 0, 0, 0, 1717, 0, 1719, 16801, 18105, 16801,
  16801, 17534, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17541, 16842, 16842, 16842, 16842, 16842, 16842, 16842,
  17808, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17316, 16842, 16842, 17319, 16842, 16842, 16842, 16842,
  17681, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17693,
  16842, 16801, 16801, 16842, 16842, 17891, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842,
  356810, 16842, 16842, 16842, 16842, 0, 0, 0, 45415, 16801, 16801, 16801, 16801, 16801, 16801, 18027, 16801, 16801,
  16801, 16801, 16801, 17647, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 17655, 16801, 16801, 16842, 16842, 16842,
  16842, 18035, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 393216, 16842, 16842,
  18168, 0, 16801, 16801, 16842, 16842, 16801, 16842, 16801, 16842, 16801, 16842, 16801, 16842, 16842, 16842, 16842,
  17310, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 17690, 16842, 16842, 16842, 16842,
  0, 324, 0, 0, 36864, 38912, 0, 324, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 0, 765, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1223, 0, 0,
  0, 0, 0, 0, 45415, 0, 0, 324, 0, 0, 0, 0, 324, 0, 0, 0, 0, 0, 0, 455, 456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 124928, 0,
  124928, 124928, 0, 0, 124928, 16860, 16818, 16818, 16860, 16818, 16860, 16818, 16818, 16818, 16818, 16818, 16818,
  16818, 16860, 16860, 16860, 16860, 16860, 16860, 16860, 16818, 16818, 16860, 1, 8194, 3, 4, 41199, 41199, 0, 855, 857,
  0, 17242, 16801, 16801, 16801, 16801, 16801, 16801, 211361, 16801, 16801, 16801, 16801, 17023, 16801, 16801, 17030,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 16801, 0, 16801, 16801, 16801, 16801, 16801, 17287, 16801, 258407,
  45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 0, 0, 258048, 0, 0, 0, 0, 521, 0, 0, 0, 0, 0, 0,
  557, 521, 0, 415, 416, 17563, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 419840, 295, 0, 0, 0, 36864, 38912, 295, 0,
  0, 0, 0, 339, 34816, 339, 339, 339, 0, 339, 339, 339, 339, 339, 45431, 45431, 339, 45431, 0, 339, 45431, 45431, 0, 0,
  0, 0, 36864, 38912, 0, 0, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 0, 0, 61440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 339, 45431, 0,
  339, 0, 339, 339, 339, 339, 0, 339, 339, 339, 339, 339, 339, 16819, 339, 339, 339, 339, 339, 339, 45431, 339, 45431,
  339, 16819, 16861, 16819, 16819, 16861, 16819, 16861, 16819, 16819, 16819, 16819, 16819, 16819, 16819, 16861, 16861,
  16861, 16861, 16861, 16861, 16861, 16819, 16819, 16861, 1, 8194, 3, 4, 41199, 41199, 1217, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 411648, 0, 0, 0, 0, 405504, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65536, 0, 0, 65536, 65536, 65536,
  65536, 16862, 16820, 16820, 16862, 16820, 16862, 16820, 16820, 16820, 16820, 16820, 16820, 16820, 16862, 16862, 16862,
  16862, 16862, 16862, 16862, 16820, 16820, 16862, 1, 8194, 3, 4, 41199, 41199, 0, 0, 0, 613, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  613, 0, 0, 0, 0, 0, 0, 0, 624, 0, 415, 416, 561, 278528, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133120, 0, 0,
  16842, 16842, 16842, 17344, 16842, 16842, 16842, 16842, 16842, 16842, 16801, 0, 970, 972, 0, 0, 0, 0, 523, 620, 0, 0,
  0, 0, 0, 586, 523, 264807, 415, 416, 0, 974, 976, 0, 16842, 47846, 0, 0, 0, 0, 0, 0, 0, 0, 986, 752, 988, 754, 990,
  756, 992, 758, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79872, 0, 0, 0, 0, 0, 0, 1123, 914, 1125, 916, 15253, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 389578, 0, 0, 0, 0, 169984, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 137216, 137216, 137216, 382976, 0, 0, 0, 0, 0, 0, 0, 752, 754, 0, 0, 756, 758, 0, 0, 0, 0, 531, 0,
  0, 0, 297, 297, 297, 0, 0, 0, 0, 0, 0, 1031, 0, 0, 0, 0, 0, 0, 1037, 0, 1039, 0, 0, 777, 0, 0, 0, 297, 297, 0, 0, 0,
  0, 0, 0, 0, 0, 77824, 0, 0, 0, 0, 0, 0, 0, 16801, 16801, 16801, 383393, 16801, 16801, 16801, 16801, 0, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 17794, 0, 0, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 18068, 16842,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1446, 0, 0, 0, 1448, 0, 16842, 16842, 16842, 16842, 383434, 16842, 16842, 16842, 16842,
  16842, 16801, 0, 970, 972, 0, 0, 0, 0, 571, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 571, 0, 0, 45415, 45415, 45646, 45415,
  45415, 45653, 45415, 45415, 45415, 45658, 0, 754, 0, 756, 0, 758, 0, 0, 0, 0, 0, 998, 0, 0, 0, 0, 0, 0, 45415, 45415,
  46104, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 0, 0, 0, 522, 0, 0, 0, 0, 0, 0, 0, 311296, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 245760, 0, 0, 45415, 45415, 45415, 311655, 45415, 45415, 45415, 45415, 45415, 45415, 45415, 0, 0,
  0, 0, 0, 0, 1348, 1349, 0, 0, 0, 0, 0, 1355, 0, 0, 16801, 311713, 16801, 16801, 16801, 16801, 16801, 16801, 16801,
  16801, 16801, 16801, 16801, 16801, 16801, 16801, 219553, 16801, 16801, 17472, 16801, 16801, 16801, 16801, 16801,
  17477, 16801, 16842, 16842, 16842, 311754, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842, 16842,
  16842, 16842, 16801, 16842, 0, 0, 16842, 16842, 16842, 16842, 222485, 231882, 16842, 16842, 16842, 16842, 16842,
  16842, 16842, 16842, 16842, 16842, 17908, 16842, 16801, 16842, 1526, 0, 0, 0, 1528, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 110969, 0, 110969, 110969, 0, 0, 110969, 0, 349, 0, 0, 0, 0, 0, 45415, 45415, 0, 45415, 0, 0, 45415, 45415, 0,
  210944, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1541, 0, 0, 0, 0, 1546, 45415, 0, 0, 0, 0, 411648, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 297, 0, 0, 411648, 0, 0, 0, 411648, 0, 0, 411648, 411648, 0, 0, 0, 0, 411648, 411648, 0, 0, 0, 0,
  411648, 0, 411648, 411648, 0, 0, 0, 0, 411976, 411976, 411648, 0, 411648, 0, 0, 0, 411976, 0, 0, 0, 0, 0, 780, 297,
  297, 0, 0, 0, 0, 0, 0, 785, 0, 0, 0, 411648, 0, 0, 0, 0, 0, 0, 0, 411648, 0, 0, 0, 411648, 0, 0, 411648, 411648, 0,
  411648, 411648, 0, 0, 0, 0, 0, 411648, 0, 411648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 112640, 0, 0, 0, 0, 0, 0, 0, 0, 411648,
  0, 0, 0, 411648, 411648, 411648, 0, 1, 8194, 3, 4, 0, 0, 0, 0, 748, 749, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 278, 279, 0, 0,
  0, 0, 397, 0, 416141, 397, 416141, 397, 416141, 416141, 416141, 416141, 416141, 416141, 416141, 416141, 416141,
  416141, 0, 416141, 416141, 416141, 416141, 416141, 416141, 416141, 416141, 416141, 416141, 0, 0, 0, 0, 419840, 329,
  329, 0, 0, 0, 0, 0, 0, 329, 0, 0, 0, 0, 0, 792, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1471, 45415, 45415, 45415, 45415, 46531,
  0, 0, 0, 0, 419840, 419840, 419840, 0, 0, 419840, 0, 0, 419840, 0, 0, 0, 0, 0, 821, 743, 821, 0, 0, 45415, 45415,
  45880, 45415, 45884, 45415, 419840, 0, 0, 419840, 0, 419840, 419840, 419840, 419840, 0, 419840, 419840, 419840,
  419840, 419840, 419840, 419840, 419840, 419840, 419840, 0, 0, 0, 0, 419840, 0, 0, 0, 419840, 419840, 419840, 1, 8194,
  3, 4, 0, 0, 0, 0, 764, 0, 0, 0, 0, 769, 0, 0, 0, 0, 0, 0, 297, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 262, 0,
  0, 0, 4096, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  784, 836, 791, 793, 793, 798, 793, 794, 805, 809, 801, 813, 817, 821, 825, 829, 833, 2213, 1452, 2213, 1060, 2213,
  850, 840, 2213, 1503, 952, 940, 934, 968, 846, 1076, 2213, 1272, 1048, 2212, 849, 895, 854, 952, 952, 1280, 2248, 946,
  946, 969, 880, 859, 2255, 2213, 865, 850, 870, 2246, 952, 952, 952, 2250, 946, 946, 877, 884, 2213, 2213, 888, 893,
  897, 952, 952, 952, 901, 946, 946, 906, 918, 2213, 2213, 923, 952, 952, 966, 946, 927, 2254, 2213, 1119, 1278, 952,
  967, 947, 2213, 1118, 931, 952, 946, 2253, 1275, 952, 945, 2253, 951, 902, 2280, 2252, 2281, 937, 966, 941, 956, 963,
  960, 973, 1308, 1565, 977, 987, 987, 981, 985, 988, 992, 996, 1000, 1004, 1008, 1012, 1016, 1031, 1022, 2213, 1144,
  2213, 2213, 1035, 2213, 2306, 2213, 2213, 2213, 2213, 2213, 2213, 1040, 2213, 2213, 2213, 2213, 1362, 2213, 2213,
  2213, 2213, 2213, 2213, 2213, 2213, 2213, 1179, 2213, 2213, 2213, 2213, 1432, 2213, 2213, 2213, 2213, 2213, 2213,
  2213, 2213, 2213, 2213, 2213, 2213, 2213, 1467, 2213, 2213, 2213, 2213, 2213, 2213, 2213, 2213, 2213, 2213, 2213,
  1468, 2213, 2213, 2213, 2213, 2213, 2213, 2213, 2213, 1047, 2213, 2213, 2213, 2213, 2213, 1468, 2213, 2213, 2213,
  2213, 1469, 2213, 2213, 2213, 2213, 2213, 2213, 2213, 2213, 2213, 2213, 2213, 2213, 2213, 2213, 2213, 1446, 1052,
  1970, 1057, 2213, 855, 1073, 2213, 1080, 1084, 1088, 1092, 1096, 1100, 1104, 1925, 1036, 1111, 2213, 1117, 1123, 1331,
  1127, 2213, 1134, 1139, 1148, 1154, 2032, 2213, 1113, 1135, 1158, 1441, 1248, 1290, 1653, 2213, 1165, 1169, 2213,
  1710, 1678, 1183, 2213, 2213, 1189, 1195, 2213, 1149, 1794, 1207, 1494, 1214, 1235, 2213, 1247, 1218, 2213, 2213,
  2213, 1222, 1258, 2213, 1227, 1233, 2116, 1240, 2213, 1246, 1253, 2213, 2213, 2213, 1257, 2213, 1262, 1266, 1349,
  2267, 2067, 2213, 2213, 1284, 1236, 1344, 1294, 1592, 1306, 2213, 1312, 1318, 1347, 2022, 1322, 1943, 1229, 1328,
  1335, 1341, 1201, 1202, 1355, 1203, 1356, 1829, 1177, 1360, 1832, 1366, 1893, 2213, 2213, 2115, 2213, 842, 2213, 2213,
  1370, 1374, 1378, 1382, 1386, 1390, 1394, 1398, 1400, 1118, 2213, 1287, 2082, 1404, 2213, 1411, 1418, 909, 1422, 1426,
  1430, 1558, 1436, 1440, 2213, 1445, 1287, 2083, 1405, 1517, 1510, 1450, 1069, 1933, 1456, 1607, 2213, 2206, 1457,
  2213, 2213, 1470, 1462, 1474, 1533, 1480, 1242, 2213, 1484, 2213, 1950, 2214, 1488, 2213, 2213, 2213, 1027, 1492,
  1544, 1498, 1983, 1324, 1502, 1949, 2214, 1507, 2213, 2213, 1693, 1514, 1706, 1521, 1269, 1735, 1525, 1530, 2213,
  1302, 1465, 1537, 1314, 2003, 1337, 2213, 2261, 2093, 1414, 1997, 1541, 2213, 1548, 1552, 1650, 1406, 1562, 1569,
  1585, 1575, 1586, 1602, 1555, 1717, 1583, 1907, 2055, 1590, 2213, 1596, 2213, 2213, 1600, 1606, 1839, 1611, 1886,
  1615, 1619, 1623, 1627, 1631, 1633, 2022, 1637, 1526, 1734, 1642, 1150, 1647, 1657, 1661, 1665, 1669, 1673, 2073,
  1677, 1682, 1759, 1686, 1927, 2213, 1643, 1692, 1783, 1697, 2090, 2213, 2010, 2213, 2081, 2213, 1714, 2213, 1752,
  2213, 1733, 1842, 1223, 2296, 1739, 2213, 2157, 1745, 2079, 2213, 1638, 1750, 2213, 1762, 2273, 2099, 1458, 1895,
  1740, 2213, 1756, 2037, 2213, 1571, 1235, 2016, 1746, 1407, 1918, 1741, 2233, 1768, 1773, 2158, 2213, 1778, 1577,
  1782, 1788, 1804, 2213, 1808, 1297, 1918, 1791, 1812, 1896, 1210, 1963, 1977, 1784, 1797, 1198, 1816, 1851, 1820,
  1852, 1826, 1836, 1845, 1849, 1688, 1844, 2213, 2213, 1856, 2213, 2213, 1174, 1351, 1191, 1720, 1860, 1864, 1868,
  1872, 1876, 1880, 1883, 2239, 1726, 2213, 1890, 1160, 1900, 1904, 1911, 1916, 1579, 2213, 2297, 1922, 1931, 1937,
  1941, 1947, 2213, 1176, 1161, 1954, 1960, 1912, 1967, 2213, 1774, 1974, 1981, 2213, 873, 1703, 1987, 2213, 1991, 1185,
  1995, 2001, 2007, 1969, 2213, 2293, 1476, 2213, 2213, 1700, 2014, 2020, 2227, 2026, 2030, 2036, 2041, 2213, 1956,
  2048, 1235, 2213, 2045, 2052, 2213, 2059, 2063, 1063, 2213, 2071, 2077, 889, 2087, 2097, 2103, 2216, 1178, 2107, 2114,
  1043, 2120, 2124, 1172, 2129, 919, 2133, 2164, 1066, 2137, 2141, 861, 2222, 2148, 2145, 2149, 2153, 2110, 1800, 2162,
  2168, 2172, 2175, 2213, 1142, 2213, 2213, 2125, 1723, 1107, 2179, 1130, 2183, 2187, 2191, 2195, 2199, 2203, 2213,
  2213, 2213, 1729, 2156, 2210, 914, 2213, 913, 2255, 2213, 2213, 2232, 2213, 786, 2213, 2213, 2213, 2220, 866, 1019,
  1301, 2213, 2226, 2213, 2213, 2231, 2213, 2213, 2213, 787, 2213, 2213, 1728, 2237, 2243, 2259, 912, 2213, 2213, 1769,
  2286, 2213, 2213, 2213, 2265, 2213, 2213, 2271, 2277, 2259, 1708, 2213, 2213, 2285, 2213, 2213, 1769, 2286, 2213,
  2290, 2301, 2213, 2213, 1822, 2213, 2213, 1764, 2213, 1025, 1249, 2213, 2216, 2213, 2215, 2213, 1053, 2213, 2216,
  2213, 2065, 1300, 2213, 2213, 2213, 2304, 2213, 2213, 2213, 2213, 2213, 2213, 2213, 2213, 2213, 2213, 2213, 2423,
  2310, 2436, 2436, 2441, 3693, 2436, 3753, 3157, 3160, 3160, 3160, 3160, 2337, 3750, 2327, 2340, 3160, 2356, 2364,
  2370, 3159, 3160, 3161, 3159, 2342, 2334, 3160, 2346, 2382, 2375, 2374, 2385, 2367, 2379, 2389, 2393, 2405, 2407,
  2411, 2415, 2430, 2418, 2421, 3056, 2434, 2436, 2871, 3895, 2436, 3226, 3778, 2436, 2318, 2321, 2863, 2359, 2360,
  2436, 2436, 2445, 2965, 2498, 3953, 3540, 2436, 2436, 3838, 2359, 2359, 3841, 2436, 2436, 2436, 2443, 3909, 3778,
  2436, 2436, 2452, 3862, 2520, 2436, 2436, 2436, 2446, 2359, 2359, 3840, 2436, 2436, 3843, 3700, 2487, 2481, 2526,
  2533, 2490, 2436, 3225, 2399, 2436, 3907, 3776, 2762, 2436, 2436, 2436, 2453, 2436, 3839, 2359, 2359, 2359, 2359,
  2436, 3139, 3144, 2487, 2487, 2487, 2436, 2483, 2531, 2500, 2436, 2436, 3877, 2436, 2436, 3897, 2436, 2436, 2784,
  3909, 2436, 2436, 2436, 2455, 2359, 2359, 3840, 2781, 2487, 2487, 2481, 2531, 2359, 3841, 3140, 3141, 3143, 2480,
  2487, 2399, 2436, 3141, 2436, 2781, 3141, 3141, 3142, 2487, 2487, 2487, 2487, 2398, 2767, 3141, 3141, 3141, 3141,
  2487, 2487, 2399, 3140, 3143, 2487, 2781, 3142, 2487, 2399, 3141, 3143, 2487, 2487, 2487, 2482, 2527, 3145, 3143,
  2396, 2396, 2548, 3499, 2541, 2565, 2545, 2552, 2559, 2577, 2563, 2546, 2547, 2547, 2547, 2547, 3500, 2575, 2569,
  2547, 2572, 2584, 2662, 2547, 2581, 2594, 2587, 2555, 2598, 2602, 2607, 2606, 2611, 2614, 2352, 2633, 2636, 3921,
  3501, 2618, 2622, 2626, 2630, 2644, 2436, 2436, 3899, 2436, 2436, 4012, 2436, 2451, 2436, 2445, 3209, 2436, 2896,
  2436, 2436, 3535, 2922, 2436, 2436, 2436, 2684, 2653, 3835, 3460, 2436, 2456, 3819, 2695, 2874, 2436, 2436, 2436,
  2762, 3541, 2436, 2448, 2436, 2784, 2684, 2678, 2475, 2436, 2467, 2779, 2436, 2436, 3770, 2436, 2436, 3829, 2461,
  3137, 2436, 3709, 3461, 2682, 4014, 2436, 2506, 3908, 3777, 3460, 2688, 2436, 3642, 2692, 3556, 2701, 2705, 2330,
  2709, 2715, 2711, 2716, 2720, 2723, 2727, 2731, 2735, 2730, 2739, 2742, 2742, 2742, 2745, 2748, 2751, 2754, 2436,
  2507, 2509, 3239, 2472, 2476, 2436, 2436, 2461, 3540, 2947, 2436, 2436, 2436, 2767, 2359, 2761, 2766, 2436, 2773,
  3294, 2801, 2805, 2436, 2507, 3913, 3925, 2811, 2436, 2436, 2436, 2777, 2818, 2906, 2823, 2436, 2509, 2436, 2436,
  3569, 3688, 2827, 2436, 2436, 2436, 2782, 2436, 2436, 3548, 3421, 2837, 3661, 2476, 2436, 2436, 2492, 2314, 3898,
  2807, 2436, 2436, 2860, 2436, 3454, 3196, 2436, 2512, 2436, 2436, 3552, 2436, 2511, 2436, 2436, 2436, 2819, 3167,
  2870, 2436, 2436, 2494, 3731, 2436, 3538, 2436, 2436, 2507, 2436, 2436, 3658, 2473, 2435, 2436, 3572, 2436, 2513,
  2436, 2436, 2941, 2909, 2514, 3521, 2883, 2436, 2640, 2436, 2780, 2833, 2862, 3433, 2890, 2436, 3434, 2889, 2349,
  2894, 2436, 2436, 2436, 2813, 2784, 2937, 2438, 2436, 3301, 2436, 2514, 3892, 2776, 2436, 2436, 2436, 2783, 3433,
  3185, 2776, 2436, 2436, 3137, 2436, 3652, 2436, 2436, 2436, 2784, 2436, 2436, 3434, 3184, 2349, 2436, 3660, 2475,
  2436, 2436, 2784, 2438, 2436, 2515, 3893, 2436, 2767, 2436, 2647, 3246, 2436, 2672, 2504, 2436, 2436, 3838, 3840,
  3139, 3141, 3141, 3140, 3141, 2436, 3659, 2474, 2436, 2756, 2966, 2436, 2775, 3887, 2440, 2767, 3433, 3894, 2436,
  2777, 2944, 2436, 2781, 2436, 2436, 2436, 3936, 3433, 2928, 2436, 2436, 2537, 2776, 3659, 3402, 2436, 2436, 2646,
  3727, 2782, 2438, 2436, 3300, 2926, 3895, 2436, 2436, 2647, 3230, 2933, 2436, 3417, 2436, 2789, 2436, 3562, 2510,
  3884, 2436, 2436, 2648, 3257, 2436, 3576, 3402, 2439, 2436, 3300, 3894, 2768, 2900, 3895, 2436, 2436, 2508, 2510,
  2909, 2512, 2436, 2510, 2436, 2952, 3075, 2436, 2436, 2659, 2436, 2510, 2436, 2439, 2513, 3582, 3416, 3007, 2970,
  2978, 2436, 2436, 2447, 2986, 3334, 2917, 2873, 3004, 2871, 3324, 3013, 3017, 3021, 3024, 3029, 3025, 3033, 3036,
  3038, 3039, 3043, 3038, 3047, 3050, 3050, 3050, 3050, 3052, 2436, 3060, 3068, 2436, 2436, 2436, 2919, 2436, 3580,
  3780, 2921, 3897, 2436, 2436, 3726, 3080, 2436, 3088, 3092, 3127, 3098, 2436, 3104, 3133, 3110, 2436, 3114, 3542,
  3121, 2436, 2436, 2666, 2436, 3125, 2436, 2436, 3409, 3131, 2436, 2436, 2436, 2947, 2769, 2436, 2436, 2436, 3063,
  3150, 2903, 2436, 2436, 2674, 2460, 3232, 3820, 2436, 2436, 2436, 3071, 2505, 2436, 2436, 4005, 3218, 2436, 2436,
  2873, 2436, 2436, 2436, 2757, 3253, 2917, 2436, 2436, 2785, 3719, 2436, 3899, 2661, 3177, 2647, 3181, 3189, 2440,
  2649, 3204, 3259, 2440, 3581, 3217, 2436, 2436, 2806, 2436, 2436, 3899, 3009, 3579, 3236, 2436, 2436, 2436, 3139,
  2649, 3205, 3173, 2436, 2797, 2436, 3094, 2436, 4006, 3219, 2436, 2830, 2436, 3955, 2445, 3570, 2436, 3571, 2874,
  2436, 2436, 2441, 3398, 2649, 3250, 2440, 2436, 2830, 2436, 3956, 2919, 2436, 3897, 2661, 2436, 3773, 3252, 2436,
  2830, 3780, 2921, 2918, 2436, 3898, 3899, 2879, 3279, 2436, 3286, 2875, 3291, 2436, 2839, 2436, 3408, 3921, 3478,
  3285, 2436, 2849, 3496, 3896, 3445, 3292, 2436, 2436, 2875, 3963, 3290, 2436, 2436, 2918, 2436, 2436, 2912, 2669,
  3343, 2436, 2918, 2992, 3285, 2436, 3290, 3674, 3915, 2436, 2436, 2916, 2436, 3419, 2436, 2436, 3311, 3318, 3400,
  2436, 2436, 2919, 2993, 2778, 2436, 2436, 2436, 3154, 3076, 3328, 2921, 2779, 3340, 2470, 3347, 3354, 3350, 3357,
  3360, 3367, 3364, 3371, 3375, 3377, 3378, 3382, 3377, 3386, 3389, 3389, 3389, 3389, 3391, 2436, 3671, 2436, 2436,
  2436, 3307, 2436, 3275, 2990, 2436, 2436, 2436, 3406, 2814, 2436, 2879, 3447, 2436, 2846, 2843, 2853, 2436, 3427,
  2436, 3413, 3426, 2436, 2436, 3442, 2436, 3832, 3431, 2400, 3439, 3791, 3667, 3451, 2436, 3784, 3471, 2776, 3465,
  2436, 2436, 2436, 3453, 3469, 3475, 2436, 2936, 3669, 3673, 2436, 2436, 2945, 2436, 2783, 2436, 2436, 2445, 2513,
  2436, 3900, 3482, 2436, 2885, 3700, 3321, 3723, 3211, 2436, 2918, 2436, 3896, 2436, 2436, 2867, 2436, 3901, 3505,
  3488, 2436, 2920, 3298, 2436, 2877, 2792, 2506, 2506, 3225, 2436, 2878, 2436, 2436, 3000, 2436, 2436, 3509, 2943,
  2436, 2436, 2436, 3394, 3314, 3580, 2436, 2996, 2436, 2997, 3487, 2436, 2436, 2436, 3681, 3515, 3489, 2436, 2436,
  2973, 3293, 2875, 3929, 2776, 2436, 2937, 2436, 3418, 3672, 2436, 2436, 2981, 2436, 3528, 2436, 2436, 2436, 3690,
  3813, 2436, 2436, 2436, 3698, 2974, 2436, 2436, 3715, 2445, 3073, 2436, 2436, 2436, 3546, 2998, 2998, 2436, 2875,
  2999, 3899, 2436, 2937, 2437, 2436, 2640, 2436, 2514, 2436, 2450, 3861, 3084, 2436, 2436, 3812, 3525, 2436, 2436,
  2639, 3532, 2436, 2436, 3814, 2436, 3573, 2436, 3293, 2436, 3575, 2436, 2436, 2982, 2436, 3575, 2436, 2945, 2436,
  2951, 2439, 2513, 2436, 2956, 2512, 3573, 2436, 3572, 2436, 2959, 2436, 2872, 2988, 2436, 2436, 2946, 2436, 3575,
  2436, 3575, 2436, 2435, 3572, 2436, 2436, 3577, 2436, 2436, 2876, 3560, 2436, 3566, 2795, 2425, 3054, 3586, 3588,
  3592, 3596, 3623, 3598, 3602, 3606, 3609, 3611, 3612, 3616, 3620, 3627, 3630, 3630, 3636, 3630, 3632, 3640, 2436,
  2961, 3332, 2655, 3938, 3554, 2436, 2511, 2436, 2440, 2436, 2436, 2996, 3814, 3566, 2436, 3581, 2944, 3574, 2436,
  2441, 2436, 2994, 2919, 2993, 2697, 2436, 2436, 2436, 3743, 3281, 3649, 2436, 2436, 3072, 2436, 3708, 3656, 3665,
  2436, 3064, 2436, 2436, 2461, 3511, 3843, 3678, 2436, 2436, 3116, 3149, 2436, 3844, 3685, 3211, 2436, 3212, 2436,
  3576, 3401, 2436, 3580, 2876, 2436, 2436, 3193, 2436, 2436, 2590, 3572, 2436, 2436, 3199, 3757, 2442, 2436, 3738,
  2436, 3073, 2436, 3733, 2435, 2436, 3760, 2436, 2436, 2436, 3780, 3704, 3708, 3713, 2436, 3082, 2436, 3812, 3843,
  3719, 2436, 2436, 3223, 2436, 2436, 3213, 3223, 2877, 2436, 3938, 3554, 2512, 3581, 2323, 2436, 2436, 3272, 2436,
  2443, 3737, 2436, 2436, 3393, 3274, 2436, 3742, 3760, 2436, 3100, 3486, 2776, 3766, 3780, 2436, 2436, 3417, 3672,
  2426, 2875, 2436, 2436, 3420, 2436, 2522, 2436, 2492, 2314, 3898, 3336, 2436, 2436, 3422, 2838, 2443, 2436, 2436,
  2436, 3814, 3241, 3759, 2436, 3760, 2455, 3871, 3764, 3074, 2436, 2436, 2463, 3782, 2436, 3781, 2875, 3293, 3305,
  2995, 3940, 2513, 2437, 2314, 3804, 3575, 2436, 2444, 2436, 2436, 3435, 2929, 3198, 3242, 2436, 2436, 3458, 2436,
  2462, 3875, 2436, 2436, 3493, 2436, 2436, 2436, 3581, 3060, 3869, 3873, 3821, 2436, 3106, 2401, 2436, 2918, 2436,
  3897, 3783, 2878, 2436, 2436, 3519, 2436, 3798, 2436, 2313, 3732, 2453, 3788, 2436, 2461, 3855, 2436, 3853, 3810,
  2436, 2436, 2436, 3842, 2436, 2878, 2436, 3797, 2437, 3802, 2436, 2436, 2436, 3881, 2453, 3788, 2436, 3808, 3818,
  2436, 2436, 3825, 3849, 2436, 2436, 2454, 3848, 2440, 2762, 3779, 2436, 3266, 3779, 2516, 2436, 2452, 3854, 2436,
  3266, 3779, 3779, 2449, 2436, 2436, 2436, 3927, 3527, 2436, 3266, 3779, 2436, 2436, 2511, 3267, 2855, 2505, 2449,
  3268, 3266, 2436, 2856, 3859, 3866, 3866, 3919, 3917, 3793, 3905, 3890, 3933, 3920, 3944, 3947, 3960, 3950, 3970,
  3967, 3974, 3983, 3976, 3977, 3987, 3978, 3979, 3994, 3991, 3994, 3994, 3996, 4000, 4003, 2436, 3117, 3165, 3171,
  2445, 2510, 3416, 2436, 2436, 2436, 2436, 2441, 2436, 2436, 2436, 4010, 2436, 2449, 3862, 2436, 3898, 2436, 2436,
  2436, 3938, 2436, 3691, 2436, 2436, 2436, 3928, 2451, 2436, 2436, 2436, 3578, 2436, 2448, 2436, 3899, 2436, 3140,
  3141, 3141, 2487, 2480, 2487, 2487, 2399, 2436, 2436, 2436, 2505, 2782, 2436, 2436, 2436, 3581, 3263, 2436, 3692,
  2436, 2436, 3651, 2917, 3782, 2450, 2436, 2436, 3680, 2943, 2446, 2436, 3899, 2436, 3140, 3141, 3142, 2487, 3690,
  3694, 2436, 2436, 2436, 3780, 2436, 2452, 2436, 3200, 3747, 3074, 2436, 2436, 2436, 3646, 2446, 2436, 2436, 2783,
  2436, 2436, 2436, 3707, 2777, 524288, 4194304, 1073741824, -2147483648, 16384, 134217728, 32, 4096, 0, 1082130432,
  8388608, 8388608, 16777216, 268435456, 0, 0, 65536, 7680, 12582912, 553648128, 553648128, -2147483640, 553648128,
  553652224, 269639680, 1351680, -2130706432, 16777216, 16777472, 553648128, -2130706432, -2130706432, -2130706432,
  16777216, 16777216, 16777218, 1122304, 16777216, 16777216, 16777216, 33554432, 536870912, 0, -164575372, -164313228,
  -164100172, 16777218, 16777218, 16777218, 2097152, 2097152, 2097152, 2097152, 134217728, 18874368, 150994946,
  18874368, 754974722, 218103810, 218103810, 150994946, 18878464, 555745280, 754974722, 150994946, 754974722, 150994946,
  150994946, 150994946, 128, 754974722, 218103810, 150994946, 555745280, 754974722, 150994946, 150994946, 218103810,
  218103810, -1392508926, 754974722, 754974722, 757071874, -1392508926, 757071874, 754974722, 128, 192, 128, 192, 0, 0,
  0, 24576, 16, 192, 8388736, 16777344, 16777408, 553648256, 16777344, 16777344, -2130706304, 16777344, 16777344,
  -2147475840, -2130698560, -2130698560, -2130698558, -2130698560, -2130698560, 754974850, -1996480830, 4, 8, 16, 32, 0,
  0, 131072, -2130698560, -2130698560, -2130698560, -2130698560, 4194304, 1073741824, 0, 0, 0, 0, -2147483648, 0, 0, 0,
  1, 0, 0, 0, 2, 0, 0, 0, 4, 0, 0, 0, 6, 64, 128, 512, 3584, 0, 0, 0, 64, 6144, 2097152, 0, 16384, 1056768, 0, 0,
  262144, 16777216, 67108864, 134217728, 268435456, 1073741824, 0, 0, 64, 192, 192, 192, 128, 4224, 4224, 192, 192, 192,
  192, 4194304, 0, 0, -2147483648, 524288, 16384, 134217728, 4224, 0, 4288, 4288, 192, 0, 3072, 2048, 0, 0, 0, 256, 0,
  0, 0, 512, 0, 0, 0, 4096, 0, 0, 0, 1048576, 1048576, 0, 512, 0, 4224, 4224, 4224, 4224, 0, 4224, 4224, 4288, 4288,
  4288, 4288, 4, 8, 2048, 268435456, 48, 80, 528, 262160, 131088, 1048592, 16, 16, 16, 16, 2, 0, 536936448, 20, 16,
  -164625872, 16, -164575404, 48, 16, 16, 24, 1572880, 524304, 524304, 1048592, 268435472, 16, 524304, 16, 16, 16, 17,
  16, 16, 17, 560, 48, 1049104, 528, 165675008, 528, 528, 16, 21, 16, 1049136, 1049136, 1049136, 0, 0, 262144,
  268435456, 528, 1048592, 528, 528, -164625872, 48, 16, -164575404, -164625872, 20, -164575404, -164624592, -164624528,
  -164575403, -164624528, -164624528, -164624528, -164624528, -164624464, -164575376, -164575376, -164575372,
  -164313232, -164100176, 21, 21, 53, 117, 140513284, 140521492, 140571932, 140571932, 140571964, 140571932, 140571932,
  140571932, 141620508, 140571964, 140571933, -164575372, -164313228, -164575372, -164575372, -164313228, -164575372, 0,
  0, 524288, 1048576, 0, -164313228, -26200268, 0, 0, 1, 2, 28, 384, 512, 0, 138412032, 0, 0, 1, 262144, 0, 12582912, 0,
  0, 2, 16, 17, 0, 4194304, 8388608, 0, 0, 16777216, 0, 0, 33554432, 33554432, 33554432, 3072, 262144, 524288, 16777216,
  67108864, 0, 2048, 2048, 8192, 32768, 131072, 2048, 8320, 2048, 1090519040, 8192, 0, 1090519040, 32, 32, 0, 0, 197120,
  0, 2048, 1409449984, 1409449984, 536870912, 0, 536870912, 553648128, 536870912, 558370848, 554176544, 554177568,
  557323264, 557323264, 3146768, 557323264, 554177568, 557323264, 3146768, 554177568, 137364496, 554177568, 554177568,
  554177568, 1546814480, 554177568, 556274720, 557323296, 556274721, 557323296, 557323312, 557323312, 557323312,
  557323312, 554185889, 569906944, 557323312, 557323312, 554185889, 557323312, 557323312, 557325360, 603543296,
  603543296, 603543296, 603543296, 603543300, 603543300, 603543300, 603543301, 603543300, 603543300, 603543301,
  603543300, 603543344, 603543332, 0, 0, 2, 512, 1024, 8320, 0, 0, 0, 1048576, 10368, 0, 0, 0, 2097152, 0, 0, 0, 163840,
  335544320, 536870912, 0, 0, 0, 32768, 0, 0, 0, 128, 0, 0, 0, 192, 553648128, 0, 8, -2147483648, 524296, 256,
  134234112, 32, 0, 16, 0, 18, 0, 5120, 0, 5120, 557318144, 0, 0, 0, 3145728, 0, 1024, 3145728, 0, 0, 2, 4096,
  -1073741824, 137363456, 0, 0, 0, 4194304, 0, 556269568, 557318144, 13440, 0, 5888, 569901056, 0, 0, 67108864, 0, 0,
  201326592, 2621440, 65536, 603455488, 0, 0, 0, 6291456, 0, 1024, 1024, 4096, 0, 4718592, 0, 0, 268435456, 536870912,
  3670016, 553648128, 0, 0, 4, 64, 0, 469762048, 2621440, 3670016, 0, 0, 0, 16777218, 0, 16384, 65536, 587202560, 0, 0,
  0, 8388608, 0, 0, 0, 8, 0, 0, 0, 12, 16777216, 536870912, 0, 0, 6, 192, 65536, 3670016, 4194304, 8388608, 16777216, 0,
  4194304, 0, 0, 8, 2048, 0, 768, 4096, 2097152, 67108864, 536870912, 0, 0, 472907776, 1073741824, 0, -2147483648, 0, 0,
  50331648, 1073741824, 16384, 33554432, 0, 0, 0, 134217728, 0, 0, 0, 163577856, 768, 4096, 16384, 2097152, 16777216,
  33554432, 0, 512, 4096, 16777216, 0, 0, 536870912, 0, 0, 0, 131072, 67108864, 268435456, 0, 0, 0, 1073741824, 0, 0, 0,
  131072, 268435456, 1073741824, 0, 0, 268435456, -2147483648, 0, 1, 0, 1, 0, 67108864, 512, 1024, 2048, 16384, 0,
  8389120, 8192, 16384, 16384, 0, 4, 524288, 1048576, 262144, 4194304, 33554432, 0, 1, 64, 0, 0, 0, 8388608, 0, 512,
  262144, 134217728, 0, 0, 8, 1048576, 0, 0, 8, 16, 0, 0, 8, 32, 0, 8388608, 8389120, 0, 2, 0, 2, 16, 2048, 0, 69206016,
  69206016, 69222400, 69208064, 134217760, 69208064, 69208080, 69225490, 69225490, 69225490, 891472978, 354470930,
  891472978, 822247488, 354470930, 354470930, 891472978, 891472978, 822255680, 830636096, 891341906, 891341906,
  891472978, 830636098, 891472978, 891472978, 891472978, 891472978, 891735122, -1254372129, 891472978, 891472978,
  891735122, 891472978, 891472978, 895667282, -172236833, -172236833, -172236833, -172236833, 0, 0, 16, 32, 524288,
  524288, 8192, 2, 8388608, 0, 2, 64, 524288, 4194304, 0, 4194304, 33554432, 0, 2, 4096, 1073741824, -2147483648, 0, 0,
  512, 524292, 18, 19456, 0, 0, 16, 32768, 134217728, 0, 0, 82, 183296, 2097152, 352321536, 536870912, 0, 0, 18, 64,
  285212672, 536870912, 0, 0, 24, 1024, 0, 172032, 0, 0, 24, 8192, 183296, 536870912, 0, 66, 445440, 536870912, 0, 0,
  31, 64, 384, 248832, 3670016, 352321536, -1610612736, 12058624, -536870912, 0, 0, 64, 163840, 352321536, -536870912,
  0, 0, 82, 536870912, 131072, 536870912, 0, 0, 128, 128, 128, 128, 192, 192, 192, 0, 128, 1024, 2048, 16384, 131072,
  384, 1536, 6144, 8388608, 553648128, -2130706432, 16777216, 16777216, 16777216, 16777216, 16784896, 1536, 6144, 16384,
  65536, 7864320, 8388608, 131072, 3670016, 8388608, 67108864, -2147483648, 0, 1024, 2048, 131072, 67108864, 128, 1024,
  2048, 65536, 2097152, 4194304, 8388608, 16777216, 131072, 1572864, 67108864, 536870912, 384, 512, 6144, 8388608,
  553648128, 0, 0, 6, 128, 256, 512, 1024, 6144, 65536, 131072, 1572864, 512, 2048, 0, 0, 230, 0, 0, 0, 8192, 8388608,
  0, 33554432, 0, 0, 0, 131072, 0, 0, 256, 256, 512, 128, 2048, 65536, 131072, 3670016, 67108864, 1572864, 67108864,
  -2147483648, 0, 4, 0, 256, 512, 65536, -2147483648, 128, 131072, 1572864, -2147483648, 4096, 131072, 1572864, 8388608,
  0, 0, 4194304, 512, 4096, 1572864, 8388608, 67108864, 536870912, 8192, 8388608, 33554432, 0, 4, 64, 2048, 0, 0, 0,
  384, 4096, 8388608, 0, 0, 512, 16, 1572864, 0, 0, 256, 197120, 0, 256, 4096, 0, 0, 8, 256, 4096, 1048576, 0, 0, 0,
  554172416, 8, 1048576, 0, 4096, 0, 4096, 16777216, 0, 134217728, 0, 8, 16, 64, 1024, 524292, 1048576, 0, 8, 16,
  8388608, 1, 64, 16384, 32768, 196608, 2097152, 4194304, 2, 2, 69206016, 262144, 1048576, 4194304, 67108864, 512,
  16384, 262144, 0, 262144, 0, 0, 65536, 262144, 0, 67108864, 0, 8, 4096, 1048576, 128, 268435456, 268468224, 67109888,
  -1073737726, 67109888, 67109888, 0, 67109888, 67109888, 75498496, 109052928, 109052928, 109194552, 109186336,
  109194552, 33728824, 109186336, 109194552, 33712440, 109186336, 109194552, 109194552, 33696056, 50473272, 109194528,
  109194528, 109194544, 109194552, 318941496, 109194552, 109194552, 109194552, 109194552, 109194553, 780332344,
  109194552, 109194552, 109194553, 109194552, 109194552, 109194680, 782495096, 782495096, 782495096, 782495096, 0, 0,
  384, 512, 4096, 64, 32768, 4194304, 16777216, 67108864, 268435456, 1073741824, 0, 0, 75497472, 0, 0, 479, 253440,
  12058624, 0, 56, 3328, 8192, 0, 0, 0, 16384, 0, 0, 0, 22272, 65536, 131072, 109051904, 0, 0, 0, 163840, 33554432, 0,
  0, 768, 4096, 16384, 65536, 0, 50331648, 0, 32, 3328, 131072, 0, 12, 16, 256, 4096, 1572864, 0, 57, 0, 0, 1792, 4096,
  7864320, 3456, 0, 0, 0, 2048, 0, 8192, 0, 120, 2326528, 536870912, 0, 120, 3328, 24576, 163840, 243269632, 2326528,
  243269632, 536870912, 0, 12, 16, 1048576, 1024, 8192, 8388608, 67108864, 24576, 32768, 8388608, 201326592, 536870912,
  0, 0, 64, 98304, 2097152, 0, 16, 2, 536936448, 16, 16, 20, 16, 112, 1024, 24576, 98304, 2097152, 0, 64, 32768,
  16777216, 67108864, 268435456, 16384, 98304, 2097152, 8388608, 512, 134217728, 0, 0, 4096, 3670016, 8, 16, 98304,
  134217728, 536870912, 0, 0, 8, 16, 32768, 0, 16, 65536, 0, 0, 524288, 4194304, 0, 0, 0, 223, 16, 98304, 0, 0, 7168, 0,
  256, 1024, 1048576, 8388608, 0, 0, 8192, 134217728, 134234112, 32, 0, 4096, 0, 558366720, 0, 1049600, 16, 0, 16,
  131072, 0, 0, 0, 65536, 0, 0, 0, 131072, 67108864, 0, 0, 0, 262144, 0, 268697600, 0, 0, 65792, 65792, 65792, 65792, 1,
  65792, 65792, 197376, 197376, 197376, 1191379712, 1191379712, 1124073472, 16974592, 1191379712, 1125123072, 16974592,
  1124073504, 16974592, 1090716416, 1090716416, 1124073504, 1124270848, 1124270848, 1124270848, 1124270848, 1090716416,
  -956062842, 1124270848, 1124270848, 1090716416, 1124270848, 1124270848, 1124270848, 1191379712, 197376, 1191379712,
  1124073472, 1258504960, 1191379712, 1392968448, -412894266, -412894266, -412894266, -412894266, -412894234,
  -412894266, -412894234, -412894234, -412894234, -412894234, -412894266, -412894266, 0, 0, 10368, 8192, 134, 256,
  238080, 117440512, 1073741824, 0, 0, 16384, 65536, 33554432, 213504, 184549376, 0, 0, 32768, 131072, 16777216,
  67108864, 134217728, 0, 459264, 318767104, 0, 0, 0, 1024, 4, 524288, 1048576, 0, 0, 134217728, 2341376, 658505728, 0,
  0, 32768, 16777216, 268435456, 2341376, 658505728, -1073741824, 0, 24, 0, 0, 1, 16, 64, 0, 0, 0, 0, 134, 256, 512,
  6144, 8192, 8192, 32768, 196608, 100663296, -1073741824, 0, 0, 0, 393216, 458752, 0, 0, 0, 32768, 268435456, 6144,
  2097152, 4194304, 536870912, 100663296, 536870912, -1073741824, 0, 28, 128, 1572864, 0, 32, 4096, 0, 16, 0, 16, 0,
  196608, 0, 0, 0, 0, 256, 512, 196608, 100663296, 8192, 32768, 196608, 33554432, 16777218, 16777472, 16777472,
  16777728, 16781312, 276824064, 512, 65536, 131072, 33554432, 1073741824, 0, 0, 131072, 2097152, 33554432, 536870912,
  1073741824, -2147483648, 256, 512, 65536, 0, 28, 384, 4096, 4096, 4096, 4096, 0, 0, 0, 32, 0, 0, 0, 56, 128, 512,
  -2147483648, 0, 48, 0, 0, 1024, 0, 0, 1048576, 512, 0, 0, 134217728, 4096, 0, 16, 0, 262144, 0, 64, 6144, 536870912,
  0, 0, 98304, 0, 0, 0, 512, 6144, 536870912, -2147483648, 0, 0, 32, 0, 1048576, 512, -2147483648, 6, 512, -2147483648,
  0, 56, 2304, 8192, 0, 239075328, 0, 0, 2097152, 2097152, 2097152, 0, 0, 0, 198, 256, 512, 2048, 4096, 536870912, 0, 4,
  64, 2048, 4096, 0, 0, 0, 64, 0, 64, 2048, 4096, 536870912, 64, 64, 64, 64, 128, 256, 512, 6144, 65536, 2097152,
  536870912, 0, 0, 52224, 352321536, 8, 32, 256, 4096, 16384, 16777216, 0, 0, 553648128, 8, 2, 0, 4096, 2097152,
  16777216, 0, 0, 0, 16, 0, 0, 0, 24, 64, 1280, 0, 256, 256, 256, 256, 4096, 4096, 256, 0, 8, 0, 8, 0, 256, 256, 0, 0,
  16, 16, 256, 2, 0, 8, 16, 16384, 32768, 201326592, 8960, 8960, 264, 2, 512, 0, 0, 256, 1024, 1048576, 0, 8960, 16, 16,
  16, 128, 272, 16, 4112, 272, 3072, 192, 0, 32, 134217728, 0, 0, 4112, 4112, 4112, 16, 16384, 98304, 201326592, 6160,
  272, 3072, 6160, 16, 272, 3076, 3074, 6160, 7184, 7184, 7184, 7184, 7440, 7440, 81, 7184, 3074, 7184, 7184, 81, 7184,
  7184, 7440, 337, 81, 337, 81, 81, 81, 81, 337, 4177, 81, 81, 337, 7505, 7249, 0, 0, 262144, 8192, 8388608, 8, 32, 0,
  0, 262144, 524288, 524288, 1073741824
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "EPSILON",
  "EOF",
  "PragmaContents",
  "DirCommentContents",
  "DirPIContents",
  "CDataSectionContents",
  "Wildcard",
  "EQName",
  "URILiteral",
  "IntegerLiteral",
  "DecimalLiteral",
  "DoubleLiteral",
  "StringLiteral",
  "PredefinedEntityRef",
  "'""""'",
  "EscapeApos",
  "ElementContentChar",
  "QuotAttrContentChar",
  "AposAttrContentChar",
  "PITarget",
  "CharRef",
  "NCName",
  "QName",
  "S",
  "S",
  "CommentContents",
  "'!'",
  "'!='",
  "'""'",
  "'#'",
  "'#)'",
  "'$'",
  "'%'",
  "''''",
  "'('",
  "'(#'",
  "'(:'",
  "')'",
  "'*'",
  "'*'",
  "'+'",
  "','",
  "'-'",
  "'-->'",
  "'.'",
  "'..'",
  "'/'",
  "'//'",
  "'/>'",
  "':)'",
  "'::'",
  "':='",
  "';'",
  "'<'",
  "'<!--'",
  "'<![CDATA['",
  "'</'",
  "'<<'",
  "'<='",
  "'<?'",
  "'='",
  "'>'",
  "'>='",
  "'>>'",
  "'?'",
  "'?>'",
  "'@'",
  "'NaN'",
  "'['",
  "']'",
  "']]>'",
  "'allowing'",
  "'ancestor'",
  "'ancestor-or-self'",
  "'and'",
  "'as'",
  "'ascending'",
  "'at'",
  "'attribute'",
  "'base-uri'",
  "'binary'",
  "'boundary-space'",
  "'by'",
  "'case'",
  "'cast'",
  "'castable'",
  "'catch'",
  "'child'",
  "'collation'",
  "'comment'",
  "'construction'",
  "'context'",
  "'copy-namespaces'",
  "'count'",
  "'decimal-format'",
  "'decimal-separator'",
  "'declare'",
  "'default'",
  "'descendant'",
  "'descendant-or-self'",
  "'descending'",
  "'digit'",
  "'div'",
  "'document'",
  "'document-node'",
  "'element'",
  "'else'",
  "'empty'",
  "'empty-sequence'",
  "'encoding'",
  "'end'",
  "'eq'",
  "'every'",
  "'except'",
  "'external'",
  "'following'",
  "'following-sibling'",
  "'for'",
  "'full'",
  "'function'",
  "'ge'",
  "'greatest'",
  "'group'",
  "'grouping-separator'",
  "'gt'",
  "'idiv'",
  "'if'",
  "'import'",
  "'in'",
  "'infinity'",
  "'inherit'",
  "'instance'",
  "'intersect'",
  "'is'",
  "'item'",
  "'lax'",
  "'le'",
  "'least'",
  "'let'",
  "'lt'",
  "'minus-sign'",
  "'mod'",
  "'module'",
  "'namespace'",
  "'namespace-node'",
  "'ne'",
  "'next'",
  "'no-inherit'",
  "'no-preserve'",
  "'node'",
  "'of'",
  "'only'",
  "'option'",
  "'or'",
  "'order'",
  "'ordered'",
  "'ordering'",
  "'parent'",
  "'pattern-separator'",
  "'per-mille'",
  "'percent'",
  "'preceding'",
  "'preceding-sibling'",
  "'preserve'",
  "'previous'",
  "'private'",
  "'processing-instruction'",
  "'property'",
  "'return'",
  "'satisfies'",
  "'schema'",
  "'schema-attribute'",
  "'schema-element'",
  "'self'",
  "'sliding'",
  "'some'",
  "'stable'",
  "'start'",
  "'strict'",
  "'strip'",
  "'stylesheet'",
  "'switch'",
  "'text'",
  "'then'",
  "'to'",
  "'treat'",
  "'try'",
  "'tumbling'",
  "'type'",
  "'typeswitch'",
  "'union'",
  "'unordered'",
  "'validate'",
  "'variable'",
  "'version'",
  "'when'",
  "'where'",
  "'window'",
  "'xquery'",
  "'zero-digit'",
  "'{'",
  "'{{'",
  "'|'",
  "'||'",
  "'}'",
  "'}}'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 2048,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer) as xs:integer+
{
  if ($current-state = 0) then
    let $result := $result idiv 2048
    return
      if ($result != 0) then
      (
        $result mod 256 - 1,
        $begin,
        $end - $result idiv 256
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 16
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 16 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 6)
    let $current := $current + 1
    let $i0 := 2048 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 2047) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 2048, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer) as xs:string*
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 6
    let $i0 := $t * 1792 + $state - 1
    let $i1 := $i0 idiv 4
    let $i2 := $i1 idiv 4
    return p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[6 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[12 + $m]
};

(:~
 : The index of the parser state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk := 1;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the token that has been shifted.
 :)
declare variable $p:b0 := 2;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the token that has been shifted.
 :)
declare variable $p:e0 := 3;

(:~
 : The index of the parser state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 := 4;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 := 5;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 := 6;

(:~
 : The index of the parser state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 := 7;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 := 8;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 := 9;

(:~
 : The index of the parser state for accessing the code of the
 : level-3-lookahead token.
 :)
declare variable $p:l3 := 10;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-3-lookahead token.
 :)
declare variable $p:b3 := 11;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-3-lookahead token.
 :)
declare variable $p:e3 := 12;

(:~
 : The index of the parser state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error := 13;

(:~
 : The index of the parser state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result := 14;

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    if ($error/@o) then
      concat
      (
        "syntax error, found ", $p:TOKEN[$error/@o + 1], "&#10;",
        "while expecting ", $p:TOKEN[$error/@x + 1], "&#10;",
        "after scanning ", string($error/@e - $begin), " characters at line ",
        string($line), ", column ", string($column), "&#10;",
        "...", substring($input, $begin, 32), "..."
      )
    else
      let $expected := p:expected-token-set($error/@s)
      return
        concat
        (
          "lexical analysis failed&#10;",
          "while expecting ",
          "["[exists($expected[2])],
          string-join($expected, ", "),
          "]"[exists($expected[2])],
          "&#10;",
          "after scanning ", string($error/@e - $begin), " characters at line ",
          string($line), ", column ", string($column), "&#10;",
          "...", substring($input, $begin, 32), "..."
        )
};

(:~
 : Shift one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:shift($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    $state[position() >= $p:l1 and position() <= $p:e3],
    0,
    $state[$p:e3],
    $state[position() >= $p:e3],
    if ($state[$p:e0] != $state[$p:b1]) then
      text {substring($input, $state[$p:e0], $state[$p:b1] - $state[$p:e0])}
    else
      (),
    let $name := $p:TOKEN[1 + $state[$p:l1]]
    let $content := substring($input, $state[$p:b1], $state[$p:e1] - $state[$p:b1])
    return
      if (starts-with($name, "'")) then
		    element TOKEN {$content}
	    else
	      element {$name} {$content}
  )
  else
  (
    $state[position() < $p:error],
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] < 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    $state[position() > $p:error]
  )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer) as xs:integer+
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 24) then                                (: S^WS :)
      p:matchW($input, $match[3], $token-set)
    else if ($match[1] = 36) then                           (: ('(' ':') :)
      let $state := p:parse-Whitespace($input, (0, 0, 0, $match, 0, $match[3], 0, 0, 0, 0, false()))
      return p:matchW($input, $state[$p:e0], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:matchW($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      $state[position() > $p:lk and position() < $p:l1],
      $match,
      0, $match[3], 0,
      $state[position() > $p:e2]
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] != 0) then
      $state[position() >= $p:l2 and position() <= $p:e2]
    else
      p:matchW($input, $state[$p:b2], $set)
  return
  (
    $match[1] * 256 + $state[$p:l1],
    $state[position() > $p:lk and position() < $p:l2],
    $match,
    0, $match[3], 0,
    $state[position() > $p:e3]
  )
};

(:~
 : Lookahead one token on level 3 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead3W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] != 0) then
      $state[position() >= $p:l3 and position() <= $p:e3]
    else
      p:matchW($input, $state[$p:b3], $set)
  return
  (
    $match[1] * 65536 + $state[$p:lk],
    $state[position() > $p:lk and position() < $p:l3],
    $match,
    $state[position() > $p:e3]
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:match($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      $state[position() > $p:lk and position() < $p:l1],
      $match,
      0, $match[3], 0,
      $state[position() > $p:e2]
    )
};

(:~
 : Reduce the result stack. Pop $count element, wrap them in a
 : new element named $name, and push the new element.
 :
 : @param $state the parser state.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @return the updated parser state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer) as item()+
{
  $state[position() <= $count],
  element {$name}
  {
    $state[position() > $count]
  }
};

(:~
 : Parse the 1st loop of production Comment (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Comment-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(81, $input, $state)          (: CommentContents | ('(' ':') | (':' ')') :)
    return
      if ($state[$p:l1] = 49) then                          (: (':' ')') :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 25) then                      (: CommentContents :)
            let $state := p:shift(25, $input, $state)       (: CommentContents :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-Comment($input, $state)
            return $state
        return p:parse-Comment-1($input, $state)
};

(:~
 : Parse Comment.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Comment($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(36, $input, $state)                 (: ('(' ':') :)
  let $state := p:parse-Comment-1($input, $state)
  let $state := p:shift(49, $input, $state)                 (: (':' ')') :)
  return p:reduce($state, "Comment", $count)
};

(:~
 : Parse Whitespace.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Whitespace($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(25, $input, $state)            (: S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:l1] = 24) then                            (: S^WS :)
      let $state := p:shift(24, $input, $state)             (: S^WS :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-Comment($input, $state)
      return $state
  return p:reduce($state, "Whitespace", $count)
};

(:~
 : Parse QueryBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QueryBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "QueryBody", $count)
};

(:~
 : Parse MainModule.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MainModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Prolog($input, $state)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-QueryBody($input, $state)
  return p:reduce($state, "MainModule", $count)
};

(:~
 : Parse the 1st loop of production MainModuleSequence (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MainModuleSequence-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(82, $input, $state)         (: EOF | S^WS | ('(' ':') | ';' :)
    let $state :=
      if ($state[$p:l1] = 52) then                          (: ';' :)
        let $state := p:lookahead2W(229, $input, $state)    (: EOF | Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | ';' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
        return $state
      else
        ($state[$p:l1], $state[position() > $p:lk])
    return
      if ($state[$p:lk] = 1                                 (: EOF :)
       or $state[$p:lk] = 308                               (: ';' EOF :)
       or $state[$p:lk] = 13364) then                       (: ';' ';' :)
        $state
      else
        let $state := p:shift(52, $input, $state)           (: ';' :)
        let $state := p:lookahead1W(223, $input, $state)    (: Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
        let $state :=
          if ($state[$p:l1] = 198) then                     (: 'xquery' :)
            let $state := p:lookahead2W(176, $input, $state) (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                                '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                                '=' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                                'castable' | 'div' | 'encoding' | 'eq' | 'except' |
                                                                'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                                'le' | 'lt' | 'mod' | 'ne' | 'or' | 'to' | 'treat' |
                                                                'union' | 'version' | '|' | '||' :)
            return $state
          else
            ($state[$p:l1], $state[position() > $p:lk])
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 28102                    (: 'xquery' 'encoding' :)
                or $state[$p:lk] = 49862) then              (: 'xquery' 'version' :)
            let $state := p:parse-VersionDecl($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(31, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-MainModule($input, $state)
        return p:parse-MainModuleSequence-1($input, $state)
};

(:~
 : Parse MainModuleSequence.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MainModuleSequence($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-MainModule($input, $state)
  let $state := p:parse-MainModuleSequence-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 52) then                       (: ';' :)
      let $state := p:shift(52, $input, $state)             (: ';' :)
      return $state
    else
      $state
  return p:reduce($state, "MainModuleSequence", $count)
};

(:~
 : Parse OptionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OptionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(70, $input, $state)           (: S^WS | ('(' ':') | 'option' :)
  let $state := p:shift(152, $input, $state)                (: 'option' :)
  let $state := p:lookahead1W(211, $input, $state)          (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(35, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:shift(12, $input, $state)                 (: StringLiteral :)
  return p:reduce($state, "OptionDecl", $count)
};

(:~
 : Parse FunctionBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-EnclosedExpr($input, $state)
  return p:reduce($state, "FunctionBody", $count)
};

(:~
 : Parse FunctionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(119, $input, $state)                (: 'function' :)
  let $state := p:lookahead1W(211, $input, $state)          (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(89, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(135, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'external' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'as' :)
      let $state := p:shift(75, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(31, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(113, $input, $state)          (: S^WS | ('(' ':') | 'external' | '{' :)
  let $state :=
    if ($state[$p:l1] = 200) then                           (: '{' :)
      let $state := p:parse-FunctionBody($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(114, $input, $state)            (: 'external' :)
      return $state
  return p:reduce($state, "FunctionDecl", $count)
};

(:~
 : Parse VarDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(193, $input, $state)                (: 'variable' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(211, $input, $state)          (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(133, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(99, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:l1] = 51) then                            (: ':=' :)
      let $state := p:shift(51, $input, $state)             (: ':=' :)
      let $state := p:lookahead1W(31, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-VarValue($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(114, $input, $state)            (: 'external' :)
      let $state := p:lookahead1W(97, $input, $state)       (: S^WS | ('(' ':') | ':=' | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 51) then                   (: ':=' :)
          let $state := p:shift(51, $input, $state)         (: ':=' :)
          let $state := p:lookahead1W(31, $input, $state)   (: EPSILON | S^WS | ('(' ':') :)
          let $state := p:parse-VarDefaultValue($input, $state)
          return $state
        else
          $state
      return $state
  return p:reduce($state, "VarDecl", $count)
};

(:~
 : Parse the 1st loop of production AnnotatedDecl (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnnotatedDecl-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(142, $input, $state)        (: S^WS | '%' | ('(' ':') | 'function' | 'private' |
                                                               'variable' :)
    return
      if ($state[$p:l1] != 32                               (: '%' :)
      and $state[$p:l1] != 165) then                        (: 'private' :)
        $state
      else
        let $state := p:parse-Annotation($input, $state)
        return p:parse-AnnotatedDecl-1($input, $state)
};

(:~
 : Parse AnnotatedDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnnotatedDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:parse-AnnotatedDecl-1($input, $state)
  let $state :=
    if ($state[$p:l1] = 193) then                           (: 'variable' :)
      let $state := p:parse-VarDecl($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionDecl($input, $state)
      return $state
  return p:reduce($state, "AnnotatedDecl", $count)
};

(:~
 : Parse VarDefaultValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarDefaultValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "VarDefaultValue", $count)
};

(:~
 : Parse the 1st loop of production CatchErrorList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CatchErrorList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(125, $input, $state)        (: S^WS | ('(' ':') | '{' | '|' :)
    return
      if ($state[$p:l1] != 202) then                        (: '|' :)
        $state
      else
        let $state := p:shift(202, $input, $state)          (: '|' :)
        let $state := p:lookahead1W(212, $input, $state)    (: Wildcard | EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
        let $state := p:parse-NameTest($input, $state)
        return p:parse-CatchErrorList-1($input, $state)
};

(:~
 : Parse CatchErrorList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CatchErrorList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-NameTest($input, $state)
  let $state := p:parse-CatchErrorList-1($input, $state)
  return p:reduce($state, "CatchErrorList", $count)
};

(:~
 : Parse CatchClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CatchClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(16, $input, $state)            (: 'catch' :)
  let $state := p:shift(86, $input, $state)                 (: 'catch' :)
  let $state := p:lookahead1W(214, $input, $state)          (: Wildcard | EQName^Token | S^WS | '(' | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 34) then                            (: '(' :)
      let $state := p:shift(34, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(39, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(211, $input, $state)      (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(41, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(37, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CatchErrorList($input, $state)
      return $state
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-EnclosedExprExtended($input, $state)
  return p:reduce($state, "CatchClause", $count)
};

(:~
 : Parse TryTargetExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryTargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "TryTargetExpr", $count)
};

(:~
 : Parse TryClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(19, $input, $state)            (: 'try' :)
  let $state := p:shift(186, $input, $state)                (: 'try' :)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(200, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-TryTargetExpr($input, $state)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(204, $input, $state)                (: '}' :)
  return p:reduce($state, "TryClause", $count)
};

(:~
 : Parse the 1st loop of production TryCatchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryCatchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(31, $input, $state)         (: EPSILON | S^WS | ('(' ':') :)
    let $state := p:parse-CatchClause($input, $state)
    let $state := p:lookahead1W(165, $input, $state)        (: EOF | S^WS | ('(' ':') | ')' | ',' | ';' | ']' |
                                                               'ascending' | 'case' | 'catch' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'else' | 'empty' | 'end' |
                                                               'for' | 'group' | 'let' | 'only' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | '}' :)
    return
      if ($state[$p:l1] != 86) then                         (: 'catch' :)
        $state
      else
        p:parse-TryCatchExpr-1($input, $state)
};

(:~
 : Parse TryCatchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryCatchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-TryClause($input, $state)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-TryCatchExpr-1($input, $state)
  return p:reduce($state, "TryCatchExpr", $count)
};

(:~
 : Parse NodeComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 133) then                           (: 'is' :)
      let $state := p:shift(133, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 57) then                       (: '<<' :)
      let $state := p:shift(57, $input, $state)             (: '<<' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(63, $input, $state)             (: '>>' :)
      return $state
  return p:reduce($state, "NodeComp", $count)
};

(:~
 : Parse GeneralComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 60) then                            (: '=' :)
      let $state := p:shift(60, $input, $state)             (: '=' :)
      return $state
    else if ($state[$p:l1] = 27) then                       (: '!=' :)
      let $state := p:shift(27, $input, $state)             (: '!=' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '<' :)
      let $state := p:shift(53, $input, $state)             (: '<' :)
      return $state
    else if ($state[$p:l1] = 58) then                       (: '<=' :)
      let $state := p:shift(58, $input, $state)             (: '<=' :)
      return $state
    else if ($state[$p:l1] = 61) then                       (: '>' :)
      let $state := p:shift(61, $input, $state)             (: '>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(62, $input, $state)             (: '>=' :)
      return $state
  return p:reduce($state, "GeneralComp", $count)
};

(:~
 : Parse ValueComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 111) then                           (: 'eq' :)
      let $state := p:shift(111, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'ne' :)
      let $state := p:shift(145, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'lt' :)
      let $state := p:shift(139, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'le' :)
      let $state := p:shift(136, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'gt' :)
      let $state := p:shift(124, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(120, $input, $state)            (: 'ge' :)
      return $state
  return p:reduce($state, "ValueComp", $count)
};

(:~
 : Parse SingleType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(208, $input, $state)           (: EQName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-AtomicOrUnionType($input, $state)
  let $state := p:lookahead1W(190, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '*' | '+' |
                                                               ',' | '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '?' | ']' | 'and' | 'ascending' | 'case' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 39                             (: '*' :)
          or $state[$p:l1] = 64) then                       (: '?' :)
      let $state :=
        if ($state[$p:l1] = 64) then                        (: '?' :)
          let $state := p:shift(64, $input, $state)         (: '?' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(39, $input, $state)         (: '*' :)
          return $state
      return $state
    else
      $state
  return p:reduce($state, "SingleType", $count)
};

(:~
 : Parse Pragma.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Pragma($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(9, $input, $state)             (: '(#' :)
  let $state := p:shift(35, $input, $state)                 (: '(#' :)
  let $state := p:lookahead1(210, $input, $state)           (: EQName^Token | S | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'ascending' | 'attribute' | 'binary' | 'case' |
                                                               'cast' | 'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 23) then                       (: S :)
      let $state := p:shift(23, $input, $state)             (: S :)
      return $state
    else
      $state
  let $state := p:lookahead1(208, $input, $state)           (: EQName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1(21, $input, $state)            (: S | '#)' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 23) then                       (: S :)
      let $state := p:shift(23, $input, $state)             (: S :)
      let $state := p:lookahead1(0, $input, $state)         (: PragmaContents :)
      let $state := p:shift(2, $input, $state)              (: PragmaContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(6, $input, $state)             (: '#)' :)
  let $state := p:shift(30, $input, $state)                 (: '#)' :)
  return p:reduce($state, "Pragma", $count)
};

(:~
 : Parse the 1st loop of production ExtensionExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(92, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 35) then                         (: '(#' :)
        $state
      else
        p:parse-ExtensionExpr-1($input, $state)
};

(:~
 : Parse ExtensionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExtensionExpr-1($input, $state)
  let $state := p:shift(200, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(228, $input, $state)          (: Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 204) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(204, $input, $state)                (: '}' :)
  return p:reduce($state, "ExtensionExpr", $count)
};

(:~
 : Parse the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(192, $input, $state)        (: EOF | S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' | '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 68) then                         (: '[' :)
        $state
      else
        let $state := p:parse-Predicate($input, $state)
        return p:parse-PredicateList-1($input, $state)
};

(:~
 : Parse PredicateList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PredicateList-1($input, $state)
  return p:reduce($state, "PredicateList", $count)
};

(:~
 : Parse AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 66) then                       (: '@' :)
      let $state := p:shift(66, $input, $state)             (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-NodeTest($input, $state)
  return p:reduce($state, "AbbrevForwardStep", $count)
};

(:~
 : Parse ForwardAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 87) then                            (: 'child' :)
      let $state := p:shift(87, $input, $state)             (: 'child' :)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'descendant' :)
      let $state := p:shift(98, $input, $state)             (: 'descendant' :)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'attribute' :)
      let $state := p:shift(78, $input, $state)             (: 'attribute' :)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'namespace' :)
      let $state := p:shift(143, $input, $state)            (: 'namespace' :)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'self' :)
      let $state := p:shift(173, $input, $state)            (: 'self' :)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'property' :)
      let $state := p:shift(167, $input, $state)            (: 'property' :)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'descendant-or-self' :)
      let $state := p:shift(99, $input, $state)             (: 'descendant-or-self' :)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'following-sibling' :)
      let $state := p:shift(116, $input, $state)            (: 'following-sibling' :)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(115, $input, $state)            (: 'following' :)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
  return p:reduce($state, "ForwardAxis", $count)
};

(:~
 : Parse ForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 78) then                            (: 'attribute' :)
      let $state := p:lookahead2W(199, $input, $state)      (: EOF | S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 87                             (: 'descendant' :)
          or $state[$p:l1] = 98                             (: 'descendant-or-self' :)
          or $state[$p:l1] = 99                             (: 'following' :)
          or $state[$p:l1] = 115                            (: 'following-sibling' :)
          or $state[$p:l1] = 116                            (: 'namespace' :)
          or $state[$p:l1] = 143                            (: 'property' :)
          or $state[$p:l1] = 167                            (: 'self' :)
          or $state[$p:l1] = 173) then                      (: 'self' :)
      let $state := p:lookahead2W(195, $input, $state)      (: EOF | S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 12878                               (: 'attribute' '::' :)
     or $state[$p:lk] = 12887                               (: 'child' '::' :)
     or $state[$p:lk] = 12898                               (: 'descendant' '::' :)
     or $state[$p:lk] = 12899                               (: 'descendant-or-self' '::' :)
     or $state[$p:lk] = 12915                               (: 'following' '::' :)
     or $state[$p:lk] = 12916                               (: 'following-sibling' '::' :)
     or $state[$p:lk] = 12943                               (: 'namespace' '::' :)
     or $state[$p:lk] = 12967                               (: 'property' '::' :)
     or $state[$p:lk] = 12973) then                         (: 'self' '::' :)
      let $state := p:parse-ForwardAxis($input, $state)
      let $state := p:lookahead1W(31, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-NodeTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AbbrevForwardStep($input, $state)
      return $state
  return p:reduce($state, "ForwardStep", $count)
};

(:~
 : Parse AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(45, $input, $state)                 (: '..' :)
  return p:reduce($state, "AbbrevReverseStep", $count)
};

(:~
 : Parse NameTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(209, $input, $state)           (: Wildcard | EQName^Token | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 6) then                             (: Wildcard :)
      let $state := p:shift(6, $input, $state)              (: Wildcard :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EQName($input, $state)
      return $state
  return p:reduce($state, "NameTest", $count)
};

(:~
 : Parse NodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(209, $input, $state)           (: Wildcard | EQName^Token | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 78                                  (: 'binary' :)
     or $state[$p:l1] = 80                                  (: 'comment' :)
     or $state[$p:l1] = 89                                  (: 'document-node' :)
     or $state[$p:l1] = 104                                 (: 'element' :)
     or $state[$p:l1] = 105                                 (: 'namespace-node' :)
     or $state[$p:l1] = 144                                 (: 'node' :)
     or $state[$p:l1] = 149                                 (: 'processing-instruction' :)
     or $state[$p:l1] = 166                                 (: 'schema-attribute' :)
     or $state[$p:l1] = 171                                 (: 'schema-element' :)
     or $state[$p:l1] = 172                                 (: 'text' :)
     or $state[$p:l1] = 182) then                           (: 'text' :)
      let $state := p:lookahead2W(194, $input, $state)      (: EOF | S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 8782                                (: 'attribute' '(' :)
     or $state[$p:lk] = 8784                                (: 'binary' '(' :)
     or $state[$p:lk] = 8793                                (: 'comment' '(' :)
     or $state[$p:lk] = 8808                                (: 'document-node' '(' :)
     or $state[$p:lk] = 8809                                (: 'element' '(' :)
     or $state[$p:lk] = 8848                                (: 'namespace-node' '(' :)
     or $state[$p:lk] = 8853                                (: 'node' '(' :)
     or $state[$p:lk] = 8870                                (: 'processing-instruction' '(' :)
     or $state[$p:lk] = 8875                                (: 'schema-attribute' '(' :)
     or $state[$p:lk] = 8876                                (: 'schema-element' '(' :)
     or $state[$p:lk] = 8886) then                          (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NameTest($input, $state)
      return $state
  return p:reduce($state, "NodeTest", $count)
};

(:~
 : Parse ReverseAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 157) then                           (: 'parent' :)
      let $state := p:shift(157, $input, $state)            (: 'parent' :)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'ancestor' :)
      let $state := p:shift(72, $input, $state)             (: 'ancestor' :)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'preceding-sibling' :)
      let $state := p:shift(162, $input, $state)            (: 'preceding-sibling' :)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 161) then                      (: 'preceding' :)
      let $state := p:shift(161, $input, $state)            (: 'preceding' :)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(73, $input, $state)             (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(44, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
  return p:reduce($state, "ReverseAxis", $count)
};

(:~
 : Parse ReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 45) then                            (: '..' :)
      let $state := p:parse-AbbrevReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ReverseAxis($input, $state)
      let $state := p:lookahead1W(31, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-NodeTest($input, $state)
      return $state
  return p:reduce($state, "ReverseStep", $count)
};

(:~
 : Parse AxisStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 72                                  (: 'ancestor-or-self' :)
     or $state[$p:l1] = 73                                  (: 'parent' :)
     or $state[$p:l1] = 157                                 (: 'preceding' :)
     or $state[$p:l1] = 161                                 (: 'preceding-sibling' :)
     or $state[$p:l1] = 162) then                           (: 'preceding-sibling' :)
      let $state := p:lookahead2W(195, $input, $state)      (: EOF | S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 45                                  (: '..' :)
     or $state[$p:lk] = 12872                               (: 'ancestor' '::' :)
     or $state[$p:lk] = 12873                               (: 'ancestor-or-self' '::' :)
     or $state[$p:lk] = 12957                               (: 'parent' '::' :)
     or $state[$p:lk] = 12961                               (: 'preceding' '::' :)
     or $state[$p:lk] = 12962) then                         (: 'preceding-sibling' '::' :)
      let $state := p:parse-ReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-PredicateList($input, $state)
  return p:reduce($state, "AxisStep", $count)
};

(:~
 : Parse Predicate.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(68, $input, $state)                 (: '[' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(48, $input, $state)           (: S^WS | ('(' ':') | ']' :)
  let $state := p:shift(69, $input, $state)                 (: ']' :)
  return p:reduce($state, "Predicate", $count)
};

(:~
 : Parse Param.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Param($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(7, $input, $state)             (: '$' :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(211, $input, $state)          (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(131, $input, $state)          (: S^WS | ('(' ':') | ')' | ',' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "Param", $count)
};

(:~
 : Parse the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(93, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(31, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-Param($input, $state)
        return p:parse-ParamList-1($input, $state)
};

(:~
 : Parse ParamList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Param($input, $state)
  let $state := p:parse-ParamList-1($input, $state)
  return p:reduce($state, "ParamList", $count)
};

(:~
 : Parse InlineFunction.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InlineFunction($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(119, $input, $state)                (: 'function' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(89, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(103, $input, $state)          (: S^WS | ('(' ':') | 'as' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'as' :)
      let $state := p:shift(75, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(31, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-EnclosedExpr($input, $state)
  return p:reduce($state, "InlineFunction", $count)
};

(:~
 : Parse LiteralFunctionItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LiteralFunctionItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(38, $input, $state)           (: S^WS | '#' | ('(' ':') :)
  let $state := p:shift(29, $input, $state)                 (: '#' :)
  let $state := p:lookahead1W(34, $input, $state)           (: IntegerLiteral | S^WS | ('(' ':') :)
  let $state := p:shift(9, $input, $state)                  (: IntegerLiteral :)
  return p:reduce($state, "LiteralFunctionItem", $count)
};

(:~
 : Parse FunctionItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 119) then                           (: 'function' :)
      let $state := p:lookahead2W(87, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 8823) then                          (: 'function' '(' :)
      let $state := p:parse-InlineFunction($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-LiteralFunctionItem($input, $state)
      return $state
  return p:reduce($state, "FunctionItemExpr", $count)
};

(:~
 : Parse PrefixExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PrefixExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "PrefixExpr", $count)
};

(:~
 : Parse Prefix.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prefix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-NCName($input, $state)
  return p:reduce($state, "Prefix", $count)
};

(:~
 : Parse CompNamespaceConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompNamespaceConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(143, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(171, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | '{' :)
  let $state :=
    if ($state[$p:l1] = 200) then                           (: '{' :)
      let $state := p:shift(200, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(31, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-PrefixExpr($input, $state)
      let $state := p:lookahead1W(80, $input, $state)       (: S^WS | ('(' ':') | '}' :)
      let $state := p:shift(204, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-Prefix($input, $state)
      return $state
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-EnclosedExprExtended($input, $state)
  return p:reduce($state, "CompNamespaceConstructor", $count)
};

(:~
 : Parse CompBinaryConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompBinaryConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(80, $input, $state)                 (: 'binary' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-EnclosedExprExtended($input, $state)
  return p:reduce($state, "CompBinaryConstructor", $count)
};

(:~
 : Parse CompPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(166, $input, $state)                (: 'processing-instruction' :)
  let $state := p:lookahead1W(171, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | '{' :)
  let $state :=
    if ($state[$p:l1] = 200) then                           (: '{' :)
      let $state := p:shift(200, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(31, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(80, $input, $state)       (: S^WS | ('(' ':') | '}' :)
      let $state := p:shift(204, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NCName($input, $state)
      return $state
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(200, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(228, $input, $state)          (: Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 204) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(204, $input, $state)                (: '}' :)
  return p:reduce($state, "CompPIConstructor", $count)
};

(:~
 : Parse CompCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(89, $input, $state)                 (: 'comment' :)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(200, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(204, $input, $state)                (: '}' :)
  return p:reduce($state, "CompCommentConstructor", $count)
};

(:~
 : Parse EnclosedExprExtended.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EnclosedExprExtended($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(20, $input, $state)            (: '{' :)
  let $state := p:shift(200, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(228, $input, $state)          (: Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 204) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(204, $input, $state)                (: '}' :)
  return p:reduce($state, "EnclosedExprExtended", $count)
};

(:~
 : Parse CompTextConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompTextConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(182, $input, $state)                (: 'text' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-EnclosedExprExtended($input, $state)
  return p:reduce($state, "CompTextConstructor", $count)
};

(:~
 : Parse CompAttrConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompAttrConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(78, $input, $state)                 (: 'attribute' :)
  let $state := p:lookahead1W(213, $input, $state)          (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
  let $state :=
    if ($state[$p:l1] = 200) then                           (: '{' :)
      let $state := p:shift(200, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(31, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(80, $input, $state)       (: S^WS | ('(' ':') | '}' :)
      let $state := p:shift(204, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(200, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(228, $input, $state)          (: Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 204) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(204, $input, $state)                (: '}' :)
  return p:reduce($state, "CompAttrConstructor", $count)
};

(:~
 : Parse ContentExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContentExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "ContentExpr", $count)
};

(:~
 : Parse CompElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(105, $input, $state)                (: 'element' :)
  let $state := p:lookahead1W(213, $input, $state)          (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
  let $state :=
    if ($state[$p:l1] = 200) then                           (: '{' :)
      let $state := p:shift(200, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(31, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(80, $input, $state)       (: S^WS | ('(' ':') | '}' :)
      let $state := p:shift(204, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(200, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(228, $input, $state)          (: Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 204) then                     (: '}' :)
      let $state := p:parse-ContentExpr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(204, $input, $state)                (: '}' :)
  return p:reduce($state, "CompElemConstructor", $count)
};

(:~
 : Parse CompDocConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompDocConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(103, $input, $state)                (: 'document' :)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(200, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(204, $input, $state)                (: '}' :)
  return p:reduce($state, "CompDocConstructor", $count)
};

(:~
 : Parse ComputedConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComputedConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 103) then                           (: 'document' :)
      let $state := p:parse-CompDocConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'element' :)
      let $state := p:parse-CompElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'attribute' :)
      let $state := p:parse-CompAttrConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 182) then                      (: 'text' :)
      let $state := p:parse-CompTextConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'comment' :)
      let $state := p:parse-CompCommentConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'processing-instruction' :)
      let $state := p:parse-CompPIConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'binary' :)
      let $state := p:parse-CompBinaryConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CompNamespaceConstructor($input, $state)
      return $state
  return p:reduce($state, "ComputedConstructor", $count)
};

(:~
 : Parse DirPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(59, $input, $state)                 (: '<?' :)
  let $state := p:lookahead1(4, $input, $state)             (: PITarget :)
  let $state := p:shift(19, $input, $state)                 (: PITarget :)
  let $state := p:lookahead1(24, $input, $state)            (: S | '?>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 23) then                       (: S :)
      let $state := p:shift(23, $input, $state)             (: S :)
      let $state := p:lookahead1(2, $input, $state)         (: DirPIContents :)
      let $state := p:shift(4, $input, $state)              (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(13, $input, $state)            (: '?>' :)
  let $state := p:shift(65, $input, $state)                 (: '?>' :)
  return p:reduce($state, "DirPIConstructor", $count)
};

(:~
 : Parse DirCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(54, $input, $state)                 (: '<!--' :)
  let $state := p:lookahead1(1, $input, $state)             (: DirCommentContents :)
  let $state := p:shift(3, $input, $state)                  (: DirCommentContents :)
  let $state := p:lookahead1(10, $input, $state)            (: '-->' :)
  let $state := p:shift(43, $input, $state)                 (: '-->' :)
  return p:reduce($state, "DirCommentConstructor", $count)
};

(:~
 : Parse CDataSection.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CDataSection($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(55, $input, $state)                 (: '<![CDATA[' :)
  let $state := p:lookahead1(3, $input, $state)             (: CDataSectionContents :)
  let $state := p:shift(5, $input, $state)                  (: CDataSectionContents :)
  let $state := p:lookahead1(14, $input, $state)            (: ']]>' :)
  let $state := p:shift(70, $input, $state)                 (: ']]>' :)
  return p:reduce($state, "CDataSection", $count)
};

(:~
 : Parse DirElemContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 53                                  (: '<' :)
     or $state[$p:l1] = 54                                  (: '<!--' :)
     or $state[$p:l1] = 59) then                            (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 55) then                       (: '<![CDATA[' :)
      let $state := p:parse-CDataSection($input, $state)
      return $state
    else if ($state[$p:l1] = 16) then                       (: ElementContentChar :)
      let $state := p:shift(16, $input, $state)             (: ElementContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return p:reduce($state, "DirElemContent", $count)
};

(:~
 : Parse AposAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AposAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 18) then                            (: AposAttrContentChar :)
      let $state := p:shift(18, $input, $state)             (: AposAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return p:reduce($state, "AposAttrValueContent", $count)
};

(:~
 : Parse EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(20, $input, $state)            (: '{' :)
  let $state := p:shift(200, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(204, $input, $state)                (: '}' :)
  return p:reduce($state, "EnclosedExpr", $count)
};

(:~
 : Parse CommonContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommonContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 13) then                            (: PredefinedEntityRef :)
      let $state := p:shift(13, $input, $state)             (: PredefinedEntityRef :)
      return $state
    else if ($state[$p:l1] = 20) then                       (: CharRef :)
      let $state := p:shift(20, $input, $state)             (: CharRef :)
      return $state
    else if ($state[$p:l1] = 201) then                      (: '{{' :)
      let $state := p:shift(201, $input, $state)            (: '{{' :)
      return $state
    else if ($state[$p:l1] = 205) then                      (: '}}' :)
      let $state := p:shift(205, $input, $state)            (: '}}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EnclosedExpr($input, $state)
      return $state
  return p:reduce($state, "CommonContent", $count)
};

(:~
 : Parse QuotAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuotAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 17) then                            (: QuotAttrContentChar :)
      let $state := p:shift(17, $input, $state)             (: QuotAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return p:reduce($state, "QuotAttrValueContent", $count)
};

(:~
 : Parse the 1st loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(149, $input, $state)         (: PredefinedEntityRef | EscapeQuot | QuotAttrContentChar |
                                                               CharRef | '"' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 28) then                          (: '"' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 14) then                      (: EscapeQuot :)
            let $state := p:shift(14, $input, $state)       (: EscapeQuot :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-QuotAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-1($input, $state)
};

(:~
 : Parse the 2nd loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(150, $input, $state)         (: PredefinedEntityRef | EscapeApos | AposAttrContentChar |
                                                               CharRef | "'" | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 33) then                          (: "'" :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 15) then                      (: EscapeApos :)
            let $state := p:shift(15, $input, $state)       (: EscapeApos :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-AposAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-2($input, $state)
};

(:~
 : Parse DirAttributeValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(26, $input, $state)            (: '"' | "'" :)
  let $state :=
    if ($state[$p:l1] = 28) then                            (: '"' :)
      let $state := p:shift(28, $input, $state)             (: '"' :)
      let $state := p:parse-DirAttributeValue-1($input, $state)
      let $state := p:shift(28, $input, $state)             (: '"' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(33, $input, $state)             (: "'" :)
      let $state := p:parse-DirAttributeValue-2($input, $state)
      let $state := p:shift(33, $input, $state)             (: "'" :)
      return $state
  return p:reduce($state, "DirAttributeValue", $count)
};

(:~
 : Parse the 1st loop of production DirAttributeList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(37, $input, $state)          (: S | '/>' | '>' :)
    return
      if ($state[$p:l1] != 23) then                         (: S :)
        $state
      else
        let $state := p:shift(23, $input, $state)           (: S :)
        let $state := p:lookahead1(86, $input, $state)      (: QName | S | '/>' | '>' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 22) then                 (: QName :)
            let $state := p:shift(22, $input, $state)       (: QName :)
            let $state := p:lookahead1(22, $input, $state)  (: S | '=' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 23) then             (: S :)
                let $state := p:shift(23, $input, $state)   (: S :)
                return $state
              else
                $state
            let $state := p:lookahead1(11, $input, $state)  (: '=' :)
            let $state := p:shift(60, $input, $state)       (: '=' :)
            let $state := p:lookahead1(36, $input, $state)  (: S | '"' | "'" :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 23) then             (: S :)
                let $state := p:shift(23, $input, $state)   (: S :)
                return $state
              else
                $state
            let $state := p:parse-DirAttributeValue($input, $state)
            return $state
          else
            $state
        return p:parse-DirAttributeList-1($input, $state)
};

(:~
 : Parse DirAttributeList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-DirAttributeList-1($input, $state)
  return p:reduce($state, "DirAttributeList", $count)
};

(:~
 : Parse the 1st loop of production DirElemConstructor (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(157, $input, $state)         (: PredefinedEntityRef | ElementContentChar | CharRef |
                                                               '<' | '<!--' | '<![CDATA[' | '</' | '<?' | '{' | '{{' |
                                                               '}}' :)
    return
      if ($state[$p:l1] = 56) then                          (: '</' :)
        $state
      else
        let $state := p:parse-DirElemContent($input, $state)
        return p:parse-DirElemConstructor-1($input, $state)
};

(:~
 : Parse DirElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(53, $input, $state)                 (: '<' :)
  let $state := p:lookahead1(5, $input, $state)             (: QName :)
  let $state := p:shift(22, $input, $state)                 (: QName :)
  let $state := p:parse-DirAttributeList($input, $state)
  let $state := p:lookahead1(27, $input, $state)            (: '/>' | '>' :)
  let $state :=
    if ($state[$p:l1] = 48) then                            (: '/>' :)
      let $state := p:shift(48, $input, $state)             (: '/>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(61, $input, $state)             (: '>' :)
      let $state := p:parse-DirElemConstructor-1($input, $state)
      let $state := p:shift(56, $input, $state)             (: '</' :)
      let $state := p:lookahead1(5, $input, $state)         (: QName :)
      let $state := p:shift(22, $input, $state)             (: QName :)
      let $state := p:lookahead1(23, $input, $state)        (: S | '>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 23) then                   (: S :)
          let $state := p:shift(23, $input, $state)         (: S :)
          return $state
        else
          $state
      let $state := p:lookahead1(12, $input, $state)        (: '>' :)
      let $state := p:shift(61, $input, $state)             (: '>' :)
      return $state
  return p:reduce($state, "DirElemConstructor", $count)
};

(:~
 : Parse DirectConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirectConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 53) then                            (: '<' :)
      let $state := p:parse-DirElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 54) then                       (: '<!--' :)
      let $state := p:parse-DirCommentConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-DirPIConstructor($input, $state)
      return $state
  return p:reduce($state, "DirectConstructor", $count)
};

(:~
 : Parse Constructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Constructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 53                                  (: '<' :)
     or $state[$p:l1] = 54                                  (: '<!--' :)
     or $state[$p:l1] = 59) then                            (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ComputedConstructor($input, $state)
      return $state
  return p:reduce($state, "Constructor", $count)
};

(:~
 : Parse UnorderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnorderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(191, $input, $state)                (: 'unordered' :)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(200, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(204, $input, $state)                (: '}' :)
  return p:reduce($state, "UnorderedExpr", $count)
};

(:~
 : Parse OrderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(155, $input, $state)                (: 'ordered' :)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(200, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(204, $input, $state)                (: '}' :)
  return p:reduce($state, "OrderedExpr", $count)
};

(:~
 : Parse ArgumentPlaceholder.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArgumentPlaceholder($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(64, $input, $state)                 (: '?' :)
  return p:reduce($state, "ArgumentPlaceholder", $count)
};

(:~
 : Parse Argument.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Argument($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(226, $input, $state)          (: Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 64) then                            (: '?' :)
      let $state := p:parse-ArgumentPlaceholder($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ExprSingle($input, $state)
      return $state
  return p:reduce($state, "Argument", $count)
};

(:~
 : Parse the 1st loop of production ArgumentList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArgumentList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(93, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(31, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-Argument($input, $state)
        return p:parse-ArgumentList-1($input, $state)
};

(:~
 : Parse ArgumentList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArgumentList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(8, $input, $state)             (: '(' :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(230, $input, $state)          (: Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | ')' | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '<' | '<!--' | '<?' | '?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:parse-Argument($input, $state)
      let $state := p:parse-ArgumentList-1($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "ArgumentList", $count)
};

(:~
 : Parse FunctionCall.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-FunctionName($input, $state)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ArgumentList($input, $state)
  return p:reduce($state, "FunctionCall", $count)
};

(:~
 : Parse ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(44, $input, $state)                 (: '.' :)
  return p:reduce($state, "ContextItemExpr", $count)
};

(:~
 : Parse ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(225, $input, $state)          (: Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | ')' | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "ParenthesizedExpr", $count)
};

(:~
 : Parse VarRef.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(211, $input, $state)          (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  return p:reduce($state, "VarRef", $count)
};

(:~
 : Parse PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(221, $input, $state)           (: EQName^Token | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | '$' | '(' | '.' | '<' |
                                                               '<!--' | '<?' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 143) then                           (: 'namespace' :)
      let $state := p:lookahead2W(178, $input, $state)      (: NCName^Token | S^WS | '#' | '(' | ('(' ':') | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'try' | 'union' |
                                                               'where' | '{' :)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'processing-instruction' :)
      let $state := p:lookahead2W(175, $input, $state)      (: NCName^Token | S^WS | '#' | ('(' ':') | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'try' | 'union' |
                                                               'where' | '{' :)
      return $state
    else if ($state[$p:l1] = 78                             (: 'element' :)
          or $state[$p:l1] = 105) then                      (: 'element' :)
      let $state := p:lookahead2W(215, $input, $state)      (: EQName^Token | S^WS | '#' | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
      return $state
    else if ($state[$p:l1] = 80                             (: 'comment' :)
          or $state[$p:l1] = 89                             (: 'text' :)
          or $state[$p:l1] = 182) then                      (: 'text' :)
      let $state := p:lookahead2W(88, $input, $state)       (: S^WS | '#' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = 103                            (: 'ordered' :)
          or $state[$p:l1] = 155                            (: 'unordered' :)
          or $state[$p:l1] = 191) then                      (: 'unordered' :)
      let $state := p:lookahead2W(127, $input, $state)      (: S^WS | '#' | '(' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = 7                              (: 'ancestor' :)
          or $state[$p:l1] = 72                             (: 'ancestor-or-self' :)
          or $state[$p:l1] = 73                             (: 'and' :)
          or $state[$p:l1] = 74                             (: 'ascending' :)
          or $state[$p:l1] = 76                             (: 'case' :)
          or $state[$p:l1] = 83                             (: 'cast' :)
          or $state[$p:l1] = 84                             (: 'castable' :)
          or $state[$p:l1] = 85                             (: 'catch' :)
          or $state[$p:l1] = 86                             (: 'child' :)
          or $state[$p:l1] = 87                             (: 'collation' :)
          or $state[$p:l1] = 88                             (: 'count' :)
          or $state[$p:l1] = 93                             (: 'declare' :)
          or $state[$p:l1] = 96                             (: 'default' :)
          or $state[$p:l1] = 97                             (: 'descendant' :)
          or $state[$p:l1] = 98                             (: 'descendant-or-self' :)
          or $state[$p:l1] = 99                             (: 'descending' :)
          or $state[$p:l1] = 100                            (: 'div' :)
          or $state[$p:l1] = 102                            (: 'else' :)
          or $state[$p:l1] = 106                            (: 'empty' :)
          or $state[$p:l1] = 107                            (: 'end' :)
          or $state[$p:l1] = 110                            (: 'eq' :)
          or $state[$p:l1] = 111                            (: 'every' :)
          or $state[$p:l1] = 112                            (: 'except' :)
          or $state[$p:l1] = 113                            (: 'following' :)
          or $state[$p:l1] = 115                            (: 'following-sibling' :)
          or $state[$p:l1] = 116                            (: 'for' :)
          or $state[$p:l1] = 117                            (: 'ge' :)
          or $state[$p:l1] = 120                            (: 'group' :)
          or $state[$p:l1] = 122                            (: 'gt' :)
          or $state[$p:l1] = 124                            (: 'idiv' :)
          or $state[$p:l1] = 125                            (: 'import' :)
          or $state[$p:l1] = 127                            (: 'instance' :)
          or $state[$p:l1] = 131                            (: 'intersect' :)
          or $state[$p:l1] = 132                            (: 'is' :)
          or $state[$p:l1] = 133                            (: 'le' :)
          or $state[$p:l1] = 136                            (: 'let' :)
          or $state[$p:l1] = 138                            (: 'lt' :)
          or $state[$p:l1] = 139                            (: 'mod' :)
          or $state[$p:l1] = 141                            (: 'module' :)
          or $state[$p:l1] = 142                            (: 'ne' :)
          or $state[$p:l1] = 145                            (: 'only' :)
          or $state[$p:l1] = 151                            (: 'or' :)
          or $state[$p:l1] = 153                            (: 'order' :)
          or $state[$p:l1] = 154                            (: 'parent' :)
          or $state[$p:l1] = 157                            (: 'preceding' :)
          or $state[$p:l1] = 161                            (: 'preceding-sibling' :)
          or $state[$p:l1] = 162                            (: 'property' :)
          or $state[$p:l1] = 167                            (: 'return' :)
          or $state[$p:l1] = 168                            (: 'satisfies' :)
          or $state[$p:l1] = 169                            (: 'self' :)
          or $state[$p:l1] = 173                            (: 'some' :)
          or $state[$p:l1] = 175                            (: 'stable' :)
          or $state[$p:l1] = 176                            (: 'start' :)
          or $state[$p:l1] = 177                            (: 'to' :)
          or $state[$p:l1] = 184                            (: 'treat' :)
          or $state[$p:l1] = 185                            (: 'try' :)
          or $state[$p:l1] = 186                            (: 'union' :)
          or $state[$p:l1] = 190                            (: 'validate' :)
          or $state[$p:l1] = 192                            (: 'where' :)
          or $state[$p:l1] = 196                            (: 'xquery' :)
          or $state[$p:l1] = 198) then                      (: 'xquery' :)
      let $state := p:lookahead2W(87, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 9                                   (: IntegerLiteral :)
     or $state[$p:lk] = 10                                  (: DecimalLiteral :)
     or $state[$p:lk] = 11                                  (: DoubleLiteral :)
     or $state[$p:lk] = 12) then                            (: StringLiteral :)
      let $state := p:parse-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 31) then                       (: '$' :)
      let $state := p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(' :)
      let $state := p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 44) then                       (: '.' :)
      let $state := p:parse-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8711                           (: EQName^Token '(' :)
          or $state[$p:lk] = 8776                           (: 'ancestor' '(' :)
          or $state[$p:lk] = 8777                           (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 8778                           (: 'and' '(' :)
          or $state[$p:lk] = 8780                           (: 'ascending' '(' :)
          or $state[$p:lk] = 8787                           (: 'case' '(' :)
          or $state[$p:lk] = 8788                           (: 'cast' '(' :)
          or $state[$p:lk] = 8789                           (: 'castable' '(' :)
          or $state[$p:lk] = 8790                           (: 'catch' '(' :)
          or $state[$p:lk] = 8791                           (: 'child' '(' :)
          or $state[$p:lk] = 8792                           (: 'collation' '(' :)
          or $state[$p:lk] = 8797                           (: 'count' '(' :)
          or $state[$p:lk] = 8800                           (: 'declare' '(' :)
          or $state[$p:lk] = 8801                           (: 'default' '(' :)
          or $state[$p:lk] = 8802                           (: 'descendant' '(' :)
          or $state[$p:lk] = 8803                           (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 8804                           (: 'descending' '(' :)
          or $state[$p:lk] = 8806                           (: 'div' '(' :)
          or $state[$p:lk] = 8807                           (: 'document' '(' :)
          or $state[$p:lk] = 8810                           (: 'else' '(' :)
          or $state[$p:lk] = 8811                           (: 'empty' '(' :)
          or $state[$p:lk] = 8814                           (: 'end' '(' :)
          or $state[$p:lk] = 8815                           (: 'eq' '(' :)
          or $state[$p:lk] = 8816                           (: 'every' '(' :)
          or $state[$p:lk] = 8817                           (: 'except' '(' :)
          or $state[$p:lk] = 8819                           (: 'following' '(' :)
          or $state[$p:lk] = 8820                           (: 'following-sibling' '(' :)
          or $state[$p:lk] = 8821                           (: 'for' '(' :)
          or $state[$p:lk] = 8824                           (: 'ge' '(' :)
          or $state[$p:lk] = 8826                           (: 'group' '(' :)
          or $state[$p:lk] = 8828                           (: 'gt' '(' :)
          or $state[$p:lk] = 8829                           (: 'idiv' '(' :)
          or $state[$p:lk] = 8831                           (: 'import' '(' :)
          or $state[$p:lk] = 8835                           (: 'instance' '(' :)
          or $state[$p:lk] = 8836                           (: 'intersect' '(' :)
          or $state[$p:lk] = 8837                           (: 'is' '(' :)
          or $state[$p:lk] = 8840                           (: 'le' '(' :)
          or $state[$p:lk] = 8842                           (: 'let' '(' :)
          or $state[$p:lk] = 8843                           (: 'lt' '(' :)
          or $state[$p:lk] = 8845                           (: 'mod' '(' :)
          or $state[$p:lk] = 8846                           (: 'module' '(' :)
          or $state[$p:lk] = 8847                           (: 'namespace' '(' :)
          or $state[$p:lk] = 8849                           (: 'ne' '(' :)
          or $state[$p:lk] = 8855                           (: 'only' '(' :)
          or $state[$p:lk] = 8857                           (: 'or' '(' :)
          or $state[$p:lk] = 8858                           (: 'order' '(' :)
          or $state[$p:lk] = 8859                           (: 'ordered' '(' :)
          or $state[$p:lk] = 8861                           (: 'parent' '(' :)
          or $state[$p:lk] = 8865                           (: 'preceding' '(' :)
          or $state[$p:lk] = 8866                           (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 8871                           (: 'property' '(' :)
          or $state[$p:lk] = 8872                           (: 'return' '(' :)
          or $state[$p:lk] = 8873                           (: 'satisfies' '(' :)
          or $state[$p:lk] = 8877                           (: 'self' '(' :)
          or $state[$p:lk] = 8879                           (: 'some' '(' :)
          or $state[$p:lk] = 8880                           (: 'stable' '(' :)
          or $state[$p:lk] = 8881                           (: 'start' '(' :)
          or $state[$p:lk] = 8888                           (: 'to' '(' :)
          or $state[$p:lk] = 8889                           (: 'treat' '(' :)
          or $state[$p:lk] = 8890                           (: 'try' '(' :)
          or $state[$p:lk] = 8894                           (: 'union' '(' :)
          or $state[$p:lk] = 8895                           (: 'unordered' '(' :)
          or $state[$p:lk] = 8896                           (: 'validate' '(' :)
          or $state[$p:lk] = 8900                           (: 'where' '(' :)
          or $state[$p:lk] = 8902) then                     (: 'xquery' '(' :)
      let $state := p:parse-FunctionCall($input, $state)
      return $state
    else if ($state[$p:lk] = 51355) then                    (: 'ordered' '{' :)
      let $state := p:parse-OrderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 51391) then                    (: 'unordered' '{' :)
      let $state := p:parse-UnorderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 104                            (: 'document-node' :)
          or $state[$p:lk] = 108                            (: 'empty-sequence' :)
          or $state[$p:lk] = 119                            (: 'function' :)
          or $state[$p:lk] = 126                            (: 'if' :)
          or $state[$p:lk] = 134                            (: 'item' :)
          or $state[$p:lk] = 144                            (: 'namespace-node' :)
          or $state[$p:lk] = 149                            (: 'node' :)
          or $state[$p:lk] = 171                            (: 'schema-attribute' :)
          or $state[$p:lk] = 172                            (: 'schema-element' :)
          or $state[$p:lk] = 181                            (: 'switch' :)
          or $state[$p:lk] = 189                            (: 'typeswitch' :)
          or $state[$p:lk] = 7431                           (: EQName^Token '#' :)
          or $state[$p:lk] = 7496                           (: 'ancestor' '#' :)
          or $state[$p:lk] = 7497                           (: 'ancestor-or-self' '#' :)
          or $state[$p:lk] = 7498                           (: 'and' '#' :)
          or $state[$p:lk] = 7500                           (: 'ascending' '#' :)
          or $state[$p:lk] = 7502                           (: 'attribute' '#' :)
          or $state[$p:lk] = 7504                           (: 'binary' '#' :)
          or $state[$p:lk] = 7507                           (: 'case' '#' :)
          or $state[$p:lk] = 7508                           (: 'cast' '#' :)
          or $state[$p:lk] = 7509                           (: 'castable' '#' :)
          or $state[$p:lk] = 7510                           (: 'catch' '#' :)
          or $state[$p:lk] = 7511                           (: 'child' '#' :)
          or $state[$p:lk] = 7512                           (: 'collation' '#' :)
          or $state[$p:lk] = 7513                           (: 'comment' '#' :)
          or $state[$p:lk] = 7517                           (: 'count' '#' :)
          or $state[$p:lk] = 7520                           (: 'declare' '#' :)
          or $state[$p:lk] = 7521                           (: 'default' '#' :)
          or $state[$p:lk] = 7522                           (: 'descendant' '#' :)
          or $state[$p:lk] = 7523                           (: 'descendant-or-self' '#' :)
          or $state[$p:lk] = 7524                           (: 'descending' '#' :)
          or $state[$p:lk] = 7526                           (: 'div' '#' :)
          or $state[$p:lk] = 7527                           (: 'document' '#' :)
          or $state[$p:lk] = 7529                           (: 'element' '#' :)
          or $state[$p:lk] = 7530                           (: 'else' '#' :)
          or $state[$p:lk] = 7531                           (: 'empty' '#' :)
          or $state[$p:lk] = 7534                           (: 'end' '#' :)
          or $state[$p:lk] = 7535                           (: 'eq' '#' :)
          or $state[$p:lk] = 7536                           (: 'every' '#' :)
          or $state[$p:lk] = 7537                           (: 'except' '#' :)
          or $state[$p:lk] = 7539                           (: 'following' '#' :)
          or $state[$p:lk] = 7540                           (: 'following-sibling' '#' :)
          or $state[$p:lk] = 7541                           (: 'for' '#' :)
          or $state[$p:lk] = 7544                           (: 'ge' '#' :)
          or $state[$p:lk] = 7546                           (: 'group' '#' :)
          or $state[$p:lk] = 7548                           (: 'gt' '#' :)
          or $state[$p:lk] = 7549                           (: 'idiv' '#' :)
          or $state[$p:lk] = 7551                           (: 'import' '#' :)
          or $state[$p:lk] = 7555                           (: 'instance' '#' :)
          or $state[$p:lk] = 7556                           (: 'intersect' '#' :)
          or $state[$p:lk] = 7557                           (: 'is' '#' :)
          or $state[$p:lk] = 7560                           (: 'le' '#' :)
          or $state[$p:lk] = 7562                           (: 'let' '#' :)
          or $state[$p:lk] = 7563                           (: 'lt' '#' :)
          or $state[$p:lk] = 7565                           (: 'mod' '#' :)
          or $state[$p:lk] = 7566                           (: 'module' '#' :)
          or $state[$p:lk] = 7567                           (: 'namespace' '#' :)
          or $state[$p:lk] = 7569                           (: 'ne' '#' :)
          or $state[$p:lk] = 7575                           (: 'only' '#' :)
          or $state[$p:lk] = 7577                           (: 'or' '#' :)
          or $state[$p:lk] = 7578                           (: 'order' '#' :)
          or $state[$p:lk] = 7579                           (: 'ordered' '#' :)
          or $state[$p:lk] = 7581                           (: 'parent' '#' :)
          or $state[$p:lk] = 7585                           (: 'preceding' '#' :)
          or $state[$p:lk] = 7586                           (: 'preceding-sibling' '#' :)
          or $state[$p:lk] = 7590                           (: 'processing-instruction' '#' :)
          or $state[$p:lk] = 7591                           (: 'property' '#' :)
          or $state[$p:lk] = 7592                           (: 'return' '#' :)
          or $state[$p:lk] = 7593                           (: 'satisfies' '#' :)
          or $state[$p:lk] = 7597                           (: 'self' '#' :)
          or $state[$p:lk] = 7599                           (: 'some' '#' :)
          or $state[$p:lk] = 7600                           (: 'stable' '#' :)
          or $state[$p:lk] = 7601                           (: 'start' '#' :)
          or $state[$p:lk] = 7606                           (: 'text' '#' :)
          or $state[$p:lk] = 7608                           (: 'to' '#' :)
          or $state[$p:lk] = 7609                           (: 'treat' '#' :)
          or $state[$p:lk] = 7610                           (: 'try' '#' :)
          or $state[$p:lk] = 7614                           (: 'union' '#' :)
          or $state[$p:lk] = 7615                           (: 'unordered' '#' :)
          or $state[$p:lk] = 7616                           (: 'validate' '#' :)
          or $state[$p:lk] = 7620                           (: 'where' '#' :)
          or $state[$p:lk] = 7622) then                     (: 'xquery' '#' :)
      let $state := p:parse-FunctionItemExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-Constructor($input, $state)
      return $state
  return p:reduce($state, "PrimaryExpr", $count)
};

(:~
 : Parse the 1st loop of production PostfixExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PostfixExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(194, $input, $state)        (: EOF | S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 34                               (: '(' :)
      and $state[$p:l1] != 68) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 68) then                      (: '[' :)
            let $state := p:parse-Predicate($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-ArgumentList($input, $state)
            return $state
        return p:parse-PostfixExpr-1($input, $state)
};

(:~
 : Parse PostfixExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PostfixExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PrimaryExpr($input, $state)
  let $state := p:parse-PostfixExpr-1($input, $state)
  return p:reduce($state, "PostfixExpr", $count)
};

(:~
 : Parse StepExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(222, $input, $state)          (: Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '(' | ('(' ':') | '.' | '..' | '<' | '<!--' |
                                                               '<?' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 78) then                            (: 'attribute' :)
      let $state := p:lookahead2W(233, $input, $state)      (: EOF | EQName^Token | S^WS | '!' | '!=' | '#' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               '::' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'ascending' | 'attribute' | 'binary' | 'case' |
                                                               'cast' | 'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] = 21326) then                     (: 'attribute' 'case' :)
          let $state := p:lookahead3W(231, $input, $state)  (: Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '%' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 22606) then                (: 'attribute' 'collation' :)
          let $state := p:lookahead3W(84, $input, $state)   (: URILiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 24910) then                (: 'attribute' 'default' :)
          let $state := p:lookahead3W(128, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 27470) then                (: 'attribute' 'empty' :)
          let $state := p:lookahead3W(137, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 30030) then                (: 'attribute' 'for' :)
          let $state := p:lookahead3W(141, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] = 33614) then                (: 'attribute' 'instance' :)
          let $state := p:lookahead3W(119, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 38734) then                (: 'attribute' 'only' :)
          let $state := p:lookahead3W(112, $input, $state)  (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = 45134) then                (: 'attribute' 'stable' :)
          let $state := p:lookahead3W(120, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 19534                      (: 'attribute' 'descending' :)
              or $state[$p:lk] = 25678) then                (: 'attribute' 'descending' :)
          let $state := p:lookahead3W(163, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 23886                      (: 'attribute' 'let' :)
              or $state[$p:lk] = 35406) then                (: 'attribute' 'let' :)
          let $state := p:lookahead3W(91, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 28238                      (: 'attribute' 'start' :)
              or $state[$p:lk] = 45390) then                (: 'attribute' 'start' :)
          let $state := p:lookahead3W(151, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 31310                      (: 'attribute' 'order' :)
              or $state[$p:lk] = 39502) then                (: 'attribute' 'order' :)
          let $state := p:lookahead3W(105, $input, $state)  (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 21582                      (: 'attribute' 'castable' :)
              or $state[$p:lk] = 21838                      (: 'attribute' 'treat' :)
              or $state[$p:lk] = 47438) then                (: 'attribute' 'treat' :)
          let $state := p:lookahead3W(103, $input, $state)  (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 19022                      (: 'attribute' 'div' :)
              or $state[$p:lk] = 26190                      (: 'attribute' 'else' :)
              or $state[$p:lk] = 27214                      (: 'attribute' 'eq' :)
              or $state[$p:lk] = 28494                      (: 'attribute' 'except' :)
              or $state[$p:lk] = 29006                      (: 'attribute' 'ge' :)
              or $state[$p:lk] = 30798                      (: 'attribute' 'gt' :)
              or $state[$p:lk] = 31822                      (: 'attribute' 'idiv' :)
              or $state[$p:lk] = 32078                      (: 'attribute' 'intersect' :)
              or $state[$p:lk] = 33870                      (: 'attribute' 'is' :)
              or $state[$p:lk] = 34126                      (: 'attribute' 'le' :)
              or $state[$p:lk] = 34894                      (: 'attribute' 'lt' :)
              or $state[$p:lk] = 35662                      (: 'attribute' 'mod' :)
              or $state[$p:lk] = 36174                      (: 'attribute' 'ne' :)
              or $state[$p:lk] = 37198                      (: 'attribute' 'or' :)
              or $state[$p:lk] = 39246                      (: 'attribute' 'return' :)
              or $state[$p:lk] = 43086                      (: 'attribute' 'satisfies' :)
              or $state[$p:lk] = 43342                      (: 'attribute' 'to' :)
              or $state[$p:lk] = 47182                      (: 'attribute' 'union' :)
              or $state[$p:lk] = 48718                      (: 'attribute' 'where' :)
              or $state[$p:lk] = 50254) then                (: 'attribute' 'where' :)
          let $state := p:lookahead3W(227, $input, $state)  (: Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'element' :)
      let $state := p:lookahead2W(232, $input, $state)      (: EOF | EQName^Token | S^WS | '!' | '!=' | '#' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] = 21353) then                     (: 'element' 'case' :)
          let $state := p:lookahead3W(231, $input, $state)  (: Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '%' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 22633) then                (: 'element' 'collation' :)
          let $state := p:lookahead3W(84, $input, $state)   (: URILiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 24937) then                (: 'element' 'default' :)
          let $state := p:lookahead3W(128, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 27497) then                (: 'element' 'empty' :)
          let $state := p:lookahead3W(137, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 30057) then                (: 'element' 'for' :)
          let $state := p:lookahead3W(141, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] = 33641) then                (: 'element' 'instance' :)
          let $state := p:lookahead3W(119, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 38761) then                (: 'element' 'only' :)
          let $state := p:lookahead3W(112, $input, $state)  (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = 45161) then                (: 'element' 'stable' :)
          let $state := p:lookahead3W(120, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 19561                      (: 'element' 'descending' :)
              or $state[$p:lk] = 25705) then                (: 'element' 'descending' :)
          let $state := p:lookahead3W(163, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 23913                      (: 'element' 'let' :)
              or $state[$p:lk] = 35433) then                (: 'element' 'let' :)
          let $state := p:lookahead3W(91, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 28265                      (: 'element' 'start' :)
              or $state[$p:lk] = 45417) then                (: 'element' 'start' :)
          let $state := p:lookahead3W(151, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 31337                      (: 'element' 'order' :)
              or $state[$p:lk] = 39529) then                (: 'element' 'order' :)
          let $state := p:lookahead3W(105, $input, $state)  (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 21609                      (: 'element' 'castable' :)
              or $state[$p:lk] = 21865                      (: 'element' 'treat' :)
              or $state[$p:lk] = 47465) then                (: 'element' 'treat' :)
          let $state := p:lookahead3W(103, $input, $state)  (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 19049                      (: 'element' 'div' :)
              or $state[$p:lk] = 26217                      (: 'element' 'else' :)
              or $state[$p:lk] = 27241                      (: 'element' 'eq' :)
              or $state[$p:lk] = 28521                      (: 'element' 'except' :)
              or $state[$p:lk] = 29033                      (: 'element' 'ge' :)
              or $state[$p:lk] = 30825                      (: 'element' 'gt' :)
              or $state[$p:lk] = 31849                      (: 'element' 'idiv' :)
              or $state[$p:lk] = 32105                      (: 'element' 'intersect' :)
              or $state[$p:lk] = 33897                      (: 'element' 'is' :)
              or $state[$p:lk] = 34153                      (: 'element' 'le' :)
              or $state[$p:lk] = 34921                      (: 'element' 'lt' :)
              or $state[$p:lk] = 35689                      (: 'element' 'mod' :)
              or $state[$p:lk] = 36201                      (: 'element' 'ne' :)
              or $state[$p:lk] = 37225                      (: 'element' 'or' :)
              or $state[$p:lk] = 39273                      (: 'element' 'return' :)
              or $state[$p:lk] = 43113                      (: 'element' 'satisfies' :)
              or $state[$p:lk] = 43369                      (: 'element' 'to' :)
              or $state[$p:lk] = 47209                      (: 'element' 'union' :)
              or $state[$p:lk] = 48745                      (: 'element' 'where' :)
              or $state[$p:lk] = 50281) then                (: 'element' 'where' :)
          let $state := p:lookahead3W(227, $input, $state)  (: Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'namespace' :)
      let $state := p:lookahead2W(206, $input, $state)      (: EOF | NCName^Token | S^WS | '!' | '!=' | '#' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               '::' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'try' | 'union' | 'where' | '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] = 21391) then                     (: 'namespace' 'case' :)
          let $state := p:lookahead3W(231, $input, $state)  (: Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '%' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 22671) then                (: 'namespace' 'collation' :)
          let $state := p:lookahead3W(84, $input, $state)   (: URILiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 24975) then                (: 'namespace' 'default' :)
          let $state := p:lookahead3W(128, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 27535) then                (: 'namespace' 'empty' :)
          let $state := p:lookahead3W(137, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 30095) then                (: 'namespace' 'for' :)
          let $state := p:lookahead3W(141, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] = 33679) then                (: 'namespace' 'instance' :)
          let $state := p:lookahead3W(119, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 38799) then                (: 'namespace' 'only' :)
          let $state := p:lookahead3W(112, $input, $state)  (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = 45199) then                (: 'namespace' 'stable' :)
          let $state := p:lookahead3W(120, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 19599                      (: 'namespace' 'descending' :)
              or $state[$p:lk] = 25743) then                (: 'namespace' 'descending' :)
          let $state := p:lookahead3W(163, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 23951                      (: 'namespace' 'let' :)
              or $state[$p:lk] = 35471) then                (: 'namespace' 'let' :)
          let $state := p:lookahead3W(91, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 28303                      (: 'namespace' 'start' :)
              or $state[$p:lk] = 45455) then                (: 'namespace' 'start' :)
          let $state := p:lookahead3W(151, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 31375                      (: 'namespace' 'order' :)
              or $state[$p:lk] = 39567) then                (: 'namespace' 'order' :)
          let $state := p:lookahead3W(105, $input, $state)  (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 21647                      (: 'namespace' 'castable' :)
              or $state[$p:lk] = 21903                      (: 'namespace' 'treat' :)
              or $state[$p:lk] = 47503) then                (: 'namespace' 'treat' :)
          let $state := p:lookahead3W(103, $input, $state)  (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 19087                      (: 'namespace' 'div' :)
              or $state[$p:lk] = 26255                      (: 'namespace' 'else' :)
              or $state[$p:lk] = 27279                      (: 'namespace' 'eq' :)
              or $state[$p:lk] = 28559                      (: 'namespace' 'except' :)
              or $state[$p:lk] = 29071                      (: 'namespace' 'ge' :)
              or $state[$p:lk] = 30863                      (: 'namespace' 'gt' :)
              or $state[$p:lk] = 31887                      (: 'namespace' 'idiv' :)
              or $state[$p:lk] = 32143                      (: 'namespace' 'intersect' :)
              or $state[$p:lk] = 33935                      (: 'namespace' 'is' :)
              or $state[$p:lk] = 34191                      (: 'namespace' 'le' :)
              or $state[$p:lk] = 34959                      (: 'namespace' 'lt' :)
              or $state[$p:lk] = 35727                      (: 'namespace' 'mod' :)
              or $state[$p:lk] = 36239                      (: 'namespace' 'ne' :)
              or $state[$p:lk] = 37263                      (: 'namespace' 'or' :)
              or $state[$p:lk] = 39311                      (: 'namespace' 'return' :)
              or $state[$p:lk] = 43151                      (: 'namespace' 'satisfies' :)
              or $state[$p:lk] = 43407                      (: 'namespace' 'to' :)
              or $state[$p:lk] = 47247                      (: 'namespace' 'union' :)
              or $state[$p:lk] = 48783                      (: 'namespace' 'where' :)
              or $state[$p:lk] = 50319) then                (: 'namespace' 'where' :)
          let $state := p:lookahead3W(227, $input, $state)  (: Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'processing-instruction' :)
      let $state := p:lookahead2W(204, $input, $state)      (: EOF | NCName^Token | S^WS | '!' | '!=' | '#' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'try' | 'union' | 'where' | '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] = 21414) then                     (: 'processing-instruction' 'case' :)
          let $state := p:lookahead3W(231, $input, $state)  (: Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '%' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' |
                                                               '..' | '/' | '//' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 22694) then                (: 'processing-instruction' 'collation' :)
          let $state := p:lookahead3W(84, $input, $state)   (: URILiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 24998) then                (: 'processing-instruction' 'default' :)
          let $state := p:lookahead3W(128, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 27558) then                (: 'processing-instruction' 'empty' :)
          let $state := p:lookahead3W(137, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 30118) then                (: 'processing-instruction' 'for' :)
          let $state := p:lookahead3W(141, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] = 33702) then                (: 'processing-instruction' 'instance' :)
          let $state := p:lookahead3W(119, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 38822) then                (: 'processing-instruction' 'only' :)
          let $state := p:lookahead3W(112, $input, $state)  (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = 45222) then                (: 'processing-instruction' 'stable' :)
          let $state := p:lookahead3W(120, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 19622                      (: 'processing-instruction' 'descending' :)
              or $state[$p:lk] = 25766) then                (: 'processing-instruction' 'descending' :)
          let $state := p:lookahead3W(163, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 23974                      (: 'processing-instruction' 'let' :)
              or $state[$p:lk] = 35494) then                (: 'processing-instruction' 'let' :)
          let $state := p:lookahead3W(91, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 28326                      (: 'processing-instruction' 'start' :)
              or $state[$p:lk] = 45478) then                (: 'processing-instruction' 'start' :)
          let $state := p:lookahead3W(151, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 31398                      (: 'processing-instruction' 'order' :)
              or $state[$p:lk] = 39590) then                (: 'processing-instruction' 'order' :)
          let $state := p:lookahead3W(105, $input, $state)  (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 21670                      (: 'processing-instruction' 'castable' :)
              or $state[$p:lk] = 21926                      (: 'processing-instruction' 'treat' :)
              or $state[$p:lk] = 47526) then                (: 'processing-instruction' 'treat' :)
          let $state := p:lookahead3W(103, $input, $state)  (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 19110                      (: 'processing-instruction' 'div' :)
              or $state[$p:lk] = 26278                      (: 'processing-instruction' 'else' :)
              or $state[$p:lk] = 27302                      (: 'processing-instruction' 'eq' :)
              or $state[$p:lk] = 28582                      (: 'processing-instruction' 'except' :)
              or $state[$p:lk] = 29094                      (: 'processing-instruction' 'ge' :)
              or $state[$p:lk] = 30886                      (: 'processing-instruction' 'gt' :)
              or $state[$p:lk] = 31910                      (: 'processing-instruction' 'idiv' :)
              or $state[$p:lk] = 32166                      (: 'processing-instruction' 'intersect' :)
              or $state[$p:lk] = 33958                      (: 'processing-instruction' 'is' :)
              or $state[$p:lk] = 34214                      (: 'processing-instruction' 'le' :)
              or $state[$p:lk] = 34982                      (: 'processing-instruction' 'lt' :)
              or $state[$p:lk] = 35750                      (: 'processing-instruction' 'mod' :)
              or $state[$p:lk] = 36262                      (: 'processing-instruction' 'ne' :)
              or $state[$p:lk] = 37286                      (: 'processing-instruction' 'or' :)
              or $state[$p:lk] = 39334                      (: 'processing-instruction' 'return' :)
              or $state[$p:lk] = 43174                      (: 'processing-instruction' 'satisfies' :)
              or $state[$p:lk] = 43430                      (: 'processing-instruction' 'to' :)
              or $state[$p:lk] = 47270                      (: 'processing-instruction' 'union' :)
              or $state[$p:lk] = 48806                      (: 'processing-instruction' 'where' :)
              or $state[$p:lk] = 50342) then                (: 'processing-instruction' 'where' :)
          let $state := p:lookahead3W(227, $input, $state)  (: Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 108                            (: 'if' :)
          or $state[$p:l1] = 126                            (: 'item' :)
          or $state[$p:l1] = 134                            (: 'switch' :)
          or $state[$p:l1] = 181                            (: 'typeswitch' :)
          or $state[$p:l1] = 189) then                      (: 'typeswitch' :)
      let $state := p:lookahead2W(193, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 80                             (: 'comment' :)
          or $state[$p:l1] = 89                             (: 'document' :)
          or $state[$p:l1] = 103                            (: 'ordered' :)
          or $state[$p:l1] = 155                            (: 'text' :)
          or $state[$p:l1] = 182                            (: 'unordered' :)
          or $state[$p:l1] = 191) then                      (: 'unordered' :)
      let $state := p:lookahead2W(203, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 72                             (: 'ancestor-or-self' :)
          or $state[$p:l1] = 73                             (: 'child' :)
          or $state[$p:l1] = 87                             (: 'descendant' :)
          or $state[$p:l1] = 98                             (: 'descendant-or-self' :)
          or $state[$p:l1] = 99                             (: 'following' :)
          or $state[$p:l1] = 115                            (: 'following-sibling' :)
          or $state[$p:l1] = 116                            (: 'parent' :)
          or $state[$p:l1] = 157                            (: 'preceding' :)
          or $state[$p:l1] = 161                            (: 'preceding-sibling' :)
          or $state[$p:l1] = 162                            (: 'property' :)
          or $state[$p:l1] = 167                            (: 'self' :)
          or $state[$p:l1] = 173) then                      (: 'self' :)
      let $state := p:lookahead2W(202, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 7                              (: 'and' :)
          or $state[$p:l1] = 74                             (: 'ascending' :)
          or $state[$p:l1] = 76                             (: 'case' :)
          or $state[$p:l1] = 83                             (: 'cast' :)
          or $state[$p:l1] = 84                             (: 'castable' :)
          or $state[$p:l1] = 85                             (: 'catch' :)
          or $state[$p:l1] = 86                             (: 'collation' :)
          or $state[$p:l1] = 88                             (: 'count' :)
          or $state[$p:l1] = 93                             (: 'declare' :)
          or $state[$p:l1] = 96                             (: 'default' :)
          or $state[$p:l1] = 97                             (: 'descending' :)
          or $state[$p:l1] = 100                            (: 'div' :)
          or $state[$p:l1] = 102                            (: 'document-node' :)
          or $state[$p:l1] = 104                            (: 'else' :)
          or $state[$p:l1] = 106                            (: 'empty' :)
          or $state[$p:l1] = 107                            (: 'end' :)
          or $state[$p:l1] = 110                            (: 'eq' :)
          or $state[$p:l1] = 111                            (: 'every' :)
          or $state[$p:l1] = 112                            (: 'except' :)
          or $state[$p:l1] = 113                            (: 'for' :)
          or $state[$p:l1] = 117                            (: 'function' :)
          or $state[$p:l1] = 119                            (: 'ge' :)
          or $state[$p:l1] = 120                            (: 'group' :)
          or $state[$p:l1] = 122                            (: 'gt' :)
          or $state[$p:l1] = 124                            (: 'idiv' :)
          or $state[$p:l1] = 125                            (: 'import' :)
          or $state[$p:l1] = 127                            (: 'instance' :)
          or $state[$p:l1] = 131                            (: 'intersect' :)
          or $state[$p:l1] = 132                            (: 'is' :)
          or $state[$p:l1] = 133                            (: 'le' :)
          or $state[$p:l1] = 136                            (: 'let' :)
          or $state[$p:l1] = 138                            (: 'lt' :)
          or $state[$p:l1] = 139                            (: 'mod' :)
          or $state[$p:l1] = 141                            (: 'module' :)
          or $state[$p:l1] = 142                            (: 'namespace-node' :)
          or $state[$p:l1] = 144                            (: 'ne' :)
          or $state[$p:l1] = 145                            (: 'node' :)
          or $state[$p:l1] = 149                            (: 'only' :)
          or $state[$p:l1] = 151                            (: 'or' :)
          or $state[$p:l1] = 153                            (: 'order' :)
          or $state[$p:l1] = 154                            (: 'return' :)
          or $state[$p:l1] = 168                            (: 'satisfies' :)
          or $state[$p:l1] = 169                            (: 'schema-attribute' :)
          or $state[$p:l1] = 171                            (: 'schema-element' :)
          or $state[$p:l1] = 172                            (: 'some' :)
          or $state[$p:l1] = 175                            (: 'stable' :)
          or $state[$p:l1] = 176                            (: 'start' :)
          or $state[$p:l1] = 177                            (: 'to' :)
          or $state[$p:l1] = 184                            (: 'treat' :)
          or $state[$p:l1] = 185                            (: 'try' :)
          or $state[$p:l1] = 186                            (: 'union' :)
          or $state[$p:l1] = 190                            (: 'validate' :)
          or $state[$p:l1] = 192                            (: 'where' :)
          or $state[$p:l1] = 196                            (: 'xquery' :)
          or $state[$p:l1] = 198) then                      (: 'xquery' :)
      let $state := p:lookahead2W(198, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 9                                   (: IntegerLiteral :)
     or $state[$p:lk] = 10                                  (: DecimalLiteral :)
     or $state[$p:lk] = 11                                  (: DoubleLiteral :)
     or $state[$p:lk] = 12                                  (: StringLiteral :)
     or $state[$p:lk] = 31                                  (: '$' :)
     or $state[$p:lk] = 34                                  (: '(' :)
     or $state[$p:lk] = 44                                  (: '.' :)
     or $state[$p:lk] = 53                                  (: '<' :)
     or $state[$p:lk] = 54                                  (: '<!--' :)
     or $state[$p:lk] = 59                                  (: '<?' :)
     or $state[$p:lk] = 1870                                (: 'attribute' EQName^Token :)
     or $state[$p:lk] = 1897                                (: 'element' EQName^Token :)
     or $state[$p:lk] = 5519                                (: 'namespace' NCName^Token :)
     or $state[$p:lk] = 5542                                (: 'processing-instruction' NCName^Token :)
     or $state[$p:lk] = 7431                                (: EQName^Token '#' :)
     or $state[$p:lk] = 7496                                (: 'ancestor' '#' :)
     or $state[$p:lk] = 7497                                (: 'ancestor-or-self' '#' :)
     or $state[$p:lk] = 7498                                (: 'and' '#' :)
     or $state[$p:lk] = 7500                                (: 'ascending' '#' :)
     or $state[$p:lk] = 7502                                (: 'attribute' '#' :)
     or $state[$p:lk] = 7504                                (: 'binary' '#' :)
     or $state[$p:lk] = 7507                                (: 'case' '#' :)
     or $state[$p:lk] = 7508                                (: 'cast' '#' :)
     or $state[$p:lk] = 7509                                (: 'castable' '#' :)
     or $state[$p:lk] = 7510                                (: 'catch' '#' :)
     or $state[$p:lk] = 7511                                (: 'child' '#' :)
     or $state[$p:lk] = 7512                                (: 'collation' '#' :)
     or $state[$p:lk] = 7513                                (: 'comment' '#' :)
     or $state[$p:lk] = 7517                                (: 'count' '#' :)
     or $state[$p:lk] = 7520                                (: 'declare' '#' :)
     or $state[$p:lk] = 7521                                (: 'default' '#' :)
     or $state[$p:lk] = 7522                                (: 'descendant' '#' :)
     or $state[$p:lk] = 7523                                (: 'descendant-or-self' '#' :)
     or $state[$p:lk] = 7524                                (: 'descending' '#' :)
     or $state[$p:lk] = 7526                                (: 'div' '#' :)
     or $state[$p:lk] = 7527                                (: 'document' '#' :)
     or $state[$p:lk] = 7528                                (: 'document-node' '#' :)
     or $state[$p:lk] = 7529                                (: 'element' '#' :)
     or $state[$p:lk] = 7530                                (: 'else' '#' :)
     or $state[$p:lk] = 7531                                (: 'empty' '#' :)
     or $state[$p:lk] = 7532                                (: 'empty-sequence' '#' :)
     or $state[$p:lk] = 7534                                (: 'end' '#' :)
     or $state[$p:lk] = 7535                                (: 'eq' '#' :)
     or $state[$p:lk] = 7536                                (: 'every' '#' :)
     or $state[$p:lk] = 7537                                (: 'except' '#' :)
     or $state[$p:lk] = 7539                                (: 'following' '#' :)
     or $state[$p:lk] = 7540                                (: 'following-sibling' '#' :)
     or $state[$p:lk] = 7541                                (: 'for' '#' :)
     or $state[$p:lk] = 7543                                (: 'function' '#' :)
     or $state[$p:lk] = 7544                                (: 'ge' '#' :)
     or $state[$p:lk] = 7546                                (: 'group' '#' :)
     or $state[$p:lk] = 7548                                (: 'gt' '#' :)
     or $state[$p:lk] = 7549                                (: 'idiv' '#' :)
     or $state[$p:lk] = 7550                                (: 'if' '#' :)
     or $state[$p:lk] = 7551                                (: 'import' '#' :)
     or $state[$p:lk] = 7555                                (: 'instance' '#' :)
     or $state[$p:lk] = 7556                                (: 'intersect' '#' :)
     or $state[$p:lk] = 7557                                (: 'is' '#' :)
     or $state[$p:lk] = 7558                                (: 'item' '#' :)
     or $state[$p:lk] = 7560                                (: 'le' '#' :)
     or $state[$p:lk] = 7562                                (: 'let' '#' :)
     or $state[$p:lk] = 7563                                (: 'lt' '#' :)
     or $state[$p:lk] = 7565                                (: 'mod' '#' :)
     or $state[$p:lk] = 7566                                (: 'module' '#' :)
     or $state[$p:lk] = 7567                                (: 'namespace' '#' :)
     or $state[$p:lk] = 7568                                (: 'namespace-node' '#' :)
     or $state[$p:lk] = 7569                                (: 'ne' '#' :)
     or $state[$p:lk] = 7573                                (: 'node' '#' :)
     or $state[$p:lk] = 7575                                (: 'only' '#' :)
     or $state[$p:lk] = 7577                                (: 'or' '#' :)
     or $state[$p:lk] = 7578                                (: 'order' '#' :)
     or $state[$p:lk] = 7579                                (: 'ordered' '#' :)
     or $state[$p:lk] = 7581                                (: 'parent' '#' :)
     or $state[$p:lk] = 7585                                (: 'preceding' '#' :)
     or $state[$p:lk] = 7586                                (: 'preceding-sibling' '#' :)
     or $state[$p:lk] = 7590                                (: 'processing-instruction' '#' :)
     or $state[$p:lk] = 7591                                (: 'property' '#' :)
     or $state[$p:lk] = 7592                                (: 'return' '#' :)
     or $state[$p:lk] = 7593                                (: 'satisfies' '#' :)
     or $state[$p:lk] = 7595                                (: 'schema-attribute' '#' :)
     or $state[$p:lk] = 7596                                (: 'schema-element' '#' :)
     or $state[$p:lk] = 7597                                (: 'self' '#' :)
     or $state[$p:lk] = 7599                                (: 'some' '#' :)
     or $state[$p:lk] = 7600                                (: 'stable' '#' :)
     or $state[$p:lk] = 7601                                (: 'start' '#' :)
     or $state[$p:lk] = 7605                                (: 'switch' '#' :)
     or $state[$p:lk] = 7606                                (: 'text' '#' :)
     or $state[$p:lk] = 7608                                (: 'to' '#' :)
     or $state[$p:lk] = 7609                                (: 'treat' '#' :)
     or $state[$p:lk] = 7610                                (: 'try' '#' :)
     or $state[$p:lk] = 7613                                (: 'typeswitch' '#' :)
     or $state[$p:lk] = 7614                                (: 'union' '#' :)
     or $state[$p:lk] = 7615                                (: 'unordered' '#' :)
     or $state[$p:lk] = 7616                                (: 'validate' '#' :)
     or $state[$p:lk] = 7620                                (: 'where' '#' :)
     or $state[$p:lk] = 7622                                (: 'xquery' '#' :)
     or $state[$p:lk] = 8711                                (: EQName^Token '(' :)
     or $state[$p:lk] = 8776                                (: 'ancestor' '(' :)
     or $state[$p:lk] = 8777                                (: 'ancestor-or-self' '(' :)
     or $state[$p:lk] = 8778                                (: 'and' '(' :)
     or $state[$p:lk] = 8780                                (: 'ascending' '(' :)
     or $state[$p:lk] = 8787                                (: 'case' '(' :)
     or $state[$p:lk] = 8788                                (: 'cast' '(' :)
     or $state[$p:lk] = 8789                                (: 'castable' '(' :)
     or $state[$p:lk] = 8790                                (: 'catch' '(' :)
     or $state[$p:lk] = 8791                                (: 'child' '(' :)
     or $state[$p:lk] = 8792                                (: 'collation' '(' :)
     or $state[$p:lk] = 8797                                (: 'count' '(' :)
     or $state[$p:lk] = 8800                                (: 'declare' '(' :)
     or $state[$p:lk] = 8801                                (: 'default' '(' :)
     or $state[$p:lk] = 8802                                (: 'descendant' '(' :)
     or $state[$p:lk] = 8803                                (: 'descendant-or-self' '(' :)
     or $state[$p:lk] = 8804                                (: 'descending' '(' :)
     or $state[$p:lk] = 8806                                (: 'div' '(' :)
     or $state[$p:lk] = 8807                                (: 'document' '(' :)
     or $state[$p:lk] = 8810                                (: 'else' '(' :)
     or $state[$p:lk] = 8811                                (: 'empty' '(' :)
     or $state[$p:lk] = 8814                                (: 'end' '(' :)
     or $state[$p:lk] = 8815                                (: 'eq' '(' :)
     or $state[$p:lk] = 8816                                (: 'every' '(' :)
     or $state[$p:lk] = 8817                                (: 'except' '(' :)
     or $state[$p:lk] = 8819                                (: 'following' '(' :)
     or $state[$p:lk] = 8820                                (: 'following-sibling' '(' :)
     or $state[$p:lk] = 8821                                (: 'for' '(' :)
     or $state[$p:lk] = 8823                                (: 'function' '(' :)
     or $state[$p:lk] = 8824                                (: 'ge' '(' :)
     or $state[$p:lk] = 8826                                (: 'group' '(' :)
     or $state[$p:lk] = 8828                                (: 'gt' '(' :)
     or $state[$p:lk] = 8829                                (: 'idiv' '(' :)
     or $state[$p:lk] = 8831                                (: 'import' '(' :)
     or $state[$p:lk] = 8835                                (: 'instance' '(' :)
     or $state[$p:lk] = 8836                                (: 'intersect' '(' :)
     or $state[$p:lk] = 8837                                (: 'is' '(' :)
     or $state[$p:lk] = 8840                                (: 'le' '(' :)
     or $state[$p:lk] = 8842                                (: 'let' '(' :)
     or $state[$p:lk] = 8843                                (: 'lt' '(' :)
     or $state[$p:lk] = 8845                                (: 'mod' '(' :)
     or $state[$p:lk] = 8846                                (: 'module' '(' :)
     or $state[$p:lk] = 8847                                (: 'namespace' '(' :)
     or $state[$p:lk] = 8849                                (: 'ne' '(' :)
     or $state[$p:lk] = 8855                                (: 'only' '(' :)
     or $state[$p:lk] = 8857                                (: 'or' '(' :)
     or $state[$p:lk] = 8858                                (: 'order' '(' :)
     or $state[$p:lk] = 8859                                (: 'ordered' '(' :)
     or $state[$p:lk] = 8861                                (: 'parent' '(' :)
     or $state[$p:lk] = 8865                                (: 'preceding' '(' :)
     or $state[$p:lk] = 8866                                (: 'preceding-sibling' '(' :)
     or $state[$p:lk] = 8871                                (: 'property' '(' :)
     or $state[$p:lk] = 8872                                (: 'return' '(' :)
     or $state[$p:lk] = 8873                                (: 'satisfies' '(' :)
     or $state[$p:lk] = 8877                                (: 'self' '(' :)
     or $state[$p:lk] = 8879                                (: 'some' '(' :)
     or $state[$p:lk] = 8880                                (: 'stable' '(' :)
     or $state[$p:lk] = 8881                                (: 'start' '(' :)
     or $state[$p:lk] = 8888                                (: 'to' '(' :)
     or $state[$p:lk] = 8889                                (: 'treat' '(' :)
     or $state[$p:lk] = 8890                                (: 'try' '(' :)
     or $state[$p:lk] = 8894                                (: 'union' '(' :)
     or $state[$p:lk] = 8895                                (: 'unordered' '(' :)
     or $state[$p:lk] = 8896                                (: 'validate' '(' :)
     or $state[$p:lk] = 8900                                (: 'where' '(' :)
     or $state[$p:lk] = 8902                                (: 'xquery' '(' :)
     or $state[$p:lk] = 18510                               (: 'attribute' 'ancestor' :)
     or $state[$p:lk] = 18537                               (: 'element' 'ancestor' :)
     or $state[$p:lk] = 18766                               (: 'attribute' 'ancestor-or-self' :)
     or $state[$p:lk] = 18793                               (: 'element' 'ancestor-or-self' :)
     or $state[$p:lk] = 20046                               (: 'attribute' 'attribute' :)
     or $state[$p:lk] = 20073                               (: 'element' 'attribute' :)
     or $state[$p:lk] = 20558                               (: 'attribute' 'binary' :)
     or $state[$p:lk] = 20585                               (: 'element' 'binary' :)
     or $state[$p:lk] = 22094                               (: 'attribute' 'catch' :)
     or $state[$p:lk] = 22121                               (: 'element' 'catch' :)
     or $state[$p:lk] = 22350                               (: 'attribute' 'child' :)
     or $state[$p:lk] = 22377                               (: 'element' 'child' :)
     or $state[$p:lk] = 22862                               (: 'attribute' 'comment' :)
     or $state[$p:lk] = 22889                               (: 'element' 'comment' :)
     or $state[$p:lk] = 24654                               (: 'attribute' 'declare' :)
     or $state[$p:lk] = 24681                               (: 'element' 'declare' :)
     or $state[$p:lk] = 25166                               (: 'attribute' 'descendant' :)
     or $state[$p:lk] = 25193                               (: 'element' 'descendant' :)
     or $state[$p:lk] = 25422                               (: 'attribute' 'descendant-or-self' :)
     or $state[$p:lk] = 25449                               (: 'element' 'descendant-or-self' :)
     or $state[$p:lk] = 26446                               (: 'attribute' 'document' :)
     or $state[$p:lk] = 26473                               (: 'element' 'document' :)
     or $state[$p:lk] = 26702                               (: 'attribute' 'document-node' :)
     or $state[$p:lk] = 26729                               (: 'element' 'document-node' :)
     or $state[$p:lk] = 26958                               (: 'attribute' 'element' :)
     or $state[$p:lk] = 26985                               (: 'element' 'element' :)
     or $state[$p:lk] = 27726                               (: 'attribute' 'empty-sequence' :)
     or $state[$p:lk] = 27753                               (: 'element' 'empty-sequence' :)
     or $state[$p:lk] = 28750                               (: 'attribute' 'every' :)
     or $state[$p:lk] = 28777                               (: 'element' 'every' :)
     or $state[$p:lk] = 29518                               (: 'attribute' 'following' :)
     or $state[$p:lk] = 29545                               (: 'element' 'following' :)
     or $state[$p:lk] = 29774                               (: 'attribute' 'following-sibling' :)
     or $state[$p:lk] = 29801                               (: 'element' 'following-sibling' :)
     or $state[$p:lk] = 30542                               (: 'attribute' 'function' :)
     or $state[$p:lk] = 30569                               (: 'element' 'function' :)
     or $state[$p:lk] = 32334                               (: 'attribute' 'if' :)
     or $state[$p:lk] = 32361                               (: 'element' 'if' :)
     or $state[$p:lk] = 32590                               (: 'attribute' 'import' :)
     or $state[$p:lk] = 32617                               (: 'element' 'import' :)
     or $state[$p:lk] = 34382                               (: 'attribute' 'item' :)
     or $state[$p:lk] = 34409                               (: 'element' 'item' :)
     or $state[$p:lk] = 36430                               (: 'attribute' 'module' :)
     or $state[$p:lk] = 36457                               (: 'element' 'module' :)
     or $state[$p:lk] = 36686                               (: 'attribute' 'namespace' :)
     or $state[$p:lk] = 36713                               (: 'element' 'namespace' :)
     or $state[$p:lk] = 36942                               (: 'attribute' 'namespace-node' :)
     or $state[$p:lk] = 36969                               (: 'element' 'namespace-node' :)
     or $state[$p:lk] = 38222                               (: 'attribute' 'node' :)
     or $state[$p:lk] = 38249                               (: 'element' 'node' :)
     or $state[$p:lk] = 39758                               (: 'attribute' 'ordered' :)
     or $state[$p:lk] = 39785                               (: 'element' 'ordered' :)
     or $state[$p:lk] = 40270                               (: 'attribute' 'parent' :)
     or $state[$p:lk] = 40297                               (: 'element' 'parent' :)
     or $state[$p:lk] = 41294                               (: 'attribute' 'preceding' :)
     or $state[$p:lk] = 41321                               (: 'element' 'preceding' :)
     or $state[$p:lk] = 41550                               (: 'attribute' 'preceding-sibling' :)
     or $state[$p:lk] = 41577                               (: 'element' 'preceding-sibling' :)
     or $state[$p:lk] = 42574                               (: 'attribute' 'processing-instruction' :)
     or $state[$p:lk] = 42601                               (: 'element' 'processing-instruction' :)
     or $state[$p:lk] = 42830                               (: 'attribute' 'property' :)
     or $state[$p:lk] = 42857                               (: 'element' 'property' :)
     or $state[$p:lk] = 43854                               (: 'attribute' 'schema-attribute' :)
     or $state[$p:lk] = 43881                               (: 'element' 'schema-attribute' :)
     or $state[$p:lk] = 44110                               (: 'attribute' 'schema-element' :)
     or $state[$p:lk] = 44137                               (: 'element' 'schema-element' :)
     or $state[$p:lk] = 44366                               (: 'attribute' 'self' :)
     or $state[$p:lk] = 44393                               (: 'element' 'self' :)
     or $state[$p:lk] = 44878                               (: 'attribute' 'some' :)
     or $state[$p:lk] = 44905                               (: 'element' 'some' :)
     or $state[$p:lk] = 46414                               (: 'attribute' 'switch' :)
     or $state[$p:lk] = 46441                               (: 'element' 'switch' :)
     or $state[$p:lk] = 46670                               (: 'attribute' 'text' :)
     or $state[$p:lk] = 46697                               (: 'element' 'text' :)
     or $state[$p:lk] = 47694                               (: 'attribute' 'try' :)
     or $state[$p:lk] = 47721                               (: 'element' 'try' :)
     or $state[$p:lk] = 47759                               (: 'namespace' 'try' :)
     or $state[$p:lk] = 47782                               (: 'processing-instruction' 'try' :)
     or $state[$p:lk] = 48462                               (: 'attribute' 'typeswitch' :)
     or $state[$p:lk] = 48489                               (: 'element' 'typeswitch' :)
     or $state[$p:lk] = 48974                               (: 'attribute' 'unordered' :)
     or $state[$p:lk] = 49001                               (: 'element' 'unordered' :)
     or $state[$p:lk] = 49230                               (: 'attribute' 'validate' :)
     or $state[$p:lk] = 49257                               (: 'element' 'validate' :)
     or $state[$p:lk] = 50766                               (: 'attribute' 'xquery' :)
     or $state[$p:lk] = 50793                               (: 'element' 'xquery' :)
     or $state[$p:lk] = 51278                               (: 'attribute' '{' :)
     or $state[$p:lk] = 51280                               (: 'binary' '{' :)
     or $state[$p:lk] = 51289                               (: 'comment' '{' :)
     or $state[$p:lk] = 51303                               (: 'document' '{' :)
     or $state[$p:lk] = 51305                               (: 'element' '{' :)
     or $state[$p:lk] = 51343                               (: 'namespace' '{' :)
     or $state[$p:lk] = 51355                               (: 'ordered' '{' :)
     or $state[$p:lk] = 51366                               (: 'processing-instruction' '{' :)
     or $state[$p:lk] = 51382                               (: 'text' '{' :)
     or $state[$p:lk] = 51391                               (: 'unordered' '{' :)
     or $state[$p:lk] = 13126222                            (: 'attribute' 'and' '{' :)
     or $state[$p:lk] = 13126249                            (: 'element' 'and' '{' :)
     or $state[$p:lk] = 13126287                            (: 'namespace' 'and' '{' :)
     or $state[$p:lk] = 13126310                            (: 'processing-instruction' 'and' '{' :)
     or $state[$p:lk] = 13126734                            (: 'attribute' 'ascending' '{' :)
     or $state[$p:lk] = 13126761                            (: 'element' 'ascending' '{' :)
     or $state[$p:lk] = 13126799                            (: 'namespace' 'ascending' '{' :)
     or $state[$p:lk] = 13126822                            (: 'processing-instruction' 'ascending' '{' :)
     or $state[$p:lk] = 13128526                            (: 'attribute' 'case' '{' :)
     or $state[$p:lk] = 13128553                            (: 'element' 'case' '{' :)
     or $state[$p:lk] = 13128591                            (: 'namespace' 'case' '{' :)
     or $state[$p:lk] = 13128614                            (: 'processing-instruction' 'case' '{' :)
     or $state[$p:lk] = 13128782                            (: 'attribute' 'cast' '{' :)
     or $state[$p:lk] = 13128809                            (: 'element' 'cast' '{' :)
     or $state[$p:lk] = 13128847                            (: 'namespace' 'cast' '{' :)
     or $state[$p:lk] = 13128870                            (: 'processing-instruction' 'cast' '{' :)
     or $state[$p:lk] = 13129038                            (: 'attribute' 'castable' '{' :)
     or $state[$p:lk] = 13129065                            (: 'element' 'castable' '{' :)
     or $state[$p:lk] = 13129103                            (: 'namespace' 'castable' '{' :)
     or $state[$p:lk] = 13129126                            (: 'processing-instruction' 'castable' '{' :)
     or $state[$p:lk] = 13129806                            (: 'attribute' 'collation' '{' :)
     or $state[$p:lk] = 13129833                            (: 'element' 'collation' '{' :)
     or $state[$p:lk] = 13129871                            (: 'namespace' 'collation' '{' :)
     or $state[$p:lk] = 13129894                            (: 'processing-instruction' 'collation' '{' :)
     or $state[$p:lk] = 13131086                            (: 'attribute' 'count' '{' :)
     or $state[$p:lk] = 13131113                            (: 'element' 'count' '{' :)
     or $state[$p:lk] = 13131151                            (: 'namespace' 'count' '{' :)
     or $state[$p:lk] = 13131174                            (: 'processing-instruction' 'count' '{' :)
     or $state[$p:lk] = 13132110                            (: 'attribute' 'default' '{' :)
     or $state[$p:lk] = 13132137                            (: 'element' 'default' '{' :)
     or $state[$p:lk] = 13132175                            (: 'namespace' 'default' '{' :)
     or $state[$p:lk] = 13132198                            (: 'processing-instruction' 'default' '{' :)
     or $state[$p:lk] = 13132878                            (: 'attribute' 'descending' '{' :)
     or $state[$p:lk] = 13132905                            (: 'element' 'descending' '{' :)
     or $state[$p:lk] = 13132943                            (: 'namespace' 'descending' '{' :)
     or $state[$p:lk] = 13132966                            (: 'processing-instruction' 'descending' '{' :)
     or $state[$p:lk] = 13133390                            (: 'attribute' 'div' '{' :)
     or $state[$p:lk] = 13133417                            (: 'element' 'div' '{' :)
     or $state[$p:lk] = 13133455                            (: 'namespace' 'div' '{' :)
     or $state[$p:lk] = 13133478                            (: 'processing-instruction' 'div' '{' :)
     or $state[$p:lk] = 13134414                            (: 'attribute' 'else' '{' :)
     or $state[$p:lk] = 13134441                            (: 'element' 'else' '{' :)
     or $state[$p:lk] = 13134479                            (: 'namespace' 'else' '{' :)
     or $state[$p:lk] = 13134502                            (: 'processing-instruction' 'else' '{' :)
     or $state[$p:lk] = 13134670                            (: 'attribute' 'empty' '{' :)
     or $state[$p:lk] = 13134697                            (: 'element' 'empty' '{' :)
     or $state[$p:lk] = 13134735                            (: 'namespace' 'empty' '{' :)
     or $state[$p:lk] = 13134758                            (: 'processing-instruction' 'empty' '{' :)
     or $state[$p:lk] = 13135438                            (: 'attribute' 'end' '{' :)
     or $state[$p:lk] = 13135465                            (: 'element' 'end' '{' :)
     or $state[$p:lk] = 13135503                            (: 'namespace' 'end' '{' :)
     or $state[$p:lk] = 13135526                            (: 'processing-instruction' 'end' '{' :)
     or $state[$p:lk] = 13135694                            (: 'attribute' 'eq' '{' :)
     or $state[$p:lk] = 13135721                            (: 'element' 'eq' '{' :)
     or $state[$p:lk] = 13135759                            (: 'namespace' 'eq' '{' :)
     or $state[$p:lk] = 13135782                            (: 'processing-instruction' 'eq' '{' :)
     or $state[$p:lk] = 13136206                            (: 'attribute' 'except' '{' :)
     or $state[$p:lk] = 13136233                            (: 'element' 'except' '{' :)
     or $state[$p:lk] = 13136271                            (: 'namespace' 'except' '{' :)
     or $state[$p:lk] = 13136294                            (: 'processing-instruction' 'except' '{' :)
     or $state[$p:lk] = 13137230                            (: 'attribute' 'for' '{' :)
     or $state[$p:lk] = 13137257                            (: 'element' 'for' '{' :)
     or $state[$p:lk] = 13137295                            (: 'namespace' 'for' '{' :)
     or $state[$p:lk] = 13137318                            (: 'processing-instruction' 'for' '{' :)
     or $state[$p:lk] = 13137998                            (: 'attribute' 'ge' '{' :)
     or $state[$p:lk] = 13138025                            (: 'element' 'ge' '{' :)
     or $state[$p:lk] = 13138063                            (: 'namespace' 'ge' '{' :)
     or $state[$p:lk] = 13138086                            (: 'processing-instruction' 'ge' '{' :)
     or $state[$p:lk] = 13138510                            (: 'attribute' 'group' '{' :)
     or $state[$p:lk] = 13138537                            (: 'element' 'group' '{' :)
     or $state[$p:lk] = 13138575                            (: 'namespace' 'group' '{' :)
     or $state[$p:lk] = 13138598                            (: 'processing-instruction' 'group' '{' :)
     or $state[$p:lk] = 13139022                            (: 'attribute' 'gt' '{' :)
     or $state[$p:lk] = 13139049                            (: 'element' 'gt' '{' :)
     or $state[$p:lk] = 13139087                            (: 'namespace' 'gt' '{' :)
     or $state[$p:lk] = 13139110                            (: 'processing-instruction' 'gt' '{' :)
     or $state[$p:lk] = 13139278                            (: 'attribute' 'idiv' '{' :)
     or $state[$p:lk] = 13139305                            (: 'element' 'idiv' '{' :)
     or $state[$p:lk] = 13139343                            (: 'namespace' 'idiv' '{' :)
     or $state[$p:lk] = 13139366                            (: 'processing-instruction' 'idiv' '{' :)
     or $state[$p:lk] = 13140814                            (: 'attribute' 'instance' '{' :)
     or $state[$p:lk] = 13140841                            (: 'element' 'instance' '{' :)
     or $state[$p:lk] = 13140879                            (: 'namespace' 'instance' '{' :)
     or $state[$p:lk] = 13140902                            (: 'processing-instruction' 'instance' '{' :)
     or $state[$p:lk] = 13141070                            (: 'attribute' 'intersect' '{' :)
     or $state[$p:lk] = 13141097                            (: 'element' 'intersect' '{' :)
     or $state[$p:lk] = 13141135                            (: 'namespace' 'intersect' '{' :)
     or $state[$p:lk] = 13141158                            (: 'processing-instruction' 'intersect' '{' :)
     or $state[$p:lk] = 13141326                            (: 'attribute' 'is' '{' :)
     or $state[$p:lk] = 13141353                            (: 'element' 'is' '{' :)
     or $state[$p:lk] = 13141391                            (: 'namespace' 'is' '{' :)
     or $state[$p:lk] = 13141414                            (: 'processing-instruction' 'is' '{' :)
     or $state[$p:lk] = 13142094                            (: 'attribute' 'le' '{' :)
     or $state[$p:lk] = 13142121                            (: 'element' 'le' '{' :)
     or $state[$p:lk] = 13142159                            (: 'namespace' 'le' '{' :)
     or $state[$p:lk] = 13142182                            (: 'processing-instruction' 'le' '{' :)
     or $state[$p:lk] = 13142606                            (: 'attribute' 'let' '{' :)
     or $state[$p:lk] = 13142633                            (: 'element' 'let' '{' :)
     or $state[$p:lk] = 13142671                            (: 'namespace' 'let' '{' :)
     or $state[$p:lk] = 13142694                            (: 'processing-instruction' 'let' '{' :)
     or $state[$p:lk] = 13142862                            (: 'attribute' 'lt' '{' :)
     or $state[$p:lk] = 13142889                            (: 'element' 'lt' '{' :)
     or $state[$p:lk] = 13142927                            (: 'namespace' 'lt' '{' :)
     or $state[$p:lk] = 13142950                            (: 'processing-instruction' 'lt' '{' :)
     or $state[$p:lk] = 13143374                            (: 'attribute' 'mod' '{' :)
     or $state[$p:lk] = 13143401                            (: 'element' 'mod' '{' :)
     or $state[$p:lk] = 13143439                            (: 'namespace' 'mod' '{' :)
     or $state[$p:lk] = 13143462                            (: 'processing-instruction' 'mod' '{' :)
     or $state[$p:lk] = 13144398                            (: 'attribute' 'ne' '{' :)
     or $state[$p:lk] = 13144425                            (: 'element' 'ne' '{' :)
     or $state[$p:lk] = 13144463                            (: 'namespace' 'ne' '{' :)
     or $state[$p:lk] = 13144486                            (: 'processing-instruction' 'ne' '{' :)
     or $state[$p:lk] = 13145934                            (: 'attribute' 'only' '{' :)
     or $state[$p:lk] = 13145961                            (: 'element' 'only' '{' :)
     or $state[$p:lk] = 13145999                            (: 'namespace' 'only' '{' :)
     or $state[$p:lk] = 13146022                            (: 'processing-instruction' 'only' '{' :)
     or $state[$p:lk] = 13146446                            (: 'attribute' 'or' '{' :)
     or $state[$p:lk] = 13146473                            (: 'element' 'or' '{' :)
     or $state[$p:lk] = 13146511                            (: 'namespace' 'or' '{' :)
     or $state[$p:lk] = 13146534                            (: 'processing-instruction' 'or' '{' :)
     or $state[$p:lk] = 13146702                            (: 'attribute' 'order' '{' :)
     or $state[$p:lk] = 13146729                            (: 'element' 'order' '{' :)
     or $state[$p:lk] = 13146767                            (: 'namespace' 'order' '{' :)
     or $state[$p:lk] = 13146790                            (: 'processing-instruction' 'order' '{' :)
     or $state[$p:lk] = 13150286                            (: 'attribute' 'return' '{' :)
     or $state[$p:lk] = 13150313                            (: 'element' 'return' '{' :)
     or $state[$p:lk] = 13150351                            (: 'namespace' 'return' '{' :)
     or $state[$p:lk] = 13150374                            (: 'processing-instruction' 'return' '{' :)
     or $state[$p:lk] = 13150542                            (: 'attribute' 'satisfies' '{' :)
     or $state[$p:lk] = 13150569                            (: 'element' 'satisfies' '{' :)
     or $state[$p:lk] = 13150607                            (: 'namespace' 'satisfies' '{' :)
     or $state[$p:lk] = 13150630                            (: 'processing-instruction' 'satisfies' '{' :)
     or $state[$p:lk] = 13152334                            (: 'attribute' 'stable' '{' :)
     or $state[$p:lk] = 13152361                            (: 'element' 'stable' '{' :)
     or $state[$p:lk] = 13152399                            (: 'namespace' 'stable' '{' :)
     or $state[$p:lk] = 13152422                            (: 'processing-instruction' 'stable' '{' :)
     or $state[$p:lk] = 13152590                            (: 'attribute' 'start' '{' :)
     or $state[$p:lk] = 13152617                            (: 'element' 'start' '{' :)
     or $state[$p:lk] = 13152655                            (: 'namespace' 'start' '{' :)
     or $state[$p:lk] = 13152678                            (: 'processing-instruction' 'start' '{' :)
     or $state[$p:lk] = 13154382                            (: 'attribute' 'to' '{' :)
     or $state[$p:lk] = 13154409                            (: 'element' 'to' '{' :)
     or $state[$p:lk] = 13154447                            (: 'namespace' 'to' '{' :)
     or $state[$p:lk] = 13154470                            (: 'processing-instruction' 'to' '{' :)
     or $state[$p:lk] = 13154638                            (: 'attribute' 'treat' '{' :)
     or $state[$p:lk] = 13154665                            (: 'element' 'treat' '{' :)
     or $state[$p:lk] = 13154703                            (: 'namespace' 'treat' '{' :)
     or $state[$p:lk] = 13154726                            (: 'processing-instruction' 'treat' '{' :)
     or $state[$p:lk] = 13155918                            (: 'attribute' 'union' '{' :)
     or $state[$p:lk] = 13155945                            (: 'element' 'union' '{' :)
     or $state[$p:lk] = 13155983                            (: 'namespace' 'union' '{' :)
     or $state[$p:lk] = 13156006                            (: 'processing-instruction' 'union' '{' :)
     or $state[$p:lk] = 13157454                            (: 'attribute' 'where' '{' :)
     or $state[$p:lk] = 13157481                            (: 'element' 'where' '{' :)
     or $state[$p:lk] = 13157519                            (: 'namespace' 'where' '{' :)
     or $state[$p:lk] = 13157542) then                      (: 'processing-instruction' 'where' '{' :)
      let $state := p:parse-PostfixExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AxisStep($input, $state)
      return $state
  return p:reduce($state, "StepExpr", $count)
};

(:~
 : Parse the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(191, $input, $state)        (: EOF | S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 26                               (: '!' :)
      and $state[$p:l1] != 46                               (: '/' :)
      and $state[$p:l1] != 47) then                         (: '//' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 46) then                      (: '/' :)
            let $state := p:shift(46, $input, $state)       (: '/' :)
            return $state
          else if ($state[$p:l1] = 47) then                 (: '//' :)
            let $state := p:shift(47, $input, $state)       (: '//' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(26, $input, $state)       (: '!' :)
            return $state
        let $state := p:lookahead1W(31, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-StepExpr($input, $state)
        return p:parse-RelativePathExpr-1($input, $state)
};

(:~
 : Parse RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-StepExpr($input, $state)
  let $state := p:parse-RelativePathExpr-1($input, $state)
  return p:reduce($state, "RelativePathExpr", $count)
};

(:~
 : Parse PathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 46) then                            (: '/' :)
      let $state := p:shift(46, $input, $state)             (: '/' :)
      let $state := p:lookahead1W(234, $input, $state)      (: EOF | Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '!=' | '$' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '.' | '..' | ';' | '<' | '<!--' | '<<' | '<=' |
                                                               '<?' | '=' | '>' | '>=' | '>>' | '@' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:l1] = 1                               (: EOF :)
         or $state[$p:l1] = 27                              (: '!=' :)
         or $state[$p:l1] = 37                              (: ')' :)
         or $state[$p:l1] = 38                              (: '*' :)
         or $state[$p:l1] = 40                              (: '+' :)
         or $state[$p:l1] = 41                              (: ',' :)
         or $state[$p:l1] = 42                              (: '-' :)
         or $state[$p:l1] = 52                              (: ';' :)
         or $state[$p:l1] = 57                              (: '<<' :)
         or $state[$p:l1] = 58                              (: '<=' :)
         or $state[$p:l1] = 60                              (: '=' :)
         or $state[$p:l1] = 61                              (: '>' :)
         or $state[$p:l1] = 62                              (: '>=' :)
         or $state[$p:l1] = 63                              (: '>>' :)
         or $state[$p:l1] = 69                              (: ']' :)
         or $state[$p:l1] = 202                             (: '|' :)
         or $state[$p:l1] = 203                             (: '||' :)
         or $state[$p:l1] = 204) then                       (: '}' :)
          $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 47) then                       (: '//' :)
      let $state := p:shift(47, $input, $state)             (: '//' :)
      let $state := p:lookahead1W(31, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
  return p:reduce($state, "PathExpr", $count)
};

(:~
 : Parse ValidationMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidationMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 135) then                           (: 'lax' :)
      let $state := p:shift(135, $input, $state)            (: 'lax' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(178, $input, $state)            (: 'strict' :)
      return $state
  return p:reduce($state, "ValidationMode", $count)
};

(:~
 : Parse ValidateExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidateExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(192, $input, $state)                (: 'validate' :)
  let $state := p:lookahead1W(153, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'full' | 'lax' | 'strict' |
                                                               'type' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 118                           (: 'full' :)
         and $state[$p:l1] != 200) then                     (: '{' :)
      let $state :=
        if ($state[$p:l1] = 135                             (: 'lax' :)
         or $state[$p:l1] = 178) then                       (: 'strict' :)
          let $state := p:parse-ValidationMode($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state :=
            if ($state[$p:l1] = 75) then                    (: 'as' :)
              let $state := p:shift(75, $input, $state)     (: 'as' :)
              return $state
            else if ($state[$p:error]) then
              $state
            else
              let $state := p:shift(188, $input, $state)    (: 'type' :)
              return $state
          let $state := p:lookahead1W(211, $input, $state)  (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
          let $state := p:parse-TypeName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(114, $input, $state)          (: S^WS | ('(' ':') | 'full' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 118) then                      (: 'full' :)
      let $state := p:shift(118, $input, $state)            (: 'full' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(200, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(204, $input, $state)                (: '}' :)
  return p:reduce($state, "ValidateExpr", $count)
};

(:~
 : Parse ValueExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 192) then                           (: 'validate' :)
      let $state := p:lookahead2W(207, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'as' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'full' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'lax' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'strict' |
                                                               'to' | 'treat' | 'type' | 'union' | 'where' | '{' | '|' |
                                                               '||' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 19392                               (: 'validate' 'as' :)
     or $state[$p:lk] = 30400                               (: 'validate' 'full' :)
     or $state[$p:lk] = 34752                               (: 'validate' 'lax' :)
     or $state[$p:lk] = 45760                               (: 'validate' 'strict' :)
     or $state[$p:lk] = 48320                               (: 'validate' 'type' :)
     or $state[$p:lk] = 51392) then                         (: 'validate' '{' :)
      let $state := p:parse-ValidateExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 35) then                       (: '(#' :)
      let $state := p:parse-ExtensionExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-PathExpr($input, $state)
      return $state
  return p:reduce($state, "ValueExpr", $count)
};

(:~
 : Parse the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(223, $input, $state)        (: Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
    return
      if ($state[$p:l1] != 40                               (: '+' :)
      and $state[$p:l1] != 42) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 42) then                      (: '-' :)
            let $state := p:shift(42, $input, $state)       (: '-' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(40, $input, $state)       (: '+' :)
            return $state
        return p:parse-UnaryExpr-1($input, $state)
};

(:~
 : Parse UnaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-UnaryExpr-1($input, $state)
  let $state := p:parse-ValueExpr($input, $state)
  return p:reduce($state, "UnaryExpr", $count)
};

(:~
 : Parse CastExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-UnaryExpr($input, $state)
  let $state := p:lookahead1W(189, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 84) then                       (: 'cast' :)
      let $state := p:shift(84, $input, $state)             (: 'cast' :)
      let $state := p:lookahead1W(49, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(75, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(31, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "CastExpr", $count)
};

(:~
 : Parse CastableExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-CastExpr($input, $state)
  let $state := p:lookahead1W(188, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 85) then                       (: 'castable' :)
      let $state := p:shift(85, $input, $state)             (: 'castable' :)
      let $state := p:lookahead1W(49, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(75, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(31, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "CastableExpr", $count)
};

(:~
 : Parse TreatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-CastableExpr($input, $state)
  let $state := p:lookahead1W(187, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'collation' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'treat' | 'union' | 'where' | '|' |
                                                               '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 185) then                      (: 'treat' :)
      let $state := p:shift(185, $input, $state)            (: 'treat' :)
      let $state := p:lookahead1W(49, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(75, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(31, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "TreatExpr", $count)
};

(:~
 : Parse InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-TreatExpr($input, $state)
  let $state := p:lookahead1W(185, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'collation' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'union' | 'where' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 131) then                      (: 'instance' :)
      let $state := p:shift(131, $input, $state)            (: 'instance' :)
      let $state := p:lookahead1W(69, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:shift(150, $input, $state)            (: 'of' :)
      let $state := p:lookahead1W(31, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "InstanceofExpr", $count)
};

(:~
 : Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(184, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'collation' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'intersect' | 'is' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'union' | 'where' | '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 113                              (: 'except' :)
      and $state[$p:l1] != 132) then                        (: 'intersect' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 132) then                     (: 'intersect' :)
            let $state := p:shift(132, $input, $state)      (: 'intersect' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(113, $input, $state)      (: 'except' :)
            return $state
        let $state := p:lookahead1W(31, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-InstanceofExpr($input, $state)
        return p:parse-IntersectExceptExpr-1($input, $state)
};

(:~
 : Parse IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-InstanceofExpr($input, $state)
  let $state := p:parse-IntersectExceptExpr-1($input, $state)
  return p:reduce($state, "IntersectExceptExpr", $count)
};

(:~
 : Parse the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(183, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'collation' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'union' | 'where' | '|' |
                                                               '||' | '}' :)
    return
      if ($state[$p:l1] != 190                              (: 'union' :)
      and $state[$p:l1] != 202) then                        (: '|' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 190) then                     (: 'union' :)
            let $state := p:shift(190, $input, $state)      (: 'union' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(202, $input, $state)      (: '|' :)
            return $state
        let $state := p:lookahead1W(31, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-IntersectExceptExpr($input, $state)
        return p:parse-UnionExpr-1($input, $state)
};

(:~
 : Parse UnionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-IntersectExceptExpr($input, $state)
  let $state := p:parse-UnionExpr-1($input, $state)
  return p:reduce($state, "UnionExpr", $count)
};

(:~
 : Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(182, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'collation' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'where' | '||' | '}' :)
    return
      if ($state[$p:l1] != 38                               (: '*' :)
      and $state[$p:l1] != 102                              (: 'div' :)
      and $state[$p:l1] != 125                              (: 'idiv' :)
      and $state[$p:l1] != 141) then                        (: 'mod' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 38) then                      (: '*' :)
            let $state := p:shift(38, $input, $state)       (: '*' :)
            return $state
          else if ($state[$p:l1] = 102) then                (: 'div' :)
            let $state := p:shift(102, $input, $state)      (: 'div' :)
            return $state
          else if ($state[$p:l1] = 125) then                (: 'idiv' :)
            let $state := p:shift(125, $input, $state)      (: 'idiv' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(141, $input, $state)      (: 'mod' :)
            return $state
        let $state := p:lookahead1W(31, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-UnionExpr($input, $state)
        return p:parse-MultiplicativeExpr-1($input, $state)
};

(:~
 : Parse MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-UnionExpr($input, $state)
  let $state := p:parse-MultiplicativeExpr-1($input, $state)
  return p:reduce($state, "MultiplicativeExpr", $count)
};

(:~
 : Parse the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(180, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'else' | 'empty' | 'end' |
                                                               'eq' | 'for' | 'ge' | 'group' | 'gt' | 'is' | 'le' |
                                                               'let' | 'lt' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'where' | '||' | '}' :)
    return
      if ($state[$p:l1] != 40                               (: '+' :)
      and $state[$p:l1] != 42) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 40) then                      (: '+' :)
            let $state := p:shift(40, $input, $state)       (: '+' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(42, $input, $state)       (: '-' :)
            return $state
        let $state := p:lookahead1W(31, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-MultiplicativeExpr($input, $state)
        return p:parse-AdditiveExpr-1($input, $state)
};

(:~
 : Parse AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-MultiplicativeExpr($input, $state)
  let $state := p:parse-AdditiveExpr-1($input, $state)
  return p:reduce($state, "AdditiveExpr", $count)
};

(:~
 : Parse RangeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-AdditiveExpr($input, $state)
  let $state := p:lookahead1W(177, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'else' | 'empty' | 'end' |
                                                               'eq' | 'for' | 'ge' | 'group' | 'gt' | 'is' | 'le' |
                                                               'let' | 'lt' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'where' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 184) then                      (: 'to' :)
      let $state := p:shift(184, $input, $state)            (: 'to' :)
      let $state := p:lookahead1W(31, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-AdditiveExpr($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "RangeExpr", $count)
};

(:~
 : Parse the 1st loop of production StringConcatExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StringConcatExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(173, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'else' | 'empty' | 'end' |
                                                               'eq' | 'for' | 'ge' | 'group' | 'gt' | 'is' | 'le' |
                                                               'let' | 'lt' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'where' |
                                                               '||' | '}' :)
    return
      if ($state[$p:l1] != 203) then                        (: '||' :)
        $state
      else
        let $state := p:shift(203, $input, $state)          (: '||' :)
        let $state := p:lookahead1W(31, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-RangeExpr($input, $state)
        return p:parse-StringConcatExpr-1($input, $state)
};

(:~
 : Parse StringConcatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StringConcatExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-RangeExpr($input, $state)
  let $state := p:parse-StringConcatExpr-1($input, $state)
  return p:reduce($state, "StringConcatExpr", $count)
};

(:~
 : Parse ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-StringConcatExpr($input, $state)
  let $state := p:lookahead1W(170, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'else' | 'empty' | 'end' |
                                                               'eq' | 'for' | 'ge' | 'group' | 'gt' | 'is' | 'le' |
                                                               'let' | 'lt' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'where' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 27                             (: '!=' :)
          or $state[$p:l1] = 53                             (: '<' :)
          or $state[$p:l1] = 57                             (: '<<' :)
          or $state[$p:l1] = 58                             (: '<=' :)
          or $state[$p:l1] = 60                             (: '=' :)
          or $state[$p:l1] = 61                             (: '>' :)
          or $state[$p:l1] = 62                             (: '>=' :)
          or $state[$p:l1] = 63                             (: '>>' :)
          or $state[$p:l1] = 111                            (: 'eq' :)
          or $state[$p:l1] = 120                            (: 'ge' :)
          or $state[$p:l1] = 124                            (: 'gt' :)
          or $state[$p:l1] = 133                            (: 'is' :)
          or $state[$p:l1] = 136                            (: 'le' :)
          or $state[$p:l1] = 139                            (: 'lt' :)
          or $state[$p:l1] = 145) then                      (: 'ne' :)
      let $state :=
        if ($state[$p:l1] = 111                             (: 'eq' :)
         or $state[$p:l1] = 120                             (: 'ge' :)
         or $state[$p:l1] = 124                             (: 'gt' :)
         or $state[$p:l1] = 136                             (: 'le' :)
         or $state[$p:l1] = 139                             (: 'lt' :)
         or $state[$p:l1] = 145) then                       (: 'ne' :)
          let $state := p:parse-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 57                         (: '<<' :)
              or $state[$p:l1] = 63                         (: '>>' :)
              or $state[$p:l1] = 133) then                  (: 'is' :)
          let $state := p:parse-NodeComp($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(31, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-StringConcatExpr($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "ComparisonExpr", $count)
};

(:~
 : Parse the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(167, $input, $state)        (: EOF | S^WS | ('(' ':') | ')' | ',' | ';' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'else' | 'empty' | 'end' |
                                                               'for' | 'group' | 'let' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'where' |
                                                               '}' :)
    return
      if ($state[$p:l1] != 74) then                         (: 'and' :)
        $state
      else
        let $state := p:shift(74, $input, $state)           (: 'and' :)
        let $state := p:lookahead1W(31, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ComparisonExpr($input, $state)
        return p:parse-AndExpr-1($input, $state)
};

(:~
 : Parse AndExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ComparisonExpr($input, $state)
  let $state := p:parse-AndExpr-1($input, $state)
  return p:reduce($state, "AndExpr", $count)
};

(:~
 : Parse the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(166, $input, $state)        (: EOF | S^WS | ('(' ':') | ')' | ',' | ';' | ']' |
                                                               'ascending' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'else' | 'empty' | 'end' |
                                                               'for' | 'group' | 'let' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'where' |
                                                               '}' :)
    return
      if ($state[$p:l1] != 153) then                        (: 'or' :)
        $state
      else
        let $state := p:shift(153, $input, $state)          (: 'or' :)
        let $state := p:lookahead1W(31, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-AndExpr($input, $state)
        return p:parse-OrExpr-1($input, $state)
};

(:~
 : Parse OrExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-AndExpr($input, $state)
  let $state := p:parse-OrExpr-1($input, $state)
  return p:reduce($state, "OrExpr", $count)
};

(:~
 : Parse IfExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(126, $input, $state)                (: 'if' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(76, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:shift(183, $input, $state)                (: 'then' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(62, $input, $state)           (: S^WS | ('(' ':') | 'else' :)
  let $state := p:shift(106, $input, $state)                (: 'else' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "IfExpr", $count)
};

(:~
 : Parse the 1st loop of production SequenceTypeUnion (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceTypeUnion-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(123, $input, $state)        (: S^WS | ('(' ':') | 'return' | '|' :)
    return
      if ($state[$p:l1] != 202) then                        (: '|' :)
        $state
      else
        let $state := p:shift(202, $input, $state)          (: '|' :)
        let $state := p:lookahead1W(31, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-SequenceType($input, $state)
        return p:parse-SequenceTypeUnion-1($input, $state)
};

(:~
 : Parse SequenceTypeUnion.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceTypeUnion($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-SequenceType($input, $state)
  let $state := p:parse-SequenceTypeUnion-1($input, $state)
  return p:reduce($state, "SequenceTypeUnion", $count)
};

(:~
 : Parse CaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(15, $input, $state)            (: 'case' :)
  let $state := p:shift(83, $input, $state)                 (: 'case' :)
  let $state := p:lookahead1W(218, $input, $state)          (: EQName^Token | S^WS | '$' | '%' | '(' | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(211, $input, $state)      (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(49, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(75, $input, $state)             (: 'as' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-SequenceTypeUnion($input, $state)
  let $state := p:lookahead1W(73, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shift(168, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "CaseClause", $count)
};

(:~
 : Parse the 1st loop of production TypeswitchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(31, $input, $state)         (: EPSILON | S^WS | ('(' ':') :)
    let $state := p:parse-CaseClause($input, $state)
    let $state := p:lookahead1W(106, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'default' :)
    return
      if ($state[$p:l1] != 83) then                         (: 'case' :)
        $state
      else
        p:parse-TypeswitchExpr-1($input, $state)
};

(:~
 : Parse TypeswitchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(189, $input, $state)                (: 'typeswitch' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-TypeswitchExpr-1($input, $state)
  let $state := p:shift(97, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(90, $input, $state)           (: S^WS | '$' | ('(' ':') | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(211, $input, $state)      (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state := p:parse-VarName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(73, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shift(168, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "TypeswitchExpr", $count)
};

(:~
 : Parse SwitchCaseOperand.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchCaseOperand($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "SwitchCaseOperand", $count)
};

(:~
 : Parse the 1st loop of production SwitchCaseClause (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchCaseClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(54, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state := p:shift(83, $input, $state)               (: 'case' :)
    let $state := p:lookahead1W(31, $input, $state)         (: EPSILON | S^WS | ('(' ':') :)
    let $state := p:parse-SwitchCaseOperand($input, $state)
    let $state := p:lookahead1W(107, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'return' :)
    return
      if ($state[$p:l1] != 83) then                         (: 'case' :)
        $state
      else
        p:parse-SwitchCaseClause-1($input, $state)
};

(:~
 : Parse SwitchCaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchCaseClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-SwitchCaseClause-1($input, $state)
  let $state := p:shift(168, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "SwitchCaseClause", $count)
};

(:~
 : Parse the 1st loop of production Expr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(148, $input, $state)        (: EOF | S^WS | ('(' ':') | ')' | ',' | ';' | ']' | '}' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(31, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-Expr-1($input, $state)
};

(:~
 : Parse Expr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-Expr-1($input, $state)
  return p:reduce($state, "Expr", $count)
};

(:~
 : Parse the 1st loop of production SwitchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(31, $input, $state)         (: EPSILON | S^WS | ('(' ':') :)
    let $state := p:parse-SwitchCaseClause($input, $state)
    let $state := p:lookahead1W(106, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'default' :)
    return
      if ($state[$p:l1] != 83) then                         (: 'case' :)
        $state
      else
        p:parse-SwitchExpr-1($input, $state)
};

(:~
 : Parse SwitchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(181, $input, $state)                (: 'switch' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-SwitchExpr-1($input, $state)
  let $state := p:shift(97, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(73, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shift(168, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "SwitchExpr", $count)
};

(:~
 : Parse the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(96, $input, $state)         (: S^WS | ('(' ':') | ',' | 'satisfies' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(39, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:shift(31, $input, $state)           (: '$' :)
        let $state := p:lookahead1W(211, $input, $state)    (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
        let $state := p:parse-VarName($input, $state)
        let $state := p:lookahead1W(102, $input, $state)    (: S^WS | ('(' ':') | 'as' | 'in' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 75) then                 (: 'as' :)
            let $state := p:parse-TypeDeclaration($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(65, $input, $state)     (: S^WS | ('(' ':') | 'in' :)
        let $state := p:shift(128, $input, $state)          (: 'in' :)
        let $state := p:lookahead1W(31, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-QuantifiedExpr-1($input, $state)
};

(:~
 : Parse QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 175) then                           (: 'some' :)
      let $state := p:shift(175, $input, $state)            (: 'some' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(112, $input, $state)            (: 'every' :)
      return $state
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(211, $input, $state)          (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(102, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(128, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-QuantifiedExpr-1($input, $state)
  let $state := p:shift(169, $input, $state)                (: 'satisfies' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "QuantifiedExpr", $count)
};

(:~
 : Parse ReturnClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReturnClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(168, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "ReturnClause", $count)
};

(:~
 : Parse CountClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CountClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(93, $input, $state)                 (: 'count' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(211, $input, $state)          (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  return p:reduce($state, "CountClause", $count)
};

(:~
 : Parse OrderModifier.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderModifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(164, $input, $state)          (: S^WS | ('(' ':') | ',' | 'ascending' | 'collation' |
                                                               'count' | 'descending' | 'empty' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76                             (: 'ascending' :)
          or $state[$p:l1] = 100) then                      (: 'descending' :)
      let $state :=
        if ($state[$p:l1] = 76) then                        (: 'ascending' :)
          let $state := p:shift(76, $input, $state)         (: 'ascending' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(100, $input, $state)        (: 'descending' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(161, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 107) then                      (: 'empty' :)
      let $state := p:shift(107, $input, $state)            (: 'empty' :)
      let $state := p:lookahead1W(115, $input, $state)      (: S^WS | ('(' ':') | 'greatest' | 'least' :)
      let $state :=
        if ($state[$p:l1] = 121) then                       (: 'greatest' :)
          let $state := p:shift(121, $input, $state)        (: 'greatest' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(137, $input, $state)        (: 'least' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(159, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 88) then                       (: 'collation' :)
      let $state := p:shift(88, $input, $state)             (: 'collation' :)
      let $state := p:lookahead1W(33, $input, $state)       (: URILiteral | S^WS | ('(' ':') :)
      let $state := p:shift(8, $input, $state)              (: URILiteral :)
      return $state
    else
      $state
  return p:reduce($state, "OrderModifier", $count)
};

(:~
 : Parse OrderSpec.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-OrderModifier($input, $state)
  return p:reduce($state, "OrderSpec", $count)
};

(:~
 : Parse the 1st loop of production OrderSpecList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(158, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(31, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-OrderSpec($input, $state)
        return p:parse-OrderSpecList-1($input, $state)
};

(:~
 : Parse OrderSpecList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-OrderSpec($input, $state)
  let $state := p:parse-OrderSpecList-1($input, $state)
  return p:reduce($state, "OrderSpecList", $count)
};

(:~
 : Parse OrderByClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderByClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 154) then                           (: 'order' :)
      let $state := p:shift(154, $input, $state)            (: 'order' :)
      let $state := p:lookahead1W(53, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:shift(82, $input, $state)             (: 'by' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(176, $input, $state)            (: 'stable' :)
      let $state := p:lookahead1W(71, $input, $state)       (: S^WS | ('(' ':') | 'order' :)
      let $state := p:shift(154, $input, $state)            (: 'order' :)
      let $state := p:lookahead1W(53, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:shift(82, $input, $state)             (: 'by' :)
      return $state
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-OrderSpecList($input, $state)
  return p:reduce($state, "OrderByClause", $count)
};

(:~
 : Parse GroupingSpec.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupingSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(7, $input, $state)             (: '$' :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(211, $input, $state)          (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(159, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 88) then                       (: 'collation' :)
      let $state := p:shift(88, $input, $state)             (: 'collation' :)
      let $state := p:lookahead1W(33, $input, $state)       (: URILiteral | S^WS | ('(' ':') :)
      let $state := p:shift(8, $input, $state)              (: URILiteral :)
      return $state
    else
      $state
  return p:reduce($state, "GroupingSpec", $count)
};

(:~
 : Parse the 1st loop of production GroupingSpecList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupingSpecList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(158, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(31, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-GroupingSpec($input, $state)
        return p:parse-GroupingSpecList-1($input, $state)
};

(:~
 : Parse GroupingSpecList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupingSpecList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-GroupingSpec($input, $state)
  let $state := p:parse-GroupingSpecList-1($input, $state)
  return p:reduce($state, "GroupingSpecList", $count)
};

(:~
 : Parse GroupByClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupByClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(122, $input, $state)                (: 'group' :)
  let $state := p:lookahead1W(53, $input, $state)           (: S^WS | ('(' ':') | 'by' :)
  let $state := p:shift(82, $input, $state)                 (: 'by' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-GroupingSpecList($input, $state)
  return p:reduce($state, "GroupByClause", $count)
};

(:~
 : Parse WhereClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WhereClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(196, $input, $state)                (: 'where' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "WhereClause", $count)
};

(:~
 : Parse IntermediateClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntermediateClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 117                                 (: 'for' :)
     or $state[$p:l1] = 138) then                           (: 'let' :)
      let $state := p:parse-InitialClause($input, $state)
      return $state
    else if ($state[$p:l1] = 196) then                      (: 'where' :)
      let $state := p:parse-WhereClause($input, $state)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'group' :)
      let $state := p:parse-GroupByClause($input, $state)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'count' :)
      let $state := p:parse-CountClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-OrderByClause($input, $state)
      return $state
  return p:reduce($state, "IntermediateClause", $count)
};

(:~
 : Parse SlidingWindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SlidingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(174, $input, $state)                (: 'sliding' :)
  let $state := p:lookahead1W(78, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:shift(197, $input, $state)                (: 'window' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(211, $input, $state)          (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(102, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(128, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-WindowStartCondition($input, $state)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-WindowEndCondition($input, $state)
  return p:reduce($state, "SlidingWindowClause", $count)
};

(:~
 : Parse WindowEndCondition.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowEndCondition($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(111, $input, $state)          (: S^WS | ('(' ':') | 'end' | 'only' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 151) then                      (: 'only' :)
      let $state := p:shift(151, $input, $state)            (: 'only' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | ('(' ':') | 'end' :)
  let $state := p:shift(110, $input, $state)                (: 'end' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-WindowVars($input, $state)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:shift(195, $input, $state)                (: 'when' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "WindowEndCondition", $count)
};

(:~
 : Parse NextItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NextItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-EQName($input, $state)
  return p:reduce($state, "NextItem", $count)
};

(:~
 : Parse PreviousItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PreviousItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-EQName($input, $state)
  return p:reduce($state, "PreviousItem", $count)
};

(:~
 : Parse CurrentItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CurrentItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-EQName($input, $state)
  return p:reduce($state, "CurrentItem", $count)
};

(:~
 : Parse WindowVars.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowVars($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(145, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(211, $input, $state)      (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state := p:parse-CurrentItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(144, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'at' :)
      let $state := p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(139, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 164) then                      (: 'previous' :)
      let $state := p:shift(164, $input, $state)            (: 'previous' :)
      let $state := p:lookahead1W(39, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(211, $input, $state)      (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state := p:parse-PreviousItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(117, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 146) then                      (: 'next' :)
      let $state := p:shift(146, $input, $state)            (: 'next' :)
      let $state := p:lookahead1W(39, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(211, $input, $state)      (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state := p:parse-NextItem($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "WindowVars", $count)
};

(:~
 : Parse WindowStartCondition.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowStartCondition($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(18, $input, $state)            (: 'start' :)
  let $state := p:shift(177, $input, $state)                (: 'start' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-WindowVars($input, $state)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:shift(195, $input, $state)                (: 'when' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "WindowStartCondition", $count)
};

(:~
 : Parse TumblingWindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TumblingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(187, $input, $state)                (: 'tumbling' :)
  let $state := p:lookahead1W(78, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:shift(197, $input, $state)                (: 'window' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(211, $input, $state)          (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(102, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(128, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-WindowStartCondition($input, $state)
  let $state := p:lookahead1W(160, $input, $state)          (: S^WS | ('(' ':') | 'count' | 'end' | 'for' | 'group' |
                                                               'let' | 'only' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 110                            (: 'end' :)
          or $state[$p:l1] = 151) then                      (: 'only' :)
      let $state := p:parse-WindowEndCondition($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "TumblingWindowClause", $count)
};

(:~
 : Parse WindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(117, $input, $state)                (: 'for' :)
  let $state := p:lookahead1W(124, $input, $state)          (: S^WS | ('(' ':') | 'sliding' | 'tumbling' :)
  let $state :=
    if ($state[$p:l1] = 187) then                           (: 'tumbling' :)
      let $state := p:parse-TumblingWindowClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-SlidingWindowClause($input, $state)
      return $state
  return p:reduce($state, "WindowClause", $count)
};

(:~
 : Parse LetBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetBinding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(7, $input, $state)             (: '$' :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(211, $input, $state)          (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(98, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shift(51, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "LetBinding", $count)
};

(:~
 : Parse the 1st loop of production LetClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(158, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(31, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-LetBinding($input, $state)
        return p:parse-LetClause-1($input, $state)
};

(:~
 : Parse LetClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(138, $input, $state)                (: 'let' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-LetBinding($input, $state)
  let $state := p:parse-LetClause-1($input, $state)
  return p:reduce($state, "LetClause", $count)
};

(:~
 : Parse PositionalVar.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PositionalVar($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(77, $input, $state)                 (: 'at' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(211, $input, $state)          (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  return p:reduce($state, "PositionalVar", $count)
};

(:~
 : Parse AllowingEmpty.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AllowingEmpty($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(71, $input, $state)                 (: 'allowing' :)
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:shift(107, $input, $state)                (: 'empty' :)
  return p:reduce($state, "AllowingEmpty", $count)
};

(:~
 : Parse TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(75, $input, $state)                 (: 'as' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-SequenceType($input, $state)
  return p:reduce($state, "TypeDeclaration", $count)
};

(:~
 : Parse VarName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-EQName($input, $state)
  return p:reduce($state, "VarName", $count)
};

(:~
 : Parse ForBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForBinding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(7, $input, $state)             (: '$' :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(211, $input, $state)          (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(143, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'as' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(134, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 71) then                       (: 'allowing' :)
      let $state := p:parse-AllowingEmpty($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(104, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'at' :)
      let $state := p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(128, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "ForBinding", $count)
};

(:~
 : Parse the 1st loop of production ForClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(158, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(31, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ForBinding($input, $state)
        return p:parse-ForClause-1($input, $state)
};

(:~
 : Parse ForClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(117, $input, $state)                (: 'for' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ForBinding($input, $state)
  let $state := p:parse-ForClause-1($input, $state)
  return p:reduce($state, "ForClause", $count)
};

(:~
 : Parse InitialClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InitialClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(28, $input, $state)            (: 'for' | 'let' :)
  let $state :=
    if ($state[$p:l1] = 117) then                           (: 'for' :)
      let $state := p:lookahead2W(129, $input, $state)      (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 8053) then                          (: 'for' '$' :)
      let $state := p:parse-ForClause($input, $state)
      return $state
    else if ($state[$p:lk] = 138) then                      (: 'let' :)
      let $state := p:parse-LetClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-WindowClause($input, $state)
      return $state
  return p:reduce($state, "InitialClause", $count)
};

(:~
 : Parse the 1st loop of production FLWORExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(156, $input, $state)        (: S^WS | ('(' ':') | 'count' | 'for' | 'group' | 'let' |
                                                               'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] = 168) then                         (: 'return' :)
        $state
      else
        let $state := p:parse-IntermediateClause($input, $state)
        return p:parse-FLWORExpr-1($input, $state)
};

(:~
 : Parse FLWORExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-InitialClause($input, $state)
  let $state := p:parse-FLWORExpr-1($input, $state)
  let $state := p:parse-ReturnClause($input, $state)
  return p:reduce($state, "FLWORExpr", $count)
};

(:~
 : Parse ExprSingle.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(223, $input, $state)          (: Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 117) then                           (: 'for' :)
      let $state := p:lookahead2W(205, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'sliding' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'tumbling' | 'union' | 'where' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 186) then                      (: 'try' :)
      let $state := p:lookahead2W(203, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 112                            (: 'let' :)
          or $state[$p:l1] = 138                            (: 'some' :)
          or $state[$p:l1] = 175) then                      (: 'some' :)
      let $state := p:lookahead2W(201, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 126                            (: 'switch' :)
          or $state[$p:l1] = 181                            (: 'typeswitch' :)
          or $state[$p:l1] = 189) then                      (: 'typeswitch' :)
      let $state := p:lookahead2W(198, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 8053                                (: 'for' '$' :)
     or $state[$p:lk] = 8074                                (: 'let' '$' :)
     or $state[$p:lk] = 44661                               (: 'for' 'sliding' :)
     or $state[$p:lk] = 47989) then                         (: 'for' 'tumbling' :)
      let $state := p:parse-FLWORExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8048                           (: 'every' '$' :)
          or $state[$p:lk] = 8111) then                     (: 'some' '$' :)
      let $state := p:parse-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8885) then                     (: 'switch' '(' :)
      let $state := p:parse-SwitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8893) then                     (: 'typeswitch' '(' :)
      let $state := p:parse-TypeswitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8830) then                     (: 'if' '(' :)
      let $state := p:parse-IfExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 51386) then                    (: 'try' '{' :)
      let $state := p:parse-TryCatchExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-OrExpr($input, $state)
      return $state
  return p:reduce($state, "ExprSingle", $count)
};

(:~
 : Parse VarValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "VarValue", $count)
};

(:~
 : Parse ParenthesizedItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParenthesizedItemType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ItemType($input, $state)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "ParenthesizedItemType", $count)
};

(:~
 : Parse AtomicOrUnionType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AtomicOrUnionType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-EQName($input, $state)
  return p:reduce($state, "AtomicOrUnionType", $count)
};

(:~
 : Parse OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 64) then                            (: '?' :)
      let $state := p:shift(64, $input, $state)             (: '?' :)
      return $state
    else if ($state[$p:l1] = 39) then                       (: '*' :)
      let $state := p:shift(39, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(40, $input, $state)             (: '+' :)
      return $state
  return p:reduce($state, "OccurrenceIndicator", $count)
};

(:~
 : Parse SequenceType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(217, $input, $state)          (: EQName^Token | S^WS | '%' | '(' | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 108) then                           (: 'empty-sequence' :)
      let $state := p:lookahead2W(200, $input, $state)      (: EOF | S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '*' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'union' | 'where' | '{' |
                                                               '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 8812) then                          (: 'empty-sequence' '(' :)
      let $state := p:shift(108, $input, $state)            (: 'empty-sequence' :)
      let $state := p:lookahead1W(40, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(34, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(41, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(37, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ItemType($input, $state)
      let $state := p:lookahead1W(196, $input, $state)      (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '*' | '+' |
                                                               ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'union' | 'where' | '{' |
                                                               '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:l1] = 39                              (: '*' :)
         or $state[$p:l1] = 40                              (: '+' :)
         or $state[$p:l1] = 64) then                        (: '?' :)
          let $state := p:parse-OccurrenceIndicator($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          $state
      return $state
  return p:reduce($state, "SequenceType", $count)
};

(:~
 : Parse the 1st loop of production TypedFunctionTest (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypedFunctionTest-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(93, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(31, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-SequenceType($input, $state)
        return p:parse-TypedFunctionTest-1($input, $state)
};

(:~
 : Parse TypedFunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypedFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(119, $input, $state)                (: 'function' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(219, $input, $state)          (: EQName^Token | S^WS | '%' | '(' | ('(' ':') | ')' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:parse-SequenceType($input, $state)
      let $state := p:parse-TypedFunctionTest-1($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | ('(' ':') | 'as' :)
  let $state := p:shift(75, $input, $state)                 (: 'as' :)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-SequenceType($input, $state)
  return p:reduce($state, "TypedFunctionTest", $count)
};

(:~
 : Parse AnyFunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(119, $input, $state)                (: 'function' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:shift(38, $input, $state)                 (: '*' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "AnyFunctionTest", $count)
};

(:~
 : Parse NumericLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 9) then                             (: IntegerLiteral :)
      let $state := p:shift(9, $input, $state)              (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 10) then                       (: DecimalLiteral :)
      let $state := p:shift(10, $input, $state)             (: DecimalLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(11, $input, $state)             (: DoubleLiteral :)
      return $state
  return p:reduce($state, "NumericLiteral", $count)
};

(:~
 : Parse Literal.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Literal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(85, $input, $state)            (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral :)
  let $state :=
    if ($state[$p:l1] = 12) then                            (: StringLiteral :)
      let $state := p:shift(12, $input, $state)             (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NumericLiteral($input, $state)
      return $state
  return p:reduce($state, "Literal", $count)
};

(:~
 : Parse the 1st loop of production Annotation (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Annotation-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(93, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(140, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
        let $state := p:parse-Literal($input, $state)
        return p:parse-Annotation-1($input, $state)
};

(:~
 : Parse Annotation.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Annotation($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 32) then                            (: '%' :)
      let $state := p:shift(32, $input, $state)             (: '%' :)
      let $state := p:lookahead1W(211, $input, $state)      (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state := p:parse-EQName($input, $state)
      let $state := p:lookahead1W(146, $input, $state)      (: S^WS | '%' | '(' | ('(' ':') | 'function' | 'private' |
                                                               'variable' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 34) then                   (: '(' :)
          let $state := p:shift(34, $input, $state)         (: '(' :)
          let $state := p:lookahead1W(140, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
          let $state := p:parse-Literal($input, $state)
          let $state := p:parse-Annotation-1($input, $state)
          let $state := p:shift(37, $input, $state)         (: ')' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(165, $input, $state)            (: 'private' :)
      return $state
  return p:reduce($state, "Annotation", $count)
};

(:~
 : Parse the 1st loop of production FunctionTest (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionTest-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(130, $input, $state)        (: S^WS | '%' | ('(' ':') | 'function' | 'private' :)
    return
      if ($state[$p:l1] = 119) then                         (: 'function' :)
        $state
      else
        let $state := p:parse-Annotation($input, $state)
        return p:parse-FunctionTest-1($input, $state)
};

(:~
 : Parse FunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-FunctionTest-1($input, $state)
  let $state :=
    if ($state[$p:l1] = 119) then                           (: 'function' :)
      let $state := p:lookahead2W(40, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state :=
        if ($state[$p:lk] = 8823) then                      (: 'function' '(' :)
          let $state := p:lookahead3W(220, $input, $state)  (: EQName^Token | S^WS | '%' | '(' | ('(' ':') | ')' | '*' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 2499191) then                       (: 'function' '(' '*' :)
      let $state := p:parse-AnyFunctionTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-TypedFunctionTest($input, $state)
      return $state
  return p:reduce($state, "FunctionTest", $count)
};

(:~
 : Parse BinaryTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BinaryTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(80, $input, $state)                 (: 'binary' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "BinaryTest", $count)
};

(:~
 : Parse AnyKindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(149, $input, $state)                (: 'node' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "AnyKindTest", $count)
};

(:~
 : Parse NamespaceNodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NamespaceNodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(144, $input, $state)                (: 'namespace-node' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "NamespaceNodeTest", $count)
};

(:~
 : Parse TextTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(182, $input, $state)                (: 'text' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "TextTest", $count)
};

(:~
 : Parse CommentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(89, $input, $state)                 (: 'comment' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "CommentTest", $count)
};

(:~
 : Parse PITest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PITest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(166, $input, $state)                (: 'processing-instruction' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(174, $input, $state)          (: StringLiteral | NCName^Token | S^WS | ('(' ':') | ')' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'try' | 'union' |
                                                               'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 12) then                        (: StringLiteral :)
          let $state := p:shift(12, $input, $state)         (: StringLiteral :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "PITest", $count)
};

(:~
 : Parse AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-AttributeName($input, $state)
  return p:reduce($state, "AttributeDeclaration", $count)
};

(:~
 : Parse SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(171, $input, $state)                (: 'schema-attribute' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(211, $input, $state)          (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "SchemaAttributeTest", $count)
};

(:~
 : Parse AttributeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-EQName($input, $state)
  return p:reduce($state, "AttributeName", $count)
};

(:~
 : Parse AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 38) then                            (: '*' :)
      let $state := p:shift(38, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AttributeName($input, $state)
      return $state
  return p:reduce($state, "AttribNameOrWildcard", $count)
};

(:~
 : Parse AttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(78, $input, $state)                 (: 'attribute' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(216, $input, $state)          (: EQName^Token | S^WS | ('(' ':') | ')' | '*' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:parse-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(93, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 41) then                   (: ',' :)
          let $state := p:shift(41, $input, $state)         (: ',' :)
          let $state := p:lookahead1W(211, $input, $state)  (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
          let $state := p:parse-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "AttributeTest", $count)
};

(:~
 : Parse ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ElementName($input, $state)
  return p:reduce($state, "ElementDeclaration", $count)
};

(:~
 : Parse SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(172, $input, $state)                (: 'schema-element' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(211, $input, $state)          (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "SchemaElementTest", $count)
};

(:~
 : Parse TypeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-EQName($input, $state)
  return p:reduce($state, "TypeName", $count)
};

(:~
 : Parse ElementName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-EQName($input, $state)
  return p:reduce($state, "ElementName", $count)
};

(:~
 : Parse ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 38) then                            (: '*' :)
      let $state := p:shift(38, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ElementName($input, $state)
      return $state
  return p:reduce($state, "ElementNameOrWildcard", $count)
};

(:~
 : Parse ElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(105, $input, $state)                (: 'element' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(216, $input, $state)          (: EQName^Token | S^WS | ('(' ':') | ')' | '*' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:parse-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(93, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 41) then                   (: ',' :)
          let $state := p:shift(41, $input, $state)         (: ',' :)
          let $state := p:lookahead1W(211, $input, $state)  (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
          let $state := p:parse-TypeName($input, $state)
          let $state := p:lookahead1W(94, $input, $state)   (: S^WS | ('(' ':') | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 64) then               (: '?' :)
              let $state := p:shift(64, $input, $state)     (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "ElementTest", $count)
};

(:~
 : Parse DocumentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(104, $input, $state)                (: 'document-node' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(132, $input, $state)          (: S^WS | ('(' ':') | ')' | 'element' | 'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 105) then                       (: 'element' :)
          let $state := p:parse-ElementTest($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "DocumentTest", $count)
};

(:~
 : Parse KindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 104) then                           (: 'document-node' :)
      let $state := p:parse-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'element' :)
      let $state := p:parse-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'attribute' :)
      let $state := p:parse-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 172) then                      (: 'schema-element' :)
      let $state := p:parse-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'schema-attribute' :)
      let $state := p:parse-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'processing-instruction' :)
      let $state := p:parse-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'comment' :)
      let $state := p:parse-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 182) then                      (: 'text' :)
      let $state := p:parse-TextTest($input, $state)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'namespace-node' :)
      let $state := p:parse-NamespaceNodeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'node' :)
      let $state := p:parse-AnyKindTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-BinaryTest($input, $state)
      return $state
  return p:reduce($state, "KindTest", $count)
};

(:~
 : Parse ItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(217, $input, $state)          (: EQName^Token | S^WS | '%' | '(' | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 78                                  (: 'binary' :)
     or $state[$p:l1] = 80                                  (: 'comment' :)
     or $state[$p:l1] = 89                                  (: 'document-node' :)
     or $state[$p:l1] = 104                                 (: 'element' :)
     or $state[$p:l1] = 105                                 (: 'function' :)
     or $state[$p:l1] = 119                                 (: 'item' :)
     or $state[$p:l1] = 134                                 (: 'namespace-node' :)
     or $state[$p:l1] = 144                                 (: 'node' :)
     or $state[$p:l1] = 149                                 (: 'processing-instruction' :)
     or $state[$p:l1] = 166                                 (: 'schema-attribute' :)
     or $state[$p:l1] = 171                                 (: 'schema-element' :)
     or $state[$p:l1] = 172                                 (: 'text' :)
     or $state[$p:l1] = 182) then                           (: 'text' :)
      let $state := p:lookahead2W(200, $input, $state)      (: EOF | S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '*' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'union' | 'where' | '{' |
                                                               '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 8782                                (: 'attribute' '(' :)
     or $state[$p:lk] = 8784                                (: 'binary' '(' :)
     or $state[$p:lk] = 8793                                (: 'comment' '(' :)
     or $state[$p:lk] = 8808                                (: 'document-node' '(' :)
     or $state[$p:lk] = 8809                                (: 'element' '(' :)
     or $state[$p:lk] = 8848                                (: 'namespace-node' '(' :)
     or $state[$p:lk] = 8853                                (: 'node' '(' :)
     or $state[$p:lk] = 8870                                (: 'processing-instruction' '(' :)
     or $state[$p:lk] = 8875                                (: 'schema-attribute' '(' :)
     or $state[$p:lk] = 8876                                (: 'schema-element' '(' :)
     or $state[$p:lk] = 8886) then                          (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 8838) then                     (: 'item' '(' :)
      let $state := p:shift(134, $input, $state)            (: 'item' :)
      let $state := p:lookahead1W(40, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(34, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(41, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(37, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:lk] = 32                             (: '%' :)
          or $state[$p:lk] = 165                            (: 'private' :)
          or $state[$p:lk] = 8823) then                     (: 'function' '(' :)
      let $state := p:parse-FunctionTest($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(' :)
      let $state := p:parse-ParenthesizedItemType($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AtomicOrUnionType($input, $state)
      return $state
  return p:reduce($state, "ItemType", $count)
};

(:~
 : Parse ContextItemDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContextItemDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | 'context' :)
  let $state := p:shift(91, $input, $state)                 (: 'context' :)
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | ('(' ':') | 'item' :)
  let $state := p:shift(134, $input, $state)                (: 'item' :)
  let $state := p:lookahead1W(133, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'as' :)
      let $state := p:shift(75, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(31, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-ItemType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(99, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:l1] = 51) then                            (: ':=' :)
      let $state := p:shift(51, $input, $state)             (: ':=' :)
      let $state := p:lookahead1W(31, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-VarValue($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(114, $input, $state)            (: 'external' :)
      let $state := p:lookahead1W(97, $input, $state)       (: S^WS | ('(' ':') | ':=' | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 51) then                   (: ':=' :)
          let $state := p:shift(51, $input, $state)         (: ':=' :)
          let $state := p:lookahead1W(31, $input, $state)   (: EPSILON | S^WS | ('(' ':') :)
          let $state := p:parse-VarDefaultValue($input, $state)
          return $state
        else
          $state
      return $state
  return p:reduce($state, "ContextItemDecl", $count)
};

(:~
 : Parse ImportStylesheetDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ImportStylesheetDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(127, $input, $state)                (: 'import' :)
  let $state := p:lookahead1W(75, $input, $state)           (: S^WS | ('(' ':') | 'stylesheet' :)
  let $state := p:shift(180, $input, $state)                (: 'stylesheet' :)
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'at' :)
  let $state := p:shift(77, $input, $state)                 (: 'at' :)
  let $state := p:lookahead1W(35, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:shift(12, $input, $state)                 (: StringLiteral :)
  return p:reduce($state, "ImportStylesheetDecl", $count)
};

(:~
 : Parse the 1st loop of production ModuleImport (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleImport-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(95, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(33, $input, $state)     (: URILiteral | S^WS | ('(' ':') :)
        let $state := p:shift(8, $input, $state)            (: URILiteral :)
        return p:parse-ModuleImport-1($input, $state)
};

(:~
 : Parse ModuleImport.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleImport($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(127, $input, $state)                (: 'import' :)
  let $state := p:lookahead1W(67, $input, $state)           (: S^WS | ('(' ':') | 'module' :)
  let $state := p:shift(142, $input, $state)                (: 'module' :)
  let $state := p:lookahead1W(83, $input, $state)           (: URILiteral | S^WS | ('(' ':') | 'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 143) then                      (: 'namespace' :)
      let $state := p:shift(143, $input, $state)            (: 'namespace' :)
      let $state := p:lookahead1W(169, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' :)
      let $state := p:parse-NCName($input, $state)
      let $state := p:lookahead1W(47, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:shift(60, $input, $state)             (: '=' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(33, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'at' :)
      let $state := p:shift(77, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(33, $input, $state)       (: URILiteral | S^WS | ('(' ':') :)
      let $state := p:shift(8, $input, $state)              (: URILiteral :)
      let $state := p:parse-ModuleImport-1($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "ModuleImport", $count)
};

(:~
 : Parse SchemaPrefix.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaPrefix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 143) then                           (: 'namespace' :)
      let $state := p:shift(143, $input, $state)            (: 'namespace' :)
      let $state := p:lookahead1W(169, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' :)
      let $state := p:parse-NCName($input, $state)
      let $state := p:lookahead1W(47, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:shift(60, $input, $state)             (: '=' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(97, $input, $state)             (: 'default' :)
      let $state := p:lookahead1W(61, $input, $state)       (: S^WS | ('(' ':') | 'element' :)
      let $state := p:shift(105, $input, $state)            (: 'element' :)
      let $state := p:lookahead1W(68, $input, $state)       (: S^WS | ('(' ':') | 'namespace' :)
      let $state := p:shift(143, $input, $state)            (: 'namespace' :)
      return $state
  return p:reduce($state, "SchemaPrefix", $count)
};

(:~
 : Parse the 1st loop of production SchemaImport (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaImport-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(95, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(33, $input, $state)     (: URILiteral | S^WS | ('(' ':') :)
        let $state := p:shift(8, $input, $state)            (: URILiteral :)
        return p:parse-SchemaImport-1($input, $state)
};

(:~
 : Parse SchemaImport.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaImport($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(127, $input, $state)                (: 'import' :)
  let $state := p:lookahead1W(74, $input, $state)           (: S^WS | ('(' ':') | 'schema' :)
  let $state := p:shift(170, $input, $state)                (: 'schema' :)
  let $state := p:lookahead1W(126, $input, $state)          (: URILiteral | S^WS | ('(' ':') | 'default' | 'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 8) then                       (: URILiteral :)
      let $state := p:parse-SchemaPrefix($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(33, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'at' :)
      let $state := p:shift(77, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(33, $input, $state)       (: URILiteral | S^WS | ('(' ':') :)
      let $state := p:shift(8, $input, $state)              (: URILiteral :)
      let $state := p:parse-SchemaImport-1($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "SchemaImport", $count)
};

(:~
 : Parse Import.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Import($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 127) then                           (: 'import' :)
      let $state := p:lookahead2W(138, $input, $state)      (: S^WS | ('(' ':') | 'module' | 'schema' | 'stylesheet' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 43647) then                         (: 'import' 'schema' :)
      let $state := p:parse-SchemaImport($input, $state)
      return $state
    else if ($state[$p:lk] = 36479) then                    (: 'import' 'module' :)
      let $state := p:parse-ModuleImport($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ImportStylesheetDecl($input, $state)
      return $state
  return p:reduce($state, "Import", $count)
};

(:~
 : Parse NamespaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(68, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:shift(143, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(169, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' :)
  let $state := p:parse-NCName($input, $state)
  let $state := p:lookahead1W(47, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:shift(60, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(33, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  return p:reduce($state, "NamespaceDecl", $count)
};

(:~
 : Parse DFPropertyName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DFPropertyName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 95) then                            (: 'decimal-separator' :)
      let $state := p:shift(95, $input, $state)             (: 'decimal-separator' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'grouping-separator' :)
      let $state := p:shift(123, $input, $state)            (: 'grouping-separator' :)
      return $state
    else if ($state[$p:l1] = 129) then                      (: 'infinity' :)
      let $state := p:shift(129, $input, $state)            (: 'infinity' :)
      return $state
    else if ($state[$p:l1] = 140) then                      (: 'minus-sign' :)
      let $state := p:shift(140, $input, $state)            (: 'minus-sign' :)
      return $state
    else if ($state[$p:l1] = 67) then                       (: 'NaN' :)
      let $state := p:shift(67, $input, $state)             (: 'NaN' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'percent' :)
      let $state := p:shift(160, $input, $state)            (: 'percent' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'per-mille' :)
      let $state := p:shift(159, $input, $state)            (: 'per-mille' :)
      return $state
    else if ($state[$p:l1] = 199) then                      (: 'zero-digit' :)
      let $state := p:shift(199, $input, $state)            (: 'zero-digit' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'digit' :)
      let $state := p:shift(101, $input, $state)            (: 'digit' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(158, $input, $state)            (: 'pattern-separator' :)
      return $state
  return p:reduce($state, "DFPropertyName", $count)
};

(:~
 : Parse FunctionName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(197, $input, $state)           (: EQName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'ne' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'property' | 'return' |
                                                               'satisfies' | 'self' | 'some' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'try' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 7) then                             (: EQName^Token :)
      let $state := p:shift(7, $input, $state)              (: EQName^Token :)
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'ancestor' :)
      let $state := p:shift(72, $input, $state)             (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'ancestor-or-self' :)
      let $state := p:shift(73, $input, $state)             (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 74) then                       (: 'and' :)
      let $state := p:shift(74, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'ascending' :)
      let $state := p:shift(76, $input, $state)             (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'case' :)
      let $state := p:shift(83, $input, $state)             (: 'case' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'cast' :)
      let $state := p:shift(84, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'castable' :)
      let $state := p:shift(85, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'catch' :)
      let $state := p:shift(86, $input, $state)             (: 'catch' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'child' :)
      let $state := p:shift(87, $input, $state)             (: 'child' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'collation' :)
      let $state := p:shift(88, $input, $state)             (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'count' :)
      let $state := p:shift(93, $input, $state)             (: 'count' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'declare' :)
      let $state := p:shift(96, $input, $state)             (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'default' :)
      let $state := p:shift(97, $input, $state)             (: 'default' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'descendant' :)
      let $state := p:shift(98, $input, $state)             (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'descendant-or-self' :)
      let $state := p:shift(99, $input, $state)             (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'descending' :)
      let $state := p:shift(100, $input, $state)            (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'div' :)
      let $state := p:shift(102, $input, $state)            (: 'div' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'document' :)
      let $state := p:shift(103, $input, $state)            (: 'document' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'else' :)
      let $state := p:shift(106, $input, $state)            (: 'else' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'empty' :)
      let $state := p:shift(107, $input, $state)            (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'end' :)
      let $state := p:shift(110, $input, $state)            (: 'end' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'eq' :)
      let $state := p:shift(111, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'every' :)
      let $state := p:shift(112, $input, $state)            (: 'every' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'except' :)
      let $state := p:shift(113, $input, $state)            (: 'except' :)
      return $state
    else if ($state[$p:l1] = 115) then                      (: 'following' :)
      let $state := p:shift(115, $input, $state)            (: 'following' :)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'following-sibling' :)
      let $state := p:shift(116, $input, $state)            (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'for' :)
      let $state := p:shift(117, $input, $state)            (: 'for' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'ge' :)
      let $state := p:shift(120, $input, $state)            (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'group' :)
      let $state := p:shift(122, $input, $state)            (: 'group' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'gt' :)
      let $state := p:shift(124, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'idiv' :)
      let $state := p:shift(125, $input, $state)            (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'import' :)
      let $state := p:shift(127, $input, $state)            (: 'import' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'instance' :)
      let $state := p:shift(131, $input, $state)            (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 132) then                      (: 'intersect' :)
      let $state := p:shift(132, $input, $state)            (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 133) then                      (: 'is' :)
      let $state := p:shift(133, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'le' :)
      let $state := p:shift(136, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'let' :)
      let $state := p:shift(138, $input, $state)            (: 'let' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'lt' :)
      let $state := p:shift(139, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 141) then                      (: 'mod' :)
      let $state := p:shift(141, $input, $state)            (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'module' :)
      let $state := p:shift(142, $input, $state)            (: 'module' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'namespace' :)
      let $state := p:shift(143, $input, $state)            (: 'namespace' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'ne' :)
      let $state := p:shift(145, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'only' :)
      let $state := p:shift(151, $input, $state)            (: 'only' :)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'or' :)
      let $state := p:shift(153, $input, $state)            (: 'or' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'order' :)
      let $state := p:shift(154, $input, $state)            (: 'order' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'ordered' :)
      let $state := p:shift(155, $input, $state)            (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 157) then                      (: 'parent' :)
      let $state := p:shift(157, $input, $state)            (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 161) then                      (: 'preceding' :)
      let $state := p:shift(161, $input, $state)            (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'preceding-sibling' :)
      let $state := p:shift(162, $input, $state)            (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'property' :)
      let $state := p:shift(167, $input, $state)            (: 'property' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'return' :)
      let $state := p:shift(168, $input, $state)            (: 'return' :)
      return $state
    else if ($state[$p:l1] = 169) then                      (: 'satisfies' :)
      let $state := p:shift(169, $input, $state)            (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'self' :)
      let $state := p:shift(173, $input, $state)            (: 'self' :)
      return $state
    else if ($state[$p:l1] = 175) then                      (: 'some' :)
      let $state := p:shift(175, $input, $state)            (: 'some' :)
      return $state
    else if ($state[$p:l1] = 176) then                      (: 'stable' :)
      let $state := p:shift(176, $input, $state)            (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 177) then                      (: 'start' :)
      let $state := p:shift(177, $input, $state)            (: 'start' :)
      return $state
    else if ($state[$p:l1] = 184) then                      (: 'to' :)
      let $state := p:shift(184, $input, $state)            (: 'to' :)
      return $state
    else if ($state[$p:l1] = 185) then                      (: 'treat' :)
      let $state := p:shift(185, $input, $state)            (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 186) then                      (: 'try' :)
      let $state := p:shift(186, $input, $state)            (: 'try' :)
      return $state
    else if ($state[$p:l1] = 190) then                      (: 'union' :)
      let $state := p:shift(190, $input, $state)            (: 'union' :)
      return $state
    else if ($state[$p:l1] = 191) then                      (: 'unordered' :)
      let $state := p:shift(191, $input, $state)            (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 192) then                      (: 'validate' :)
      let $state := p:shift(192, $input, $state)            (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 196) then                      (: 'where' :)
      let $state := p:shift(196, $input, $state)            (: 'where' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(198, $input, $state)            (: 'xquery' :)
      return $state
  return p:reduce($state, "FunctionName", $count)
};

(:~
 : Parse EQName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EQName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(208, $input, $state)           (: EQName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 78) then                            (: 'attribute' :)
      let $state := p:shift(78, $input, $state)             (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'binary' :)
      let $state := p:shift(80, $input, $state)             (: 'binary' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'comment' :)
      let $state := p:shift(89, $input, $state)             (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'document-node' :)
      let $state := p:shift(104, $input, $state)            (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'element' :)
      let $state := p:shift(105, $input, $state)            (: 'element' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'empty-sequence' :)
      let $state := p:shift(108, $input, $state)            (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'function' :)
      let $state := p:shift(119, $input, $state)            (: 'function' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'if' :)
      let $state := p:shift(126, $input, $state)            (: 'if' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'item' :)
      let $state := p:shift(134, $input, $state)            (: 'item' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'namespace-node' :)
      let $state := p:shift(144, $input, $state)            (: 'namespace-node' :)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'node' :)
      let $state := p:shift(149, $input, $state)            (: 'node' :)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'processing-instruction' :)
      let $state := p:shift(166, $input, $state)            (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'schema-attribute' :)
      let $state := p:shift(171, $input, $state)            (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 172) then                      (: 'schema-element' :)
      let $state := p:shift(172, $input, $state)            (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 181) then                      (: 'switch' :)
      let $state := p:shift(181, $input, $state)            (: 'switch' :)
      return $state
    else if ($state[$p:l1] = 182) then                      (: 'text' :)
      let $state := p:shift(182, $input, $state)            (: 'text' :)
      return $state
    else if ($state[$p:l1] = 189) then                      (: 'typeswitch' :)
      let $state := p:shift(189, $input, $state)            (: 'typeswitch' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionName($input, $state)
      return $state
  return p:reduce($state, "EQName", $count)
};

(:~
 : Parse the 1st loop of production DecimalFormatDecl (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DecimalFormatDecl-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(162, $input, $state)        (: S^WS | ('(' ':') | ';' | 'NaN' | 'decimal-separator' |
                                                               'digit' | 'grouping-separator' | 'infinity' |
                                                               'minus-sign' | 'pattern-separator' | 'per-mille' |
                                                               'percent' | 'zero-digit' :)
    return
      if ($state[$p:l1] = 52) then                          (: ';' :)
        $state
      else
        let $state := p:parse-DFPropertyName($input, $state)
        let $state := p:lookahead1W(47, $input, $state)     (: S^WS | ('(' ':') | '=' :)
        let $state := p:shift(60, $input, $state)           (: '=' :)
        let $state := p:lookahead1W(35, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:shift(12, $input, $state)           (: StringLiteral :)
        return p:parse-DecimalFormatDecl-1($input, $state)
};

(:~
 : Parse DecimalFormatDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DecimalFormatDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(108, $input, $state)          (: S^WS | ('(' ':') | 'decimal-format' | 'default' :)
  let $state :=
    if ($state[$p:l1] = 94) then                            (: 'decimal-format' :)
      let $state := p:shift(94, $input, $state)             (: 'decimal-format' :)
      let $state := p:lookahead1W(211, $input, $state)      (: EQName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
      let $state := p:parse-EQName($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(97, $input, $state)             (: 'default' :)
      let $state := p:lookahead1W(59, $input, $state)       (: S^WS | ('(' ':') | 'decimal-format' :)
      let $state := p:shift(94, $input, $state)             (: 'decimal-format' :)
      return $state
  let $state := p:parse-DecimalFormatDecl-1($input, $state)
  return p:reduce($state, "DecimalFormatDecl", $count)
};

(:~
 : Parse InheritMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InheritMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(29, $input, $state)            (: 'inherit' | 'no-inherit' :)
  let $state :=
    if ($state[$p:l1] = 130) then                           (: 'inherit' :)
      let $state := p:shift(130, $input, $state)            (: 'inherit' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(147, $input, $state)            (: 'no-inherit' :)
      return $state
  return p:reduce($state, "InheritMode", $count)
};

(:~
 : Parse PreserveMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PreserveMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(30, $input, $state)            (: 'no-preserve' | 'preserve' :)
  let $state :=
    if ($state[$p:l1] = 163) then                           (: 'preserve' :)
      let $state := p:shift(163, $input, $state)            (: 'preserve' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(148, $input, $state)            (: 'no-preserve' :)
      return $state
  return p:reduce($state, "PreserveMode", $count)
};

(:~
 : Parse CopyNamespacesDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CopyNamespacesDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | ('(' ':') | 'copy-namespaces' :)
  let $state := p:shift(92, $input, $state)                 (: 'copy-namespaces' :)
  let $state := p:lookahead1W(118, $input, $state)          (: S^WS | ('(' ':') | 'no-preserve' | 'preserve' :)
  let $state := p:parse-PreserveMode($input, $state)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | ('(' ':') | ',' :)
  let $state := p:shift(41, $input, $state)                 (: ',' :)
  let $state := p:lookahead1W(116, $input, $state)          (: S^WS | ('(' ':') | 'inherit' | 'no-inherit' :)
  let $state := p:parse-InheritMode($input, $state)
  return p:reduce($state, "CopyNamespacesDecl", $count)
};

(:~
 : Parse EmptyOrderDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EmptyOrderDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:shift(97, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(71, $input, $state)           (: S^WS | ('(' ':') | 'order' :)
  let $state := p:shift(154, $input, $state)                (: 'order' :)
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:shift(107, $input, $state)                (: 'empty' :)
  let $state := p:lookahead1W(115, $input, $state)          (: S^WS | ('(' ':') | 'greatest' | 'least' :)
  let $state :=
    if ($state[$p:l1] = 121) then                           (: 'greatest' :)
      let $state := p:shift(121, $input, $state)            (: 'greatest' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(137, $input, $state)            (: 'least' :)
      return $state
  return p:reduce($state, "EmptyOrderDecl", $count)
};

(:~
 : Parse OrderingModeDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderingModeDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(72, $input, $state)           (: S^WS | ('(' ':') | 'ordering' :)
  let $state := p:shift(156, $input, $state)                (: 'ordering' :)
  let $state := p:lookahead1W(121, $input, $state)          (: S^WS | ('(' ':') | 'ordered' | 'unordered' :)
  let $state :=
    if ($state[$p:l1] = 155) then                           (: 'ordered' :)
      let $state := p:shift(155, $input, $state)            (: 'ordered' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(191, $input, $state)            (: 'unordered' :)
      return $state
  return p:reduce($state, "OrderingModeDecl", $count)
};

(:~
 : Parse ConstructionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ConstructionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(56, $input, $state)           (: S^WS | ('(' ':') | 'construction' :)
  let $state := p:shift(90, $input, $state)                 (: 'construction' :)
  let $state := p:lookahead1W(122, $input, $state)          (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:l1] = 179) then                           (: 'strip' :)
      let $state := p:shift(179, $input, $state)            (: 'strip' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(163, $input, $state)            (: 'preserve' :)
      return $state
  return p:reduce($state, "ConstructionDecl", $count)
};

(:~
 : Parse BaseURIDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BaseURIDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(51, $input, $state)           (: S^WS | ('(' ':') | 'base-uri' :)
  let $state := p:shift(79, $input, $state)                 (: 'base-uri' :)
  let $state := p:lookahead1W(33, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  return p:reduce($state, "BaseURIDecl", $count)
};

(:~
 : Parse DefaultCollationDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DefaultCollationDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:shift(97, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(55, $input, $state)           (: S^WS | ('(' ':') | 'collation' :)
  let $state := p:shift(88, $input, $state)                 (: 'collation' :)
  let $state := p:lookahead1W(33, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  return p:reduce($state, "DefaultCollationDecl", $count)
};

(:~
 : Parse BoundarySpaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BoundarySpaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'boundary-space' :)
  let $state := p:shift(81, $input, $state)                 (: 'boundary-space' :)
  let $state := p:lookahead1W(122, $input, $state)          (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:l1] = 163) then                           (: 'preserve' :)
      let $state := p:shift(163, $input, $state)            (: 'preserve' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(179, $input, $state)            (: 'strip' :)
      return $state
  return p:reduce($state, "BoundarySpaceDecl", $count)
};

(:~
 : Parse Setter.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Setter($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 96) then                            (: 'declare' :)
      let $state := p:lookahead2W(154, $input, $state)      (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                               'construction' | 'copy-namespaces' | 'decimal-format' |
                                                               'default' | 'ordering' :)
      let $state :=
        if ($state[$p:lk] = 24928) then                     (: 'declare' 'default' :)
          let $state := p:lookahead3W(136, $input, $state)  (: S^WS | ('(' ':') | 'collation' | 'decimal-format' |
                                                               'order' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 20832) then                         (: 'declare' 'boundary-space' :)
      let $state := p:parse-BoundarySpaceDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 5792096) then                  (: 'declare' 'default' 'collation' :)
      let $state := p:parse-DefaultCollationDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 20320) then                    (: 'declare' 'base-uri' :)
      let $state := p:parse-BaseURIDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 23136) then                    (: 'declare' 'construction' :)
      let $state := p:parse-ConstructionDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 40032) then                    (: 'declare' 'ordering' :)
      let $state := p:parse-OrderingModeDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 10117472) then                 (: 'declare' 'default' 'order' :)
      let $state := p:parse-EmptyOrderDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 23648) then                    (: 'declare' 'copy-namespaces' :)
      let $state := p:parse-CopyNamespacesDecl($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-DecimalFormatDecl($input, $state)
      return $state
  return p:reduce($state, "Setter", $count)
};

(:~
 : Parse DefaultNamespaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DefaultNamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:shift(97, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(109, $input, $state)          (: S^WS | ('(' ':') | 'element' | 'function' :)
  let $state :=
    if ($state[$p:l1] = 105) then                           (: 'element' :)
      let $state := p:shift(105, $input, $state)            (: 'element' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(119, $input, $state)            (: 'function' :)
      return $state
  let $state := p:lookahead1W(68, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:shift(143, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(33, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  return p:reduce($state, "DefaultNamespaceDecl", $count)
};

(:~
 : Parse the 1st loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(224, $input, $state)        (: EOF | Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] = 96) then                          (: 'declare' :)
        let $state := p:lookahead2W(186, $input, $state)    (: EOF | S^WS | '!' | '!=' | '#' | '%' | '(' | ('(' ':') |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | 'and' |
                                                               'base-uri' | 'boundary-space' | 'cast' | 'castable' |
                                                               'construction' | 'context' | 'copy-namespaces' |
                                                               'decimal-format' | 'default' | 'div' | 'eq' | 'except' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'namespace' |
                                                               'ne' | 'option' | 'or' | 'ordering' | 'private' | 'to' |
                                                               'treat' | 'union' | 'variable' | '|' | '||' :)
        return $state
      else if ($state[$p:l1] = 127) then                    (: 'import' :)
        let $state := p:lookahead2W(179, $input, $state)    (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'div' | 'eq' | 'except' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'lt' |
                                                               'mod' | 'module' | 'ne' | 'or' | 'schema' |
                                                               'stylesheet' | 'to' | 'treat' | 'union' | '|' | '||' :)
        return $state
      else
        ($state[$p:l1], $state[position() > $p:lk])
    return
      if ($state[$p:lk] != 20320                            (: 'declare' 'base-uri' :)
      and $state[$p:lk] != 20832                            (: 'declare' 'boundary-space' :)
      and $state[$p:lk] != 23136                            (: 'declare' 'construction' :)
      and $state[$p:lk] != 23648                            (: 'declare' 'copy-namespaces' :)
      and $state[$p:lk] != 24160                            (: 'declare' 'decimal-format' :)
      and $state[$p:lk] != 24928                            (: 'declare' 'default' :)
      and $state[$p:lk] != 36479                            (: 'import' 'module' :)
      and $state[$p:lk] != 36704                            (: 'declare' 'namespace' :)
      and $state[$p:lk] != 40032                            (: 'declare' 'ordering' :)
      and $state[$p:lk] != 43647                            (: 'import' 'schema' :)
      and $state[$p:lk] != 46207) then                      (: 'import' 'stylesheet' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 96) then                      (: 'declare' :)
            let $state := p:lookahead2W(155, $input, $state) (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                                'construction' | 'copy-namespaces' | 'decimal-format' |
                                                                'default' | 'namespace' | 'ordering' :)
            let $state :=
              if ($state[$p:lk] = 24928) then               (: 'declare' 'default' :)
                let $state := p:lookahead3W(147, $input, $state) (: S^WS | ('(' ':') | 'collation' | 'decimal-format' |
                                                                    'element' | 'function' | 'order' :)
                return $state
              else
                $state
            return $state
          else
            ($state[$p:l1], $state[position() > $p:lk])
        let $state :=
          if ($state[$p:lk] = 6906208                       (: 'declare' 'default' 'element' :)
           or $state[$p:lk] = 7823712) then                 (: 'declare' 'default' 'function' :)
            let $state := p:parse-DefaultNamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 36704) then              (: 'declare' 'namespace' :)
            let $state := p:parse-NamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 127) then                (: 'import' :)
            let $state := p:parse-Import($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-Setter($input, $state)
            return $state
        let $state := p:lookahead1W(46, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state := p:parse-Separator($input, $state)
        return p:parse-Prolog-1($input, $state)
};

(:~
 : Parse the 2nd loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(224, $input, $state)        (: EOF | Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] = 96) then                          (: 'declare' :)
        let $state := p:lookahead2W(181, $input, $state)    (: EOF | S^WS | '!' | '!=' | '#' | '%' | '(' | ('(' ':') |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'context' | 'div' | 'eq' | 'except' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' |
                                                               'option' | 'or' | 'private' | 'to' | 'treat' | 'union' |
                                                               'variable' | '|' | '||' :)
        return $state
      else
        ($state[$p:l1], $state[position() > $p:lk])
    return
      if ($state[$p:lk] != 8288                             (: 'declare' '%' :)
      and $state[$p:lk] != 23392                            (: 'declare' 'context' :)
      and $state[$p:lk] != 30560                            (: 'declare' 'function' :)
      and $state[$p:lk] != 39008                            (: 'declare' 'option' :)
      and $state[$p:lk] != 42336                            (: 'declare' 'private' :)
      and $state[$p:lk] != 49504) then                      (: 'declare' 'variable' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 96) then                      (: 'declare' :)
            let $state := p:lookahead2W(152, $input, $state) (: S^WS | '%' | ('(' ':') | 'context' | 'function' |
                                                                'option' | 'private' | 'variable' :)
            return $state
          else
            ($state[$p:l1], $state[position() > $p:lk])
        let $state :=
          if ($state[$p:lk] = 23392) then                   (: 'declare' 'context' :)
            let $state := p:parse-ContextItemDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 39008) then              (: 'declare' 'option' :)
            let $state := p:parse-OptionDecl($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-AnnotatedDecl($input, $state)
            return $state
        let $state := p:lookahead1W(46, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state := p:parse-Separator($input, $state)
        return p:parse-Prolog-2($input, $state)
};

(:~
 : Parse Prolog.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Prolog-1($input, $state)
  let $state := p:parse-Prolog-2($input, $state)
  return p:reduce($state, "Prolog", $count)
};

(:~
 : Parse NCName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NCName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(168, $input, $state)           (: NCName^Token | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'try' | 'union' | 'where' :)
  let $state :=
    if ($state[$p:l1] = 21) then                            (: NCName^Token :)
      let $state := p:shift(21, $input, $state)             (: NCName^Token :)
      return $state
    else if ($state[$p:l1] = 74) then                       (: 'and' :)
      let $state := p:shift(74, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'ascending' :)
      let $state := p:shift(76, $input, $state)             (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'case' :)
      let $state := p:shift(83, $input, $state)             (: 'case' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'cast' :)
      let $state := p:shift(84, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'castable' :)
      let $state := p:shift(85, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'collation' :)
      let $state := p:shift(88, $input, $state)             (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'count' :)
      let $state := p:shift(93, $input, $state)             (: 'count' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'default' :)
      let $state := p:shift(97, $input, $state)             (: 'default' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'descending' :)
      let $state := p:shift(100, $input, $state)            (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'div' :)
      let $state := p:shift(102, $input, $state)            (: 'div' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'else' :)
      let $state := p:shift(106, $input, $state)            (: 'else' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'empty' :)
      let $state := p:shift(107, $input, $state)            (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'end' :)
      let $state := p:shift(110, $input, $state)            (: 'end' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'eq' :)
      let $state := p:shift(111, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'except' :)
      let $state := p:shift(113, $input, $state)            (: 'except' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'for' :)
      let $state := p:shift(117, $input, $state)            (: 'for' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'ge' :)
      let $state := p:shift(120, $input, $state)            (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'group' :)
      let $state := p:shift(122, $input, $state)            (: 'group' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'gt' :)
      let $state := p:shift(124, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'idiv' :)
      let $state := p:shift(125, $input, $state)            (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'instance' :)
      let $state := p:shift(131, $input, $state)            (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 132) then                      (: 'intersect' :)
      let $state := p:shift(132, $input, $state)            (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 133) then                      (: 'is' :)
      let $state := p:shift(133, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'le' :)
      let $state := p:shift(136, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'let' :)
      let $state := p:shift(138, $input, $state)            (: 'let' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'lt' :)
      let $state := p:shift(139, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 141) then                      (: 'mod' :)
      let $state := p:shift(141, $input, $state)            (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'ne' :)
      let $state := p:shift(145, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'only' :)
      let $state := p:shift(151, $input, $state)            (: 'only' :)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'or' :)
      let $state := p:shift(153, $input, $state)            (: 'or' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'order' :)
      let $state := p:shift(154, $input, $state)            (: 'order' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'return' :)
      let $state := p:shift(168, $input, $state)            (: 'return' :)
      return $state
    else if ($state[$p:l1] = 169) then                      (: 'satisfies' :)
      let $state := p:shift(169, $input, $state)            (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 176) then                      (: 'stable' :)
      let $state := p:shift(176, $input, $state)            (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 177) then                      (: 'start' :)
      let $state := p:shift(177, $input, $state)            (: 'start' :)
      return $state
    else if ($state[$p:l1] = 184) then                      (: 'to' :)
      let $state := p:shift(184, $input, $state)            (: 'to' :)
      return $state
    else if ($state[$p:l1] = 185) then                      (: 'treat' :)
      let $state := p:shift(185, $input, $state)            (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 186) then                      (: 'try' :)
      let $state := p:shift(186, $input, $state)            (: 'try' :)
      return $state
    else if ($state[$p:l1] = 190) then                      (: 'union' :)
      let $state := p:shift(190, $input, $state)            (: 'union' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(196, $input, $state)            (: 'where' :)
      return $state
  return p:reduce($state, "NCName", $count)
};

(:~
 : Parse ModuleDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(17, $input, $state)            (: 'module' :)
  let $state := p:shift(142, $input, $state)                (: 'module' :)
  let $state := p:lookahead1W(68, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:shift(143, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(169, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' :)
  let $state := p:parse-NCName($input, $state)
  let $state := p:lookahead1W(47, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:shift(60, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(33, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state := p:parse-Separator($input, $state)
  return p:reduce($state, "ModuleDecl", $count)
};

(:~
 : Parse LibraryModule.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LibraryModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ModuleDecl($input, $state)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Prolog($input, $state)
  return p:reduce($state, "LibraryModule", $count)
};

(:~
 : Parse Separator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Separator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(52, $input, $state)                 (: ';' :)
  return p:reduce($state, "Separator", $count)
};

(:~
 : Parse VersionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VersionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(198, $input, $state)                (: 'xquery' :)
  let $state := p:lookahead1W(110, $input, $state)          (: S^WS | ('(' ':') | 'encoding' | 'version' :)
  let $state :=
    if ($state[$p:l1] = 109) then                           (: 'encoding' :)
      let $state := p:shift(109, $input, $state)            (: 'encoding' :)
      let $state := p:lookahead1W(35, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(12, $input, $state)             (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(194, $input, $state)            (: 'version' :)
      let $state := p:lookahead1W(35, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(12, $input, $state)             (: StringLiteral :)
      let $state := p:lookahead1W(101, $input, $state)      (: S^WS | ('(' ':') | ';' | 'encoding' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 109) then                  (: 'encoding' :)
          let $state := p:shift(109, $input, $state)        (: 'encoding' :)
          let $state := p:lookahead1W(35, $input, $state)   (: StringLiteral | S^WS | ('(' ':') :)
          let $state := p:shift(12, $input, $state)         (: StringLiteral :)
          return $state
        else
          $state
      return $state
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state := p:parse-Separator($input, $state)
  return p:reduce($state, "VersionDecl", $count)
};

(:~
 : Parse Module.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Module($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(223, $input, $state)          (: Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 198) then                           (: 'xquery' :)
      let $state := p:lookahead2W(176, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'div' | 'encoding' | 'eq' | 'except' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'lt' | 'mod' | 'ne' | 'or' | 'to' | 'treat' |
                                                               'union' | 'version' | '|' | '||' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 28102                          (: 'xquery' 'encoding' :)
          or $state[$p:lk] = 49862) then                    (: 'xquery' 'version' :)
      let $state := p:parse-VersionDecl($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(223, $input, $state)          (: Wildcard | EQName^Token | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral | S^WS |
                                                               '$' | '(' | '(#' | ('(' ':') | '+' | '-' | '.' | '..' |
                                                               '/' | '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 142) then                           (: 'module' :)
      let $state := p:lookahead2W(172, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'div' | 'eq' | 'except' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'lt' |
                                                               'mod' | 'namespace' | 'ne' | 'or' | 'to' | 'treat' |
                                                               'union' | '|' | '||' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 36750) then                         (: 'module' 'namespace' :)
      let $state := p:parse-LibraryModule($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-MainModuleSequence($input, $state)
      return $state
  return p:reduce($state, "Module", $count)
};

(:~
 : Parse XQuery.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-XQuery($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(31, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Module($input, $state)
  let $state := p:lookahead1W(32, $input, $state)           (: EOF | S^WS | ('(' ':') :)
  let $state := p:shift(1, $input, $state)                  (: EOF :)
  return p:reduce($state, "XQuery", $count)
};

(:~
 : Parse start symbol XQuery from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-XQuery($s as xs:string) as item()*
{
  let $state := p:parse-XQuery($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, false()))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      $state[position() >= $p:result]
};

(: End :)
